
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model HealthWorker
 * 
 */
export type HealthWorker = $Result.DefaultSelection<Prisma.$HealthWorkerPayload>
/**
 * Model FamilyRecord
 * 
 */
export type FamilyRecord = $Result.DefaultSelection<Prisma.$FamilyRecordPayload>
/**
 * Model FamilyMember
 * 
 */
export type FamilyMember = $Result.DefaultSelection<Prisma.$FamilyMemberPayload>
/**
 * Model FamilyHealthHistory
 * 
 */
export type FamilyHealthHistory = $Result.DefaultSelection<Prisma.$FamilyHealthHistoryPayload>
/**
 * Model MaternalHealth
 * 
 */
export type MaternalHealth = $Result.DefaultSelection<Prisma.$MaternalHealthPayload>
/**
 * Model PrenatalVisit
 * 
 */
export type PrenatalVisit = $Result.DefaultSelection<Prisma.$PrenatalVisitPayload>
/**
 * Model LaboratoryTest
 * 
 */
export type LaboratoryTest = $Result.DefaultSelection<Prisma.$LaboratoryTestPayload>
/**
 * Model Intervention
 * 
 */
export type Intervention = $Result.DefaultSelection<Prisma.$InterventionPayload>
/**
 * Model BirthInformation
 * 
 */
export type BirthInformation = $Result.DefaultSelection<Prisma.$BirthInformationPayload>
/**
 * Model ImmunizationEvent
 * 
 */
export type ImmunizationEvent = $Result.DefaultSelection<Prisma.$ImmunizationEventPayload>
/**
 * Model VaccineGiven
 * 
 */
export type VaccineGiven = $Result.DefaultSelection<Prisma.$VaccineGivenPayload>
/**
 * Model VitalSigns
 * 
 */
export type VitalSigns = $Result.DefaultSelection<Prisma.$VitalSignsPayload>
/**
 * Model AnthropometricMeasurement
 * 
 */
export type AnthropometricMeasurement = $Result.DefaultSelection<Prisma.$AnthropometricMeasurementPayload>
/**
 * Model GrowthTracking
 * 
 */
export type GrowthTracking = $Result.DefaultSelection<Prisma.$GrowthTrackingPayload>
/**
 * Model NCDRiskAssessment
 * 
 */
export type NCDRiskAssessment = $Result.DefaultSelection<Prisma.$NCDRiskAssessmentPayload>
/**
 * Model VisitRecord
 * 
 */
export type VisitRecord = $Result.DefaultSelection<Prisma.$VisitRecordPayload>
/**
 * Model HealthEducation
 * 
 */
export type HealthEducation = $Result.DefaultSelection<Prisma.$HealthEducationPayload>
/**
 * Model NutritionalCounseling
 * 
 */
export type NutritionalCounseling = $Result.DefaultSelection<Prisma.$NutritionalCounselingPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model ImmunizationReminder
 * 
 */
export type ImmunizationReminder = $Result.DefaultSelection<Prisma.$ImmunizationReminderPayload>
/**
 * Model TestReminder
 * 
 */
export type TestReminder = $Result.DefaultSelection<Prisma.$TestReminderPayload>
/**
 * Model VirtualCheckup
 * 
 */
export type VirtualCheckup = $Result.DefaultSelection<Prisma.$VirtualCheckupPayload>
/**
 * Model VirtualCheckupNote
 * 
 */
export type VirtualCheckupNote = $Result.DefaultSelection<Prisma.$VirtualCheckupNotePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventRegistration
 * 
 */
export type EventRegistration = $Result.DefaultSelection<Prisma.$EventRegistrationPayload>
/**
 * Model MedicalProgram
 * 
 */
export type MedicalProgram = $Result.DefaultSelection<Prisma.$MedicalProgramPayload>
/**
 * Model ProgramParticipation
 * 
 */
export type ProgramParticipation = $Result.DefaultSelection<Prisma.$ProgramParticipationPayload>
/**
 * Model Inquiry
 * 
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>
/**
 * Model InquiryResponse
 * 
 */
export type InquiryResponse = $Result.DefaultSelection<Prisma.$InquiryResponsePayload>
/**
 * Model Survey
 * 
 */
export type Survey = $Result.DefaultSelection<Prisma.$SurveyPayload>
/**
 * Model SurveyQuestion
 * 
 */
export type SurveyQuestion = $Result.DefaultSelection<Prisma.$SurveyQuestionPayload>
/**
 * Model SurveyResponse
 * 
 */
export type SurveyResponse = $Result.DefaultSelection<Prisma.$SurveyResponsePayload>
/**
 * Model SurveyAnswer
 * 
 */
export type SurveyAnswer = $Result.DefaultSelection<Prisma.$SurveyAnswerPayload>
/**
 * Model AnalyticsReport
 * 
 */
export type AnalyticsReport = $Result.DefaultSelection<Prisma.$AnalyticsReportPayload>
/**
 * Model PredictionModel
 * 
 */
export type PredictionModel = $Result.DefaultSelection<Prisma.$PredictionModelPayload>
/**
 * Model SystemLog
 * 
 */
export type SystemLog = $Result.DefaultSelection<Prisma.$SystemLogPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.healthWorker`: Exposes CRUD operations for the **HealthWorker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthWorkers
    * const healthWorkers = await prisma.healthWorker.findMany()
    * ```
    */
  get healthWorker(): Prisma.HealthWorkerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyRecord`: Exposes CRUD operations for the **FamilyRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyRecords
    * const familyRecords = await prisma.familyRecord.findMany()
    * ```
    */
  get familyRecord(): Prisma.FamilyRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyMember`: Exposes CRUD operations for the **FamilyMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyMembers
    * const familyMembers = await prisma.familyMember.findMany()
    * ```
    */
  get familyMember(): Prisma.FamilyMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.familyHealthHistory`: Exposes CRUD operations for the **FamilyHealthHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FamilyHealthHistories
    * const familyHealthHistories = await prisma.familyHealthHistory.findMany()
    * ```
    */
  get familyHealthHistory(): Prisma.FamilyHealthHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maternalHealth`: Exposes CRUD operations for the **MaternalHealth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaternalHealths
    * const maternalHealths = await prisma.maternalHealth.findMany()
    * ```
    */
  get maternalHealth(): Prisma.MaternalHealthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prenatalVisit`: Exposes CRUD operations for the **PrenatalVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrenatalVisits
    * const prenatalVisits = await prisma.prenatalVisit.findMany()
    * ```
    */
  get prenatalVisit(): Prisma.PrenatalVisitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.laboratoryTest`: Exposes CRUD operations for the **LaboratoryTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LaboratoryTests
    * const laboratoryTests = await prisma.laboratoryTest.findMany()
    * ```
    */
  get laboratoryTest(): Prisma.LaboratoryTestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.intervention`: Exposes CRUD operations for the **Intervention** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interventions
    * const interventions = await prisma.intervention.findMany()
    * ```
    */
  get intervention(): Prisma.InterventionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.birthInformation`: Exposes CRUD operations for the **BirthInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BirthInformations
    * const birthInformations = await prisma.birthInformation.findMany()
    * ```
    */
  get birthInformation(): Prisma.BirthInformationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.immunizationEvent`: Exposes CRUD operations for the **ImmunizationEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImmunizationEvents
    * const immunizationEvents = await prisma.immunizationEvent.findMany()
    * ```
    */
  get immunizationEvent(): Prisma.ImmunizationEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccineGiven`: Exposes CRUD operations for the **VaccineGiven** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccineGivens
    * const vaccineGivens = await prisma.vaccineGiven.findMany()
    * ```
    */
  get vaccineGiven(): Prisma.VaccineGivenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vitalSigns`: Exposes CRUD operations for the **VitalSigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitalSigns
    * const vitalSigns = await prisma.vitalSigns.findMany()
    * ```
    */
  get vitalSigns(): Prisma.VitalSignsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.anthropometricMeasurement`: Exposes CRUD operations for the **AnthropometricMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnthropometricMeasurements
    * const anthropometricMeasurements = await prisma.anthropometricMeasurement.findMany()
    * ```
    */
  get anthropometricMeasurement(): Prisma.AnthropometricMeasurementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.growthTracking`: Exposes CRUD operations for the **GrowthTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GrowthTrackings
    * const growthTrackings = await prisma.growthTracking.findMany()
    * ```
    */
  get growthTracking(): Prisma.GrowthTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nCDRiskAssessment`: Exposes CRUD operations for the **NCDRiskAssessment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NCDRiskAssessments
    * const nCDRiskAssessments = await prisma.nCDRiskAssessment.findMany()
    * ```
    */
  get nCDRiskAssessment(): Prisma.NCDRiskAssessmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visitRecord`: Exposes CRUD operations for the **VisitRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisitRecords
    * const visitRecords = await prisma.visitRecord.findMany()
    * ```
    */
  get visitRecord(): Prisma.VisitRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.healthEducation`: Exposes CRUD operations for the **HealthEducation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthEducations
    * const healthEducations = await prisma.healthEducation.findMany()
    * ```
    */
  get healthEducation(): Prisma.HealthEducationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nutritionalCounseling`: Exposes CRUD operations for the **NutritionalCounseling** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionalCounselings
    * const nutritionalCounselings = await prisma.nutritionalCounseling.findMany()
    * ```
    */
  get nutritionalCounseling(): Prisma.NutritionalCounselingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.immunizationReminder`: Exposes CRUD operations for the **ImmunizationReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImmunizationReminders
    * const immunizationReminders = await prisma.immunizationReminder.findMany()
    * ```
    */
  get immunizationReminder(): Prisma.ImmunizationReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testReminder`: Exposes CRUD operations for the **TestReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestReminders
    * const testReminders = await prisma.testReminder.findMany()
    * ```
    */
  get testReminder(): Prisma.TestReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.virtualCheckup`: Exposes CRUD operations for the **VirtualCheckup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VirtualCheckups
    * const virtualCheckups = await prisma.virtualCheckup.findMany()
    * ```
    */
  get virtualCheckup(): Prisma.VirtualCheckupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.virtualCheckupNote`: Exposes CRUD operations for the **VirtualCheckupNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VirtualCheckupNotes
    * const virtualCheckupNotes = await prisma.virtualCheckupNote.findMany()
    * ```
    */
  get virtualCheckupNote(): Prisma.VirtualCheckupNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventRegistration`: Exposes CRUD operations for the **EventRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventRegistrations
    * const eventRegistrations = await prisma.eventRegistration.findMany()
    * ```
    */
  get eventRegistration(): Prisma.EventRegistrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalProgram`: Exposes CRUD operations for the **MedicalProgram** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalPrograms
    * const medicalPrograms = await prisma.medicalProgram.findMany()
    * ```
    */
  get medicalProgram(): Prisma.MedicalProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programParticipation`: Exposes CRUD operations for the **ProgramParticipation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramParticipations
    * const programParticipations = await prisma.programParticipation.findMany()
    * ```
    */
  get programParticipation(): Prisma.ProgramParticipationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inquiryResponse`: Exposes CRUD operations for the **InquiryResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InquiryResponses
    * const inquiryResponses = await prisma.inquiryResponse.findMany()
    * ```
    */
  get inquiryResponse(): Prisma.InquiryResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.survey`: Exposes CRUD operations for the **Survey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surveys
    * const surveys = await prisma.survey.findMany()
    * ```
    */
  get survey(): Prisma.SurveyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyQuestion`: Exposes CRUD operations for the **SurveyQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyQuestions
    * const surveyQuestions = await prisma.surveyQuestion.findMany()
    * ```
    */
  get surveyQuestion(): Prisma.SurveyQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyResponse`: Exposes CRUD operations for the **SurveyResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyResponses
    * const surveyResponses = await prisma.surveyResponse.findMany()
    * ```
    */
  get surveyResponse(): Prisma.SurveyResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surveyAnswer`: Exposes CRUD operations for the **SurveyAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurveyAnswers
    * const surveyAnswers = await prisma.surveyAnswer.findMany()
    * ```
    */
  get surveyAnswer(): Prisma.SurveyAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsReport`: Exposes CRUD operations for the **AnalyticsReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsReports
    * const analyticsReports = await prisma.analyticsReport.findMany()
    * ```
    */
  get analyticsReport(): Prisma.AnalyticsReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.predictionModel`: Exposes CRUD operations for the **PredictionModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PredictionModels
    * const predictionModels = await prisma.predictionModel.findMany()
    * ```
    */
  get predictionModel(): Prisma.PredictionModelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemLog`: Exposes CRUD operations for the **SystemLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemLogs
    * const systemLogs = await prisma.systemLog.findMany()
    * ```
    */
  get systemLog(): Prisma.SystemLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    UserProfile: 'UserProfile',
    HealthWorker: 'HealthWorker',
    FamilyRecord: 'FamilyRecord',
    FamilyMember: 'FamilyMember',
    FamilyHealthHistory: 'FamilyHealthHistory',
    MaternalHealth: 'MaternalHealth',
    PrenatalVisit: 'PrenatalVisit',
    LaboratoryTest: 'LaboratoryTest',
    Intervention: 'Intervention',
    BirthInformation: 'BirthInformation',
    ImmunizationEvent: 'ImmunizationEvent',
    VaccineGiven: 'VaccineGiven',
    VitalSigns: 'VitalSigns',
    AnthropometricMeasurement: 'AnthropometricMeasurement',
    GrowthTracking: 'GrowthTracking',
    NCDRiskAssessment: 'NCDRiskAssessment',
    VisitRecord: 'VisitRecord',
    HealthEducation: 'HealthEducation',
    NutritionalCounseling: 'NutritionalCounseling',
    Referral: 'Referral',
    Appointment: 'Appointment',
    ImmunizationReminder: 'ImmunizationReminder',
    TestReminder: 'TestReminder',
    VirtualCheckup: 'VirtualCheckup',
    VirtualCheckupNote: 'VirtualCheckupNote',
    Event: 'Event',
    EventRegistration: 'EventRegistration',
    MedicalProgram: 'MedicalProgram',
    ProgramParticipation: 'ProgramParticipation',
    Inquiry: 'Inquiry',
    InquiryResponse: 'InquiryResponse',
    Survey: 'Survey',
    SurveyQuestion: 'SurveyQuestion',
    SurveyResponse: 'SurveyResponse',
    SurveyAnswer: 'SurveyAnswer',
    AnalyticsReport: 'AnalyticsReport',
    PredictionModel: 'PredictionModel',
    SystemLog: 'SystemLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "userProfile" | "healthWorker" | "familyRecord" | "familyMember" | "familyHealthHistory" | "maternalHealth" | "prenatalVisit" | "laboratoryTest" | "intervention" | "birthInformation" | "immunizationEvent" | "vaccineGiven" | "vitalSigns" | "anthropometricMeasurement" | "growthTracking" | "nCDRiskAssessment" | "visitRecord" | "healthEducation" | "nutritionalCounseling" | "referral" | "appointment" | "immunizationReminder" | "testReminder" | "virtualCheckup" | "virtualCheckupNote" | "event" | "eventRegistration" | "medicalProgram" | "programParticipation" | "inquiry" | "inquiryResponse" | "survey" | "surveyQuestion" | "surveyResponse" | "surveyAnswer" | "analyticsReport" | "predictionModel" | "systemLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      HealthWorker: {
        payload: Prisma.$HealthWorkerPayload<ExtArgs>
        fields: Prisma.HealthWorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthWorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthWorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          findFirst: {
            args: Prisma.HealthWorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthWorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          findMany: {
            args: Prisma.HealthWorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>[]
          }
          create: {
            args: Prisma.HealthWorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          createMany: {
            args: Prisma.HealthWorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HealthWorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          update: {
            args: Prisma.HealthWorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          deleteMany: {
            args: Prisma.HealthWorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthWorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthWorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthWorkerPayload>
          }
          aggregate: {
            args: Prisma.HealthWorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthWorker>
          }
          groupBy: {
            args: Prisma.HealthWorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthWorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthWorkerCountArgs<ExtArgs>
            result: $Utils.Optional<HealthWorkerCountAggregateOutputType> | number
          }
        }
      }
      FamilyRecord: {
        payload: Prisma.$FamilyRecordPayload<ExtArgs>
        fields: Prisma.FamilyRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload>
          }
          findFirst: {
            args: Prisma.FamilyRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload>
          }
          findMany: {
            args: Prisma.FamilyRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload>[]
          }
          create: {
            args: Prisma.FamilyRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload>
          }
          createMany: {
            args: Prisma.FamilyRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload>
          }
          update: {
            args: Prisma.FamilyRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload>
          }
          deleteMany: {
            args: Prisma.FamilyRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyRecordPayload>
          }
          aggregate: {
            args: Prisma.FamilyRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyRecord>
          }
          groupBy: {
            args: Prisma.FamilyRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyRecordCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyRecordCountAggregateOutputType> | number
          }
        }
      }
      FamilyMember: {
        payload: Prisma.$FamilyMemberPayload<ExtArgs>
        fields: Prisma.FamilyMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findFirst: {
            args: Prisma.FamilyMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          findMany: {
            args: Prisma.FamilyMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>[]
          }
          create: {
            args: Prisma.FamilyMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          createMany: {
            args: Prisma.FamilyMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          update: {
            args: Prisma.FamilyMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          deleteMany: {
            args: Prisma.FamilyMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyMemberPayload>
          }
          aggregate: {
            args: Prisma.FamilyMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyMember>
          }
          groupBy: {
            args: Prisma.FamilyMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyMemberCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyMemberCountAggregateOutputType> | number
          }
        }
      }
      FamilyHealthHistory: {
        payload: Prisma.$FamilyHealthHistoryPayload<ExtArgs>
        fields: Prisma.FamilyHealthHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamilyHealthHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamilyHealthHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload>
          }
          findFirst: {
            args: Prisma.FamilyHealthHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamilyHealthHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload>
          }
          findMany: {
            args: Prisma.FamilyHealthHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload>[]
          }
          create: {
            args: Prisma.FamilyHealthHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload>
          }
          createMany: {
            args: Prisma.FamilyHealthHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FamilyHealthHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload>
          }
          update: {
            args: Prisma.FamilyHealthHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload>
          }
          deleteMany: {
            args: Prisma.FamilyHealthHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamilyHealthHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamilyHealthHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamilyHealthHistoryPayload>
          }
          aggregate: {
            args: Prisma.FamilyHealthHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamilyHealthHistory>
          }
          groupBy: {
            args: Prisma.FamilyHealthHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamilyHealthHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamilyHealthHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<FamilyHealthHistoryCountAggregateOutputType> | number
          }
        }
      }
      MaternalHealth: {
        payload: Prisma.$MaternalHealthPayload<ExtArgs>
        fields: Prisma.MaternalHealthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaternalHealthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaternalHealthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload>
          }
          findFirst: {
            args: Prisma.MaternalHealthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaternalHealthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload>
          }
          findMany: {
            args: Prisma.MaternalHealthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload>[]
          }
          create: {
            args: Prisma.MaternalHealthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload>
          }
          createMany: {
            args: Prisma.MaternalHealthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MaternalHealthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload>
          }
          update: {
            args: Prisma.MaternalHealthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload>
          }
          deleteMany: {
            args: Prisma.MaternalHealthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaternalHealthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaternalHealthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaternalHealthPayload>
          }
          aggregate: {
            args: Prisma.MaternalHealthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaternalHealth>
          }
          groupBy: {
            args: Prisma.MaternalHealthGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaternalHealthGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaternalHealthCountArgs<ExtArgs>
            result: $Utils.Optional<MaternalHealthCountAggregateOutputType> | number
          }
        }
      }
      PrenatalVisit: {
        payload: Prisma.$PrenatalVisitPayload<ExtArgs>
        fields: Prisma.PrenatalVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrenatalVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrenatalVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload>
          }
          findFirst: {
            args: Prisma.PrenatalVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrenatalVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload>
          }
          findMany: {
            args: Prisma.PrenatalVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload>[]
          }
          create: {
            args: Prisma.PrenatalVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload>
          }
          createMany: {
            args: Prisma.PrenatalVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PrenatalVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload>
          }
          update: {
            args: Prisma.PrenatalVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload>
          }
          deleteMany: {
            args: Prisma.PrenatalVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrenatalVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrenatalVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrenatalVisitPayload>
          }
          aggregate: {
            args: Prisma.PrenatalVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrenatalVisit>
          }
          groupBy: {
            args: Prisma.PrenatalVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrenatalVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrenatalVisitCountArgs<ExtArgs>
            result: $Utils.Optional<PrenatalVisitCountAggregateOutputType> | number
          }
        }
      }
      LaboratoryTest: {
        payload: Prisma.$LaboratoryTestPayload<ExtArgs>
        fields: Prisma.LaboratoryTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaboratoryTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaboratoryTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload>
          }
          findFirst: {
            args: Prisma.LaboratoryTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaboratoryTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload>
          }
          findMany: {
            args: Prisma.LaboratoryTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload>[]
          }
          create: {
            args: Prisma.LaboratoryTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload>
          }
          createMany: {
            args: Prisma.LaboratoryTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LaboratoryTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload>
          }
          update: {
            args: Prisma.LaboratoryTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload>
          }
          deleteMany: {
            args: Prisma.LaboratoryTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaboratoryTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LaboratoryTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LaboratoryTestPayload>
          }
          aggregate: {
            args: Prisma.LaboratoryTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLaboratoryTest>
          }
          groupBy: {
            args: Prisma.LaboratoryTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaboratoryTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaboratoryTestCountArgs<ExtArgs>
            result: $Utils.Optional<LaboratoryTestCountAggregateOutputType> | number
          }
        }
      }
      Intervention: {
        payload: Prisma.$InterventionPayload<ExtArgs>
        fields: Prisma.InterventionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findFirst: {
            args: Prisma.InterventionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          findMany: {
            args: Prisma.InterventionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>[]
          }
          create: {
            args: Prisma.InterventionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          createMany: {
            args: Prisma.InterventionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InterventionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          update: {
            args: Prisma.InterventionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          deleteMany: {
            args: Prisma.InterventionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterventionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionPayload>
          }
          aggregate: {
            args: Prisma.InterventionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntervention>
          }
          groupBy: {
            args: Prisma.InterventionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionCountAggregateOutputType> | number
          }
        }
      }
      BirthInformation: {
        payload: Prisma.$BirthInformationPayload<ExtArgs>
        fields: Prisma.BirthInformationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BirthInformationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BirthInformationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload>
          }
          findFirst: {
            args: Prisma.BirthInformationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BirthInformationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload>
          }
          findMany: {
            args: Prisma.BirthInformationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload>[]
          }
          create: {
            args: Prisma.BirthInformationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload>
          }
          createMany: {
            args: Prisma.BirthInformationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BirthInformationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload>
          }
          update: {
            args: Prisma.BirthInformationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload>
          }
          deleteMany: {
            args: Prisma.BirthInformationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BirthInformationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BirthInformationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BirthInformationPayload>
          }
          aggregate: {
            args: Prisma.BirthInformationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBirthInformation>
          }
          groupBy: {
            args: Prisma.BirthInformationGroupByArgs<ExtArgs>
            result: $Utils.Optional<BirthInformationGroupByOutputType>[]
          }
          count: {
            args: Prisma.BirthInformationCountArgs<ExtArgs>
            result: $Utils.Optional<BirthInformationCountAggregateOutputType> | number
          }
        }
      }
      ImmunizationEvent: {
        payload: Prisma.$ImmunizationEventPayload<ExtArgs>
        fields: Prisma.ImmunizationEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImmunizationEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImmunizationEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload>
          }
          findFirst: {
            args: Prisma.ImmunizationEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImmunizationEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload>
          }
          findMany: {
            args: Prisma.ImmunizationEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload>[]
          }
          create: {
            args: Prisma.ImmunizationEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload>
          }
          createMany: {
            args: Prisma.ImmunizationEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImmunizationEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload>
          }
          update: {
            args: Prisma.ImmunizationEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload>
          }
          deleteMany: {
            args: Prisma.ImmunizationEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImmunizationEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImmunizationEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationEventPayload>
          }
          aggregate: {
            args: Prisma.ImmunizationEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImmunizationEvent>
          }
          groupBy: {
            args: Prisma.ImmunizationEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImmunizationEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImmunizationEventCountArgs<ExtArgs>
            result: $Utils.Optional<ImmunizationEventCountAggregateOutputType> | number
          }
        }
      }
      VaccineGiven: {
        payload: Prisma.$VaccineGivenPayload<ExtArgs>
        fields: Prisma.VaccineGivenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccineGivenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccineGivenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload>
          }
          findFirst: {
            args: Prisma.VaccineGivenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccineGivenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload>
          }
          findMany: {
            args: Prisma.VaccineGivenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload>[]
          }
          create: {
            args: Prisma.VaccineGivenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload>
          }
          createMany: {
            args: Prisma.VaccineGivenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VaccineGivenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload>
          }
          update: {
            args: Prisma.VaccineGivenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload>
          }
          deleteMany: {
            args: Prisma.VaccineGivenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccineGivenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VaccineGivenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccineGivenPayload>
          }
          aggregate: {
            args: Prisma.VaccineGivenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccineGiven>
          }
          groupBy: {
            args: Prisma.VaccineGivenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccineGivenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VaccineGivenCountArgs<ExtArgs>
            result: $Utils.Optional<VaccineGivenCountAggregateOutputType> | number
          }
        }
      }
      VitalSigns: {
        payload: Prisma.$VitalSignsPayload<ExtArgs>
        fields: Prisma.VitalSignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VitalSignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VitalSignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          findFirst: {
            args: Prisma.VitalSignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VitalSignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          findMany: {
            args: Prisma.VitalSignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>[]
          }
          create: {
            args: Prisma.VitalSignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          createMany: {
            args: Prisma.VitalSignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VitalSignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          update: {
            args: Prisma.VitalSignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          deleteMany: {
            args: Prisma.VitalSignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VitalSignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VitalSignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VitalSignsPayload>
          }
          aggregate: {
            args: Prisma.VitalSignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVitalSigns>
          }
          groupBy: {
            args: Prisma.VitalSignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VitalSignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VitalSignsCountArgs<ExtArgs>
            result: $Utils.Optional<VitalSignsCountAggregateOutputType> | number
          }
        }
      }
      AnthropometricMeasurement: {
        payload: Prisma.$AnthropometricMeasurementPayload<ExtArgs>
        fields: Prisma.AnthropometricMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnthropometricMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnthropometricMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload>
          }
          findFirst: {
            args: Prisma.AnthropometricMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnthropometricMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload>
          }
          findMany: {
            args: Prisma.AnthropometricMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload>[]
          }
          create: {
            args: Prisma.AnthropometricMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload>
          }
          createMany: {
            args: Prisma.AnthropometricMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnthropometricMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload>
          }
          update: {
            args: Prisma.AnthropometricMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.AnthropometricMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnthropometricMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnthropometricMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnthropometricMeasurementPayload>
          }
          aggregate: {
            args: Prisma.AnthropometricMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnthropometricMeasurement>
          }
          groupBy: {
            args: Prisma.AnthropometricMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnthropometricMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnthropometricMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<AnthropometricMeasurementCountAggregateOutputType> | number
          }
        }
      }
      GrowthTracking: {
        payload: Prisma.$GrowthTrackingPayload<ExtArgs>
        fields: Prisma.GrowthTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GrowthTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GrowthTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload>
          }
          findFirst: {
            args: Prisma.GrowthTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GrowthTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload>
          }
          findMany: {
            args: Prisma.GrowthTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload>[]
          }
          create: {
            args: Prisma.GrowthTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload>
          }
          createMany: {
            args: Prisma.GrowthTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GrowthTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload>
          }
          update: {
            args: Prisma.GrowthTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload>
          }
          deleteMany: {
            args: Prisma.GrowthTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GrowthTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GrowthTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GrowthTrackingPayload>
          }
          aggregate: {
            args: Prisma.GrowthTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrowthTracking>
          }
          groupBy: {
            args: Prisma.GrowthTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<GrowthTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.GrowthTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<GrowthTrackingCountAggregateOutputType> | number
          }
        }
      }
      NCDRiskAssessment: {
        payload: Prisma.$NCDRiskAssessmentPayload<ExtArgs>
        fields: Prisma.NCDRiskAssessmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NCDRiskAssessmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NCDRiskAssessmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload>
          }
          findFirst: {
            args: Prisma.NCDRiskAssessmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NCDRiskAssessmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload>
          }
          findMany: {
            args: Prisma.NCDRiskAssessmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload>[]
          }
          create: {
            args: Prisma.NCDRiskAssessmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload>
          }
          createMany: {
            args: Prisma.NCDRiskAssessmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NCDRiskAssessmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload>
          }
          update: {
            args: Prisma.NCDRiskAssessmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload>
          }
          deleteMany: {
            args: Prisma.NCDRiskAssessmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NCDRiskAssessmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NCDRiskAssessmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NCDRiskAssessmentPayload>
          }
          aggregate: {
            args: Prisma.NCDRiskAssessmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNCDRiskAssessment>
          }
          groupBy: {
            args: Prisma.NCDRiskAssessmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<NCDRiskAssessmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.NCDRiskAssessmentCountArgs<ExtArgs>
            result: $Utils.Optional<NCDRiskAssessmentCountAggregateOutputType> | number
          }
        }
      }
      VisitRecord: {
        payload: Prisma.$VisitRecordPayload<ExtArgs>
        fields: Prisma.VisitRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisitRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisitRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload>
          }
          findFirst: {
            args: Prisma.VisitRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisitRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload>
          }
          findMany: {
            args: Prisma.VisitRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload>[]
          }
          create: {
            args: Prisma.VisitRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload>
          }
          createMany: {
            args: Prisma.VisitRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisitRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload>
          }
          update: {
            args: Prisma.VisitRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload>
          }
          deleteMany: {
            args: Prisma.VisitRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisitRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisitRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisitRecordPayload>
          }
          aggregate: {
            args: Prisma.VisitRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisitRecord>
          }
          groupBy: {
            args: Prisma.VisitRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisitRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisitRecordCountArgs<ExtArgs>
            result: $Utils.Optional<VisitRecordCountAggregateOutputType> | number
          }
        }
      }
      HealthEducation: {
        payload: Prisma.$HealthEducationPayload<ExtArgs>
        fields: Prisma.HealthEducationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthEducationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthEducationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload>
          }
          findFirst: {
            args: Prisma.HealthEducationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthEducationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload>
          }
          findMany: {
            args: Prisma.HealthEducationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload>[]
          }
          create: {
            args: Prisma.HealthEducationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload>
          }
          createMany: {
            args: Prisma.HealthEducationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HealthEducationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload>
          }
          update: {
            args: Prisma.HealthEducationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload>
          }
          deleteMany: {
            args: Prisma.HealthEducationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthEducationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthEducationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthEducationPayload>
          }
          aggregate: {
            args: Prisma.HealthEducationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthEducation>
          }
          groupBy: {
            args: Prisma.HealthEducationGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthEducationGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthEducationCountArgs<ExtArgs>
            result: $Utils.Optional<HealthEducationCountAggregateOutputType> | number
          }
        }
      }
      NutritionalCounseling: {
        payload: Prisma.$NutritionalCounselingPayload<ExtArgs>
        fields: Prisma.NutritionalCounselingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NutritionalCounselingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NutritionalCounselingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload>
          }
          findFirst: {
            args: Prisma.NutritionalCounselingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NutritionalCounselingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload>
          }
          findMany: {
            args: Prisma.NutritionalCounselingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload>[]
          }
          create: {
            args: Prisma.NutritionalCounselingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload>
          }
          createMany: {
            args: Prisma.NutritionalCounselingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NutritionalCounselingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload>
          }
          update: {
            args: Prisma.NutritionalCounselingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload>
          }
          deleteMany: {
            args: Prisma.NutritionalCounselingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NutritionalCounselingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NutritionalCounselingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NutritionalCounselingPayload>
          }
          aggregate: {
            args: Prisma.NutritionalCounselingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNutritionalCounseling>
          }
          groupBy: {
            args: Prisma.NutritionalCounselingGroupByArgs<ExtArgs>
            result: $Utils.Optional<NutritionalCounselingGroupByOutputType>[]
          }
          count: {
            args: Prisma.NutritionalCounselingCountArgs<ExtArgs>
            result: $Utils.Optional<NutritionalCounselingCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      ImmunizationReminder: {
        payload: Prisma.$ImmunizationReminderPayload<ExtArgs>
        fields: Prisma.ImmunizationReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImmunizationReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImmunizationReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload>
          }
          findFirst: {
            args: Prisma.ImmunizationReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImmunizationReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload>
          }
          findMany: {
            args: Prisma.ImmunizationReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload>[]
          }
          create: {
            args: Prisma.ImmunizationReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload>
          }
          createMany: {
            args: Prisma.ImmunizationReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ImmunizationReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload>
          }
          update: {
            args: Prisma.ImmunizationReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload>
          }
          deleteMany: {
            args: Prisma.ImmunizationReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImmunizationReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImmunizationReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImmunizationReminderPayload>
          }
          aggregate: {
            args: Prisma.ImmunizationReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImmunizationReminder>
          }
          groupBy: {
            args: Prisma.ImmunizationReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImmunizationReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImmunizationReminderCountArgs<ExtArgs>
            result: $Utils.Optional<ImmunizationReminderCountAggregateOutputType> | number
          }
        }
      }
      TestReminder: {
        payload: Prisma.$TestReminderPayload<ExtArgs>
        fields: Prisma.TestReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload>
          }
          findFirst: {
            args: Prisma.TestReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload>
          }
          findMany: {
            args: Prisma.TestReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload>[]
          }
          create: {
            args: Prisma.TestReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload>
          }
          createMany: {
            args: Prisma.TestReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TestReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload>
          }
          update: {
            args: Prisma.TestReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload>
          }
          deleteMany: {
            args: Prisma.TestReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TestReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestReminderPayload>
          }
          aggregate: {
            args: Prisma.TestReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestReminder>
          }
          groupBy: {
            args: Prisma.TestReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestReminderCountArgs<ExtArgs>
            result: $Utils.Optional<TestReminderCountAggregateOutputType> | number
          }
        }
      }
      VirtualCheckup: {
        payload: Prisma.$VirtualCheckupPayload<ExtArgs>
        fields: Prisma.VirtualCheckupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VirtualCheckupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VirtualCheckupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload>
          }
          findFirst: {
            args: Prisma.VirtualCheckupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VirtualCheckupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload>
          }
          findMany: {
            args: Prisma.VirtualCheckupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload>[]
          }
          create: {
            args: Prisma.VirtualCheckupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload>
          }
          createMany: {
            args: Prisma.VirtualCheckupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VirtualCheckupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload>
          }
          update: {
            args: Prisma.VirtualCheckupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload>
          }
          deleteMany: {
            args: Prisma.VirtualCheckupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VirtualCheckupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VirtualCheckupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupPayload>
          }
          aggregate: {
            args: Prisma.VirtualCheckupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtualCheckup>
          }
          groupBy: {
            args: Prisma.VirtualCheckupGroupByArgs<ExtArgs>
            result: $Utils.Optional<VirtualCheckupGroupByOutputType>[]
          }
          count: {
            args: Prisma.VirtualCheckupCountArgs<ExtArgs>
            result: $Utils.Optional<VirtualCheckupCountAggregateOutputType> | number
          }
        }
      }
      VirtualCheckupNote: {
        payload: Prisma.$VirtualCheckupNotePayload<ExtArgs>
        fields: Prisma.VirtualCheckupNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VirtualCheckupNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VirtualCheckupNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload>
          }
          findFirst: {
            args: Prisma.VirtualCheckupNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VirtualCheckupNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload>
          }
          findMany: {
            args: Prisma.VirtualCheckupNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload>[]
          }
          create: {
            args: Prisma.VirtualCheckupNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload>
          }
          createMany: {
            args: Prisma.VirtualCheckupNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VirtualCheckupNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload>
          }
          update: {
            args: Prisma.VirtualCheckupNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload>
          }
          deleteMany: {
            args: Prisma.VirtualCheckupNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VirtualCheckupNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VirtualCheckupNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualCheckupNotePayload>
          }
          aggregate: {
            args: Prisma.VirtualCheckupNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtualCheckupNote>
          }
          groupBy: {
            args: Prisma.VirtualCheckupNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VirtualCheckupNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VirtualCheckupNoteCountArgs<ExtArgs>
            result: $Utils.Optional<VirtualCheckupNoteCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventRegistration: {
        payload: Prisma.$EventRegistrationPayload<ExtArgs>
        fields: Prisma.EventRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findFirst: {
            args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findMany: {
            args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          create: {
            args: Prisma.EventRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          createMany: {
            args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          update: {
            args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          aggregate: {
            args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventRegistration>
          }
          groupBy: {
            args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationCountAggregateOutputType> | number
          }
        }
      }
      MedicalProgram: {
        payload: Prisma.$MedicalProgramPayload<ExtArgs>
        fields: Prisma.MedicalProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload>
          }
          findFirst: {
            args: Prisma.MedicalProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload>
          }
          findMany: {
            args: Prisma.MedicalProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload>[]
          }
          create: {
            args: Prisma.MedicalProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload>
          }
          createMany: {
            args: Prisma.MedicalProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicalProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload>
          }
          update: {
            args: Prisma.MedicalProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload>
          }
          deleteMany: {
            args: Prisma.MedicalProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalProgramPayload>
          }
          aggregate: {
            args: Prisma.MedicalProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalProgram>
          }
          groupBy: {
            args: Prisma.MedicalProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalProgramCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalProgramCountAggregateOutputType> | number
          }
        }
      }
      ProgramParticipation: {
        payload: Prisma.$ProgramParticipationPayload<ExtArgs>
        fields: Prisma.ProgramParticipationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramParticipationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramParticipationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          findFirst: {
            args: Prisma.ProgramParticipationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramParticipationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          findMany: {
            args: Prisma.ProgramParticipationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>[]
          }
          create: {
            args: Prisma.ProgramParticipationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          createMany: {
            args: Prisma.ProgramParticipationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProgramParticipationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          update: {
            args: Prisma.ProgramParticipationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          deleteMany: {
            args: Prisma.ProgramParticipationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramParticipationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramParticipationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramParticipationPayload>
          }
          aggregate: {
            args: Prisma.ProgramParticipationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramParticipation>
          }
          groupBy: {
            args: Prisma.ProgramParticipationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramParticipationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramParticipationCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramParticipationCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
      InquiryResponse: {
        payload: Prisma.$InquiryResponsePayload<ExtArgs>
        fields: Prisma.InquiryResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload>
          }
          findFirst: {
            args: Prisma.InquiryResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload>
          }
          findMany: {
            args: Prisma.InquiryResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload>[]
          }
          create: {
            args: Prisma.InquiryResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload>
          }
          createMany: {
            args: Prisma.InquiryResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InquiryResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload>
          }
          update: {
            args: Prisma.InquiryResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload>
          }
          deleteMany: {
            args: Prisma.InquiryResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InquiryResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryResponsePayload>
          }
          aggregate: {
            args: Prisma.InquiryResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiryResponse>
          }
          groupBy: {
            args: Prisma.InquiryResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryResponseCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryResponseCountAggregateOutputType> | number
          }
        }
      }
      Survey: {
        payload: Prisma.$SurveyPayload<ExtArgs>
        fields: Prisma.SurveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          findFirst: {
            args: Prisma.SurveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          findMany: {
            args: Prisma.SurveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>[]
          }
          create: {
            args: Prisma.SurveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          createMany: {
            args: Prisma.SurveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SurveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          update: {
            args: Prisma.SurveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          deleteMany: {
            args: Prisma.SurveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyPayload>
          }
          aggregate: {
            args: Prisma.SurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurvey>
          }
          groupBy: {
            args: Prisma.SurveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyCountAggregateOutputType> | number
          }
        }
      }
      SurveyQuestion: {
        payload: Prisma.$SurveyQuestionPayload<ExtArgs>
        fields: Prisma.SurveyQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          findFirst: {
            args: Prisma.SurveyQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          findMany: {
            args: Prisma.SurveyQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
          }
          create: {
            args: Prisma.SurveyQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          createMany: {
            args: Prisma.SurveyQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SurveyQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          update: {
            args: Prisma.SurveyQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          deleteMany: {
            args: Prisma.SurveyQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
          }
          aggregate: {
            args: Prisma.SurveyQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyQuestion>
          }
          groupBy: {
            args: Prisma.SurveyQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyQuestionCountAggregateOutputType> | number
          }
        }
      }
      SurveyResponse: {
        payload: Prisma.$SurveyResponsePayload<ExtArgs>
        fields: Prisma.SurveyResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          findFirst: {
            args: Prisma.SurveyResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          findMany: {
            args: Prisma.SurveyResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
          }
          create: {
            args: Prisma.SurveyResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          createMany: {
            args: Prisma.SurveyResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SurveyResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          update: {
            args: Prisma.SurveyResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          deleteMany: {
            args: Prisma.SurveyResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
          }
          aggregate: {
            args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyResponse>
          }
          groupBy: {
            args: Prisma.SurveyResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyResponseCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyResponseCountAggregateOutputType> | number
          }
        }
      }
      SurveyAnswer: {
        payload: Prisma.$SurveyAnswerPayload<ExtArgs>
        fields: Prisma.SurveyAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurveyAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurveyAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
          }
          findFirst: {
            args: Prisma.SurveyAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurveyAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
          }
          findMany: {
            args: Prisma.SurveyAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>[]
          }
          create: {
            args: Prisma.SurveyAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
          }
          createMany: {
            args: Prisma.SurveyAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SurveyAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
          }
          update: {
            args: Prisma.SurveyAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
          }
          deleteMany: {
            args: Prisma.SurveyAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurveyAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SurveyAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurveyAnswerPayload>
          }
          aggregate: {
            args: Prisma.SurveyAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurveyAnswer>
          }
          groupBy: {
            args: Prisma.SurveyAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurveyAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurveyAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<SurveyAnswerCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsReport: {
        payload: Prisma.$AnalyticsReportPayload<ExtArgs>
        fields: Prisma.AnalyticsReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findMany: {
            args: Prisma.AnalyticsReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          create: {
            args: Prisma.AnalyticsReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          createMany: {
            args: Prisma.AnalyticsReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AnalyticsReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          update: {
            args: Prisma.AnalyticsReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsReport>
          }
          groupBy: {
            args: Prisma.AnalyticsReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsReportCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportCountAggregateOutputType> | number
          }
        }
      }
      PredictionModel: {
        payload: Prisma.$PredictionModelPayload<ExtArgs>
        fields: Prisma.PredictionModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PredictionModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PredictionModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload>
          }
          findFirst: {
            args: Prisma.PredictionModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PredictionModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload>
          }
          findMany: {
            args: Prisma.PredictionModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload>[]
          }
          create: {
            args: Prisma.PredictionModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload>
          }
          createMany: {
            args: Prisma.PredictionModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PredictionModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload>
          }
          update: {
            args: Prisma.PredictionModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload>
          }
          deleteMany: {
            args: Prisma.PredictionModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PredictionModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PredictionModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionModelPayload>
          }
          aggregate: {
            args: Prisma.PredictionModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePredictionModel>
          }
          groupBy: {
            args: Prisma.PredictionModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PredictionModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PredictionModelCountArgs<ExtArgs>
            result: $Utils.Optional<PredictionModelCountAggregateOutputType> | number
          }
        }
      }
      SystemLog: {
        payload: Prisma.$SystemLogPayload<ExtArgs>
        fields: Prisma.SystemLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findFirst: {
            args: Prisma.SystemLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          findMany: {
            args: Prisma.SystemLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>[]
          }
          create: {
            args: Prisma.SystemLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          createMany: {
            args: Prisma.SystemLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          update: {
            args: Prisma.SystemLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          deleteMany: {
            args: Prisma.SystemLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemLogPayload>
          }
          aggregate: {
            args: Prisma.SystemLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemLog>
          }
          groupBy: {
            args: Prisma.SystemLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemLogCountArgs<ExtArgs>
            result: $Utils.Optional<SystemLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    userProfile?: UserProfileOmit
    healthWorker?: HealthWorkerOmit
    familyRecord?: FamilyRecordOmit
    familyMember?: FamilyMemberOmit
    familyHealthHistory?: FamilyHealthHistoryOmit
    maternalHealth?: MaternalHealthOmit
    prenatalVisit?: PrenatalVisitOmit
    laboratoryTest?: LaboratoryTestOmit
    intervention?: InterventionOmit
    birthInformation?: BirthInformationOmit
    immunizationEvent?: ImmunizationEventOmit
    vaccineGiven?: VaccineGivenOmit
    vitalSigns?: VitalSignsOmit
    anthropometricMeasurement?: AnthropometricMeasurementOmit
    growthTracking?: GrowthTrackingOmit
    nCDRiskAssessment?: NCDRiskAssessmentOmit
    visitRecord?: VisitRecordOmit
    healthEducation?: HealthEducationOmit
    nutritionalCounseling?: NutritionalCounselingOmit
    referral?: ReferralOmit
    appointment?: AppointmentOmit
    immunizationReminder?: ImmunizationReminderOmit
    testReminder?: TestReminderOmit
    virtualCheckup?: VirtualCheckupOmit
    virtualCheckupNote?: VirtualCheckupNoteOmit
    event?: EventOmit
    eventRegistration?: EventRegistrationOmit
    medicalProgram?: MedicalProgramOmit
    programParticipation?: ProgramParticipationOmit
    inquiry?: InquiryOmit
    inquiryResponse?: InquiryResponseOmit
    survey?: SurveyOmit
    surveyQuestion?: SurveyQuestionOmit
    surveyResponse?: SurveyResponseOmit
    surveyAnswer?: SurveyAnswerOmit
    analyticsReport?: AnalyticsReportOmit
    predictionModel?: PredictionModelOmit
    systemLog?: SystemLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    healthWorkers: number
    events: number
    surveys: number
    inquiryResponses: number
    analyticsReports: number
    predictionModels: number
    systemLogs: number
    medicalPrograms: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthWorkers?: boolean | AccountCountOutputTypeCountHealthWorkersArgs
    events?: boolean | AccountCountOutputTypeCountEventsArgs
    surveys?: boolean | AccountCountOutputTypeCountSurveysArgs
    inquiryResponses?: boolean | AccountCountOutputTypeCountInquiryResponsesArgs
    analyticsReports?: boolean | AccountCountOutputTypeCountAnalyticsReportsArgs
    predictionModels?: boolean | AccountCountOutputTypeCountPredictionModelsArgs
    systemLogs?: boolean | AccountCountOutputTypeCountSystemLogsArgs
    medicalPrograms?: boolean | AccountCountOutputTypeCountMedicalProgramsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountHealthWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthWorkerWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSurveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountInquiryResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryResponseWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAnalyticsReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsReportWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPredictionModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionModelWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSystemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountMedicalProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalProgramWhereInput
  }


  /**
   * Count Type UserProfileCountOutputType
   */

  export type UserProfileCountOutputType = {
    familyRecordsHeaded: number
    familyMembers: number
    maternalHealthRecords: number
    birthInformation: number
    immunizationEvents: number
    vitalSigns: number
    anthropometricMeasurements: number
    growthTracking: number
    ncdRiskAssessments: number
    visitRecords: number
    healthEducation: number
    nutritionalCounseling: number
    referrals: number
    appointments: number
    immunizationReminders: number
    testReminders: number
    virtualCheckups: number
    eventRegistrations: number
    programParticipations: number
    inquiries: number
    surveyResponses: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyRecordsHeaded?: boolean | UserProfileCountOutputTypeCountFamilyRecordsHeadedArgs
    familyMembers?: boolean | UserProfileCountOutputTypeCountFamilyMembersArgs
    maternalHealthRecords?: boolean | UserProfileCountOutputTypeCountMaternalHealthRecordsArgs
    birthInformation?: boolean | UserProfileCountOutputTypeCountBirthInformationArgs
    immunizationEvents?: boolean | UserProfileCountOutputTypeCountImmunizationEventsArgs
    vitalSigns?: boolean | UserProfileCountOutputTypeCountVitalSignsArgs
    anthropometricMeasurements?: boolean | UserProfileCountOutputTypeCountAnthropometricMeasurementsArgs
    growthTracking?: boolean | UserProfileCountOutputTypeCountGrowthTrackingArgs
    ncdRiskAssessments?: boolean | UserProfileCountOutputTypeCountNcdRiskAssessmentsArgs
    visitRecords?: boolean | UserProfileCountOutputTypeCountVisitRecordsArgs
    healthEducation?: boolean | UserProfileCountOutputTypeCountHealthEducationArgs
    nutritionalCounseling?: boolean | UserProfileCountOutputTypeCountNutritionalCounselingArgs
    referrals?: boolean | UserProfileCountOutputTypeCountReferralsArgs
    appointments?: boolean | UserProfileCountOutputTypeCountAppointmentsArgs
    immunizationReminders?: boolean | UserProfileCountOutputTypeCountImmunizationRemindersArgs
    testReminders?: boolean | UserProfileCountOutputTypeCountTestRemindersArgs
    virtualCheckups?: boolean | UserProfileCountOutputTypeCountVirtualCheckupsArgs
    eventRegistrations?: boolean | UserProfileCountOutputTypeCountEventRegistrationsArgs
    programParticipations?: boolean | UserProfileCountOutputTypeCountProgramParticipationsArgs
    inquiries?: boolean | UserProfileCountOutputTypeCountInquiriesArgs
    surveyResponses?: boolean | UserProfileCountOutputTypeCountSurveyResponsesArgs
  }

  // Custom InputTypes
  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountFamilyRecordsHeadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyRecordWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountFamilyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountMaternalHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaternalHealthWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountBirthInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BirthInformationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountImmunizationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmunizationEventWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountVitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignsWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountAnthropometricMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnthropometricMeasurementWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountGrowthTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrowthTrackingWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountNcdRiskAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NCDRiskAssessmentWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountVisitRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitRecordWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountHealthEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthEducationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountNutritionalCounselingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionalCounselingWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountImmunizationRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmunizationReminderWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountTestRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestReminderWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountVirtualCheckupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualCheckupWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountEventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountProgramParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramParticipationWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountSurveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
  }


  /**
   * Count Type HealthWorkerCountOutputType
   */

  export type HealthWorkerCountOutputType = {
    virtualCheckups: number
  }

  export type HealthWorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualCheckups?: boolean | HealthWorkerCountOutputTypeCountVirtualCheckupsArgs
  }

  // Custom InputTypes
  /**
   * HealthWorkerCountOutputType without action
   */
  export type HealthWorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorkerCountOutputType
     */
    select?: HealthWorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HealthWorkerCountOutputType without action
   */
  export type HealthWorkerCountOutputTypeCountVirtualCheckupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualCheckupWhereInput
  }


  /**
   * Count Type FamilyRecordCountOutputType
   */

  export type FamilyRecordCountOutputType = {
    members: number
  }

  export type FamilyRecordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | FamilyRecordCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * FamilyRecordCountOutputType without action
   */
  export type FamilyRecordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecordCountOutputType
     */
    select?: FamilyRecordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FamilyRecordCountOutputType without action
   */
  export type FamilyRecordCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
  }


  /**
   * Count Type MaternalHealthCountOutputType
   */

  export type MaternalHealthCountOutputType = {
    prenatalVisits: number
    birthInformation: number
  }

  export type MaternalHealthCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prenatalVisits?: boolean | MaternalHealthCountOutputTypeCountPrenatalVisitsArgs
    birthInformation?: boolean | MaternalHealthCountOutputTypeCountBirthInformationArgs
  }

  // Custom InputTypes
  /**
   * MaternalHealthCountOutputType without action
   */
  export type MaternalHealthCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealthCountOutputType
     */
    select?: MaternalHealthCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaternalHealthCountOutputType without action
   */
  export type MaternalHealthCountOutputTypeCountPrenatalVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrenatalVisitWhereInput
  }

  /**
   * MaternalHealthCountOutputType without action
   */
  export type MaternalHealthCountOutputTypeCountBirthInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BirthInformationWhereInput
  }


  /**
   * Count Type PrenatalVisitCountOutputType
   */

  export type PrenatalVisitCountOutputType = {
    laboratoryTests: number
    interventions: number
  }

  export type PrenatalVisitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    laboratoryTests?: boolean | PrenatalVisitCountOutputTypeCountLaboratoryTestsArgs
    interventions?: boolean | PrenatalVisitCountOutputTypeCountInterventionsArgs
  }

  // Custom InputTypes
  /**
   * PrenatalVisitCountOutputType without action
   */
  export type PrenatalVisitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisitCountOutputType
     */
    select?: PrenatalVisitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrenatalVisitCountOutputType without action
   */
  export type PrenatalVisitCountOutputTypeCountLaboratoryTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaboratoryTestWhereInput
  }

  /**
   * PrenatalVisitCountOutputType without action
   */
  export type PrenatalVisitCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
  }


  /**
   * Count Type ImmunizationEventCountOutputType
   */

  export type ImmunizationEventCountOutputType = {
    vaccinesGiven: number
  }

  export type ImmunizationEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinesGiven?: boolean | ImmunizationEventCountOutputTypeCountVaccinesGivenArgs
  }

  // Custom InputTypes
  /**
   * ImmunizationEventCountOutputType without action
   */
  export type ImmunizationEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEventCountOutputType
     */
    select?: ImmunizationEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImmunizationEventCountOutputType without action
   */
  export type ImmunizationEventCountOutputTypeCountVaccinesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccineGivenWhereInput
  }


  /**
   * Count Type VirtualCheckupCountOutputType
   */

  export type VirtualCheckupCountOutputType = {
    virtualCheckupNotes: number
  }

  export type VirtualCheckupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualCheckupNotes?: boolean | VirtualCheckupCountOutputTypeCountVirtualCheckupNotesArgs
  }

  // Custom InputTypes
  /**
   * VirtualCheckupCountOutputType without action
   */
  export type VirtualCheckupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupCountOutputType
     */
    select?: VirtualCheckupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VirtualCheckupCountOutputType without action
   */
  export type VirtualCheckupCountOutputTypeCountVirtualCheckupNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualCheckupNoteWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    eventRegistrations: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventRegistrations?: boolean | EventCountOutputTypeCountEventRegistrationsArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }


  /**
   * Count Type MedicalProgramCountOutputType
   */

  export type MedicalProgramCountOutputType = {
    programParticipations: number
  }

  export type MedicalProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programParticipations?: boolean | MedicalProgramCountOutputTypeCountProgramParticipationsArgs
  }

  // Custom InputTypes
  /**
   * MedicalProgramCountOutputType without action
   */
  export type MedicalProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgramCountOutputType
     */
    select?: MedicalProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicalProgramCountOutputType without action
   */
  export type MedicalProgramCountOutputTypeCountProgramParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramParticipationWhereInput
  }


  /**
   * Count Type InquiryCountOutputType
   */

  export type InquiryCountOutputType = {
    inquiryResponses: number
  }

  export type InquiryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inquiryResponses?: boolean | InquiryCountOutputTypeCountInquiryResponsesArgs
  }

  // Custom InputTypes
  /**
   * InquiryCountOutputType without action
   */
  export type InquiryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryCountOutputType
     */
    select?: InquiryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InquiryCountOutputType without action
   */
  export type InquiryCountOutputTypeCountInquiryResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryResponseWhereInput
  }


  /**
   * Count Type SurveyCountOutputType
   */

  export type SurveyCountOutputType = {
    surveyQuestions: number
    surveyResponses: number
  }

  export type SurveyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyQuestions?: boolean | SurveyCountOutputTypeCountSurveyQuestionsArgs
    surveyResponses?: boolean | SurveyCountOutputTypeCountSurveyResponsesArgs
  }

  // Custom InputTypes
  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyCountOutputType
     */
    select?: SurveyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeCountSurveyQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyQuestionWhereInput
  }

  /**
   * SurveyCountOutputType without action
   */
  export type SurveyCountOutputTypeCountSurveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
  }


  /**
   * Count Type SurveyQuestionCountOutputType
   */

  export type SurveyQuestionCountOutputType = {
    surveyAnswers: number
  }

  export type SurveyQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyAnswers?: boolean | SurveyQuestionCountOutputTypeCountSurveyAnswersArgs
  }

  // Custom InputTypes
  /**
   * SurveyQuestionCountOutputType without action
   */
  export type SurveyQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestionCountOutputType
     */
    select?: SurveyQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyQuestionCountOutputType without action
   */
  export type SurveyQuestionCountOutputTypeCountSurveyAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyAnswerWhereInput
  }


  /**
   * Count Type SurveyResponseCountOutputType
   */

  export type SurveyResponseCountOutputType = {
    surveyAnswers: number
  }

  export type SurveyResponseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyAnswers?: boolean | SurveyResponseCountOutputTypeCountSurveyAnswersArgs
  }

  // Custom InputTypes
  /**
   * SurveyResponseCountOutputType without action
   */
  export type SurveyResponseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponseCountOutputType
     */
    select?: SurveyResponseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurveyResponseCountOutputType without action
   */
  export type SurveyResponseCountOutputTypeCountSurveyAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyAnswerWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profilePictureUrl: string | null
    emailVerified: boolean | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    role: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profilePictureUrl: string | null
    emailVerified: boolean | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    email: number
    password: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    profilePictureUrl: number
    emailVerified: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profilePictureUrl?: true
    emailVerified?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profilePictureUrl?: true
    emailVerified?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    profilePictureUrl?: true
    emailVerified?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    email: string
    password: string
    role: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    profilePictureUrl: string | null
    emailVerified: boolean
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profilePictureUrl?: boolean
    emailVerified?: boolean
    userProfile?: boolean | Account$userProfileArgs<ExtArgs>
    healthWorkers?: boolean | Account$healthWorkersArgs<ExtArgs>
    events?: boolean | Account$eventsArgs<ExtArgs>
    surveys?: boolean | Account$surveysArgs<ExtArgs>
    inquiryResponses?: boolean | Account$inquiryResponsesArgs<ExtArgs>
    analyticsReports?: boolean | Account$analyticsReportsArgs<ExtArgs>
    predictionModels?: boolean | Account$predictionModelsArgs<ExtArgs>
    systemLogs?: boolean | Account$systemLogsArgs<ExtArgs>
    medicalPrograms?: boolean | Account$medicalProgramsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>



  export type AccountSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profilePictureUrl?: boolean
    emailVerified?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "role" | "isActive" | "createdAt" | "updatedAt" | "profilePictureUrl" | "emailVerified", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | Account$userProfileArgs<ExtArgs>
    healthWorkers?: boolean | Account$healthWorkersArgs<ExtArgs>
    events?: boolean | Account$eventsArgs<ExtArgs>
    surveys?: boolean | Account$surveysArgs<ExtArgs>
    inquiryResponses?: boolean | Account$inquiryResponsesArgs<ExtArgs>
    analyticsReports?: boolean | Account$analyticsReportsArgs<ExtArgs>
    predictionModels?: boolean | Account$predictionModelsArgs<ExtArgs>
    systemLogs?: boolean | Account$systemLogsArgs<ExtArgs>
    medicalPrograms?: boolean | Account$medicalProgramsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs> | null
      healthWorkers: Prisma.$HealthWorkerPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      surveys: Prisma.$SurveyPayload<ExtArgs>[]
      inquiryResponses: Prisma.$InquiryResponsePayload<ExtArgs>[]
      analyticsReports: Prisma.$AnalyticsReportPayload<ExtArgs>[]
      predictionModels: Prisma.$PredictionModelPayload<ExtArgs>[]
      systemLogs: Prisma.$SystemLogPayload<ExtArgs>[]
      medicalPrograms: Prisma.$MedicalProgramPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      role: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      profilePictureUrl: string | null
      emailVerified: boolean
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends Account$userProfileArgs<ExtArgs> = {}>(args?: Subset<T, Account$userProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    healthWorkers<T extends Account$healthWorkersArgs<ExtArgs> = {}>(args?: Subset<T, Account$healthWorkersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Account$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Account$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surveys<T extends Account$surveysArgs<ExtArgs> = {}>(args?: Subset<T, Account$surveysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiryResponses<T extends Account$inquiryResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Account$inquiryResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analyticsReports<T extends Account$analyticsReportsArgs<ExtArgs> = {}>(args?: Subset<T, Account$analyticsReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    predictionModels<T extends Account$predictionModelsArgs<ExtArgs> = {}>(args?: Subset<T, Account$predictionModelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    systemLogs<T extends Account$systemLogsArgs<ExtArgs> = {}>(args?: Subset<T, Account$systemLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalPrograms<T extends Account$medicalProgramsArgs<ExtArgs> = {}>(args?: Subset<T, Account$medicalProgramsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly role: FieldRef<"Account", 'String'>
    readonly isActive: FieldRef<"Account", 'Boolean'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly profilePictureUrl: FieldRef<"Account", 'String'>
    readonly emailVerified: FieldRef<"Account", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.userProfile
   */
  export type Account$userProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * Account.healthWorkers
   */
  export type Account$healthWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    where?: HealthWorkerWhereInput
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    cursor?: HealthWorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * Account.events
   */
  export type Account$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Account.surveys
   */
  export type Account$surveysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    cursor?: SurveyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Account.inquiryResponses
   */
  export type Account$inquiryResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    where?: InquiryResponseWhereInput
    orderBy?: InquiryResponseOrderByWithRelationInput | InquiryResponseOrderByWithRelationInput[]
    cursor?: InquiryResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryResponseScalarFieldEnum | InquiryResponseScalarFieldEnum[]
  }

  /**
   * Account.analyticsReports
   */
  export type Account$analyticsReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    where?: AnalyticsReportWhereInput
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    cursor?: AnalyticsReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * Account.predictionModels
   */
  export type Account$predictionModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    where?: PredictionModelWhereInput
    orderBy?: PredictionModelOrderByWithRelationInput | PredictionModelOrderByWithRelationInput[]
    cursor?: PredictionModelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PredictionModelScalarFieldEnum | PredictionModelScalarFieldEnum[]
  }

  /**
   * Account.systemLogs
   */
  export type Account$systemLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    cursor?: SystemLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * Account.medicalPrograms
   */
  export type Account$medicalProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    where?: MedicalProgramWhereInput
    orderBy?: MedicalProgramOrderByWithRelationInput | MedicalProgramOrderByWithRelationInput[]
    cursor?: MedicalProgramWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalProgramScalarFieldEnum | MedicalProgramScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    age: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    age: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    fullName: string | null
    dateOfBirth: Date | null
    age: number | null
    gender: string | null
    address: string | null
    contactNumber: string | null
    religion: string | null
    civilStatus: string | null
    occupation: string | null
    educationLevel: string | null
    philhealthNumber: string | null
    nhtsStatus: string | null
    personWithDisability: boolean | null
    indigenousPeople: boolean | null
    createdAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    fullName: string | null
    dateOfBirth: Date | null
    age: number | null
    gender: string | null
    address: string | null
    contactNumber: string | null
    religion: string | null
    civilStatus: string | null
    occupation: string | null
    educationLevel: string | null
    philhealthNumber: string | null
    nhtsStatus: string | null
    personWithDisability: boolean | null
    indigenousPeople: boolean | null
    createdAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    accountId: number
    fullName: number
    dateOfBirth: number
    age: number
    gender: number
    address: number
    contactNumber: number
    religion: number
    civilStatus: number
    occupation: number
    educationLevel: number
    philhealthNumber: number
    nhtsStatus: number
    personWithDisability: number
    indigenousPeople: number
    createdAt: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    age?: true
  }

  export type UserProfileSumAggregateInputType = {
    age?: true
  }

  export type UserProfileMinAggregateInputType = {
    id?: true
    accountId?: true
    fullName?: true
    dateOfBirth?: true
    age?: true
    gender?: true
    address?: true
    contactNumber?: true
    religion?: true
    civilStatus?: true
    occupation?: true
    educationLevel?: true
    philhealthNumber?: true
    nhtsStatus?: true
    personWithDisability?: true
    indigenousPeople?: true
    createdAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    accountId?: true
    fullName?: true
    dateOfBirth?: true
    age?: true
    gender?: true
    address?: true
    contactNumber?: true
    religion?: true
    civilStatus?: true
    occupation?: true
    educationLevel?: true
    philhealthNumber?: true
    nhtsStatus?: true
    personWithDisability?: true
    indigenousPeople?: true
    createdAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    accountId?: true
    fullName?: true
    dateOfBirth?: true
    age?: true
    gender?: true
    address?: true
    contactNumber?: true
    religion?: true
    civilStatus?: true
    occupation?: true
    educationLevel?: true
    philhealthNumber?: true
    nhtsStatus?: true
    personWithDisability?: true
    indigenousPeople?: true
    createdAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    accountId: string
    fullName: string
    dateOfBirth: Date
    age: number
    gender: string
    address: string
    contactNumber: string
    religion: string | null
    civilStatus: string
    occupation: string | null
    educationLevel: string | null
    philhealthNumber: string | null
    nhtsStatus: string | null
    personWithDisability: boolean
    indigenousPeople: boolean
    createdAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    age?: boolean
    gender?: boolean
    address?: boolean
    contactNumber?: boolean
    religion?: boolean
    civilStatus?: boolean
    occupation?: boolean
    educationLevel?: boolean
    philhealthNumber?: boolean
    nhtsStatus?: boolean
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    familyRecordsHeaded?: boolean | UserProfile$familyRecordsHeadedArgs<ExtArgs>
    familyMembers?: boolean | UserProfile$familyMembersArgs<ExtArgs>
    maternalHealthRecords?: boolean | UserProfile$maternalHealthRecordsArgs<ExtArgs>
    birthInformation?: boolean | UserProfile$birthInformationArgs<ExtArgs>
    immunizationEvents?: boolean | UserProfile$immunizationEventsArgs<ExtArgs>
    vitalSigns?: boolean | UserProfile$vitalSignsArgs<ExtArgs>
    anthropometricMeasurements?: boolean | UserProfile$anthropometricMeasurementsArgs<ExtArgs>
    growthTracking?: boolean | UserProfile$growthTrackingArgs<ExtArgs>
    ncdRiskAssessments?: boolean | UserProfile$ncdRiskAssessmentsArgs<ExtArgs>
    visitRecords?: boolean | UserProfile$visitRecordsArgs<ExtArgs>
    healthEducation?: boolean | UserProfile$healthEducationArgs<ExtArgs>
    nutritionalCounseling?: boolean | UserProfile$nutritionalCounselingArgs<ExtArgs>
    referrals?: boolean | UserProfile$referralsArgs<ExtArgs>
    appointments?: boolean | UserProfile$appointmentsArgs<ExtArgs>
    immunizationReminders?: boolean | UserProfile$immunizationRemindersArgs<ExtArgs>
    testReminders?: boolean | UserProfile$testRemindersArgs<ExtArgs>
    virtualCheckups?: boolean | UserProfile$virtualCheckupsArgs<ExtArgs>
    eventRegistrations?: boolean | UserProfile$eventRegistrationsArgs<ExtArgs>
    programParticipations?: boolean | UserProfile$programParticipationsArgs<ExtArgs>
    inquiries?: boolean | UserProfile$inquiriesArgs<ExtArgs>
    surveyResponses?: boolean | UserProfile$surveyResponsesArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>



  export type UserProfileSelectScalar = {
    id?: boolean
    accountId?: boolean
    fullName?: boolean
    dateOfBirth?: boolean
    age?: boolean
    gender?: boolean
    address?: boolean
    contactNumber?: boolean
    religion?: boolean
    civilStatus?: boolean
    occupation?: boolean
    educationLevel?: boolean
    philhealthNumber?: boolean
    nhtsStatus?: boolean
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "fullName" | "dateOfBirth" | "age" | "gender" | "address" | "contactNumber" | "religion" | "civilStatus" | "occupation" | "educationLevel" | "philhealthNumber" | "nhtsStatus" | "personWithDisability" | "indigenousPeople" | "createdAt", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    familyRecordsHeaded?: boolean | UserProfile$familyRecordsHeadedArgs<ExtArgs>
    familyMembers?: boolean | UserProfile$familyMembersArgs<ExtArgs>
    maternalHealthRecords?: boolean | UserProfile$maternalHealthRecordsArgs<ExtArgs>
    birthInformation?: boolean | UserProfile$birthInformationArgs<ExtArgs>
    immunizationEvents?: boolean | UserProfile$immunizationEventsArgs<ExtArgs>
    vitalSigns?: boolean | UserProfile$vitalSignsArgs<ExtArgs>
    anthropometricMeasurements?: boolean | UserProfile$anthropometricMeasurementsArgs<ExtArgs>
    growthTracking?: boolean | UserProfile$growthTrackingArgs<ExtArgs>
    ncdRiskAssessments?: boolean | UserProfile$ncdRiskAssessmentsArgs<ExtArgs>
    visitRecords?: boolean | UserProfile$visitRecordsArgs<ExtArgs>
    healthEducation?: boolean | UserProfile$healthEducationArgs<ExtArgs>
    nutritionalCounseling?: boolean | UserProfile$nutritionalCounselingArgs<ExtArgs>
    referrals?: boolean | UserProfile$referralsArgs<ExtArgs>
    appointments?: boolean | UserProfile$appointmentsArgs<ExtArgs>
    immunizationReminders?: boolean | UserProfile$immunizationRemindersArgs<ExtArgs>
    testReminders?: boolean | UserProfile$testRemindersArgs<ExtArgs>
    virtualCheckups?: boolean | UserProfile$virtualCheckupsArgs<ExtArgs>
    eventRegistrations?: boolean | UserProfile$eventRegistrationsArgs<ExtArgs>
    programParticipations?: boolean | UserProfile$programParticipationsArgs<ExtArgs>
    inquiries?: boolean | UserProfile$inquiriesArgs<ExtArgs>
    surveyResponses?: boolean | UserProfile$surveyResponsesArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      familyRecordsHeaded: Prisma.$FamilyRecordPayload<ExtArgs>[]
      familyMembers: Prisma.$FamilyMemberPayload<ExtArgs>[]
      maternalHealthRecords: Prisma.$MaternalHealthPayload<ExtArgs>[]
      birthInformation: Prisma.$BirthInformationPayload<ExtArgs>[]
      immunizationEvents: Prisma.$ImmunizationEventPayload<ExtArgs>[]
      vitalSigns: Prisma.$VitalSignsPayload<ExtArgs>[]
      anthropometricMeasurements: Prisma.$AnthropometricMeasurementPayload<ExtArgs>[]
      growthTracking: Prisma.$GrowthTrackingPayload<ExtArgs>[]
      ncdRiskAssessments: Prisma.$NCDRiskAssessmentPayload<ExtArgs>[]
      visitRecords: Prisma.$VisitRecordPayload<ExtArgs>[]
      healthEducation: Prisma.$HealthEducationPayload<ExtArgs>[]
      nutritionalCounseling: Prisma.$NutritionalCounselingPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      immunizationReminders: Prisma.$ImmunizationReminderPayload<ExtArgs>[]
      testReminders: Prisma.$TestReminderPayload<ExtArgs>[]
      virtualCheckups: Prisma.$VirtualCheckupPayload<ExtArgs>[]
      eventRegistrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
      programParticipations: Prisma.$ProgramParticipationPayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
      surveyResponses: Prisma.$SurveyResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      fullName: string
      dateOfBirth: Date
      age: number
      gender: string
      address: string
      contactNumber: string
      religion: string | null
      civilStatus: string
      occupation: string | null
      educationLevel: string | null
      philhealthNumber: string | null
      nhtsStatus: string | null
      personWithDisability: boolean
      indigenousPeople: boolean
      createdAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    familyRecordsHeaded<T extends UserProfile$familyRecordsHeadedArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$familyRecordsHeadedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    familyMembers<T extends UserProfile$familyMembersArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$familyMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maternalHealthRecords<T extends UserProfile$maternalHealthRecordsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$maternalHealthRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    birthInformation<T extends UserProfile$birthInformationArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$birthInformationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    immunizationEvents<T extends UserProfile$immunizationEventsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$immunizationEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vitalSigns<T extends UserProfile$vitalSignsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$vitalSignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    anthropometricMeasurements<T extends UserProfile$anthropometricMeasurementsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$anthropometricMeasurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    growthTracking<T extends UserProfile$growthTrackingArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$growthTrackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ncdRiskAssessments<T extends UserProfile$ncdRiskAssessmentsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$ncdRiskAssessmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    visitRecords<T extends UserProfile$visitRecordsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$visitRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    healthEducation<T extends UserProfile$healthEducationArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$healthEducationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nutritionalCounseling<T extends UserProfile$nutritionalCounselingArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$nutritionalCounselingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends UserProfile$referralsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends UserProfile$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    immunizationReminders<T extends UserProfile$immunizationRemindersArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$immunizationRemindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testReminders<T extends UserProfile$testRemindersArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$testRemindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    virtualCheckups<T extends UserProfile$virtualCheckupsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$virtualCheckupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    eventRegistrations<T extends UserProfile$eventRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$eventRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programParticipations<T extends UserProfile$programParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$programParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiries<T extends UserProfile$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surveyResponses<T extends UserProfile$surveyResponsesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$surveyResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly accountId: FieldRef<"UserProfile", 'String'>
    readonly fullName: FieldRef<"UserProfile", 'String'>
    readonly dateOfBirth: FieldRef<"UserProfile", 'DateTime'>
    readonly age: FieldRef<"UserProfile", 'Int'>
    readonly gender: FieldRef<"UserProfile", 'String'>
    readonly address: FieldRef<"UserProfile", 'String'>
    readonly contactNumber: FieldRef<"UserProfile", 'String'>
    readonly religion: FieldRef<"UserProfile", 'String'>
    readonly civilStatus: FieldRef<"UserProfile", 'String'>
    readonly occupation: FieldRef<"UserProfile", 'String'>
    readonly educationLevel: FieldRef<"UserProfile", 'String'>
    readonly philhealthNumber: FieldRef<"UserProfile", 'String'>
    readonly nhtsStatus: FieldRef<"UserProfile", 'String'>
    readonly personWithDisability: FieldRef<"UserProfile", 'Boolean'>
    readonly indigenousPeople: FieldRef<"UserProfile", 'Boolean'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile.familyRecordsHeaded
   */
  export type UserProfile$familyRecordsHeadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    where?: FamilyRecordWhereInput
    orderBy?: FamilyRecordOrderByWithRelationInput | FamilyRecordOrderByWithRelationInput[]
    cursor?: FamilyRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyRecordScalarFieldEnum | FamilyRecordScalarFieldEnum[]
  }

  /**
   * UserProfile.familyMembers
   */
  export type UserProfile$familyMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    cursor?: FamilyMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * UserProfile.maternalHealthRecords
   */
  export type UserProfile$maternalHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    where?: MaternalHealthWhereInput
    orderBy?: MaternalHealthOrderByWithRelationInput | MaternalHealthOrderByWithRelationInput[]
    cursor?: MaternalHealthWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaternalHealthScalarFieldEnum | MaternalHealthScalarFieldEnum[]
  }

  /**
   * UserProfile.birthInformation
   */
  export type UserProfile$birthInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    where?: BirthInformationWhereInput
    orderBy?: BirthInformationOrderByWithRelationInput | BirthInformationOrderByWithRelationInput[]
    cursor?: BirthInformationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BirthInformationScalarFieldEnum | BirthInformationScalarFieldEnum[]
  }

  /**
   * UserProfile.immunizationEvents
   */
  export type UserProfile$immunizationEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    where?: ImmunizationEventWhereInput
    orderBy?: ImmunizationEventOrderByWithRelationInput | ImmunizationEventOrderByWithRelationInput[]
    cursor?: ImmunizationEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImmunizationEventScalarFieldEnum | ImmunizationEventScalarFieldEnum[]
  }

  /**
   * UserProfile.vitalSigns
   */
  export type UserProfile$vitalSignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    where?: VitalSignsWhereInput
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    cursor?: VitalSignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * UserProfile.anthropometricMeasurements
   */
  export type UserProfile$anthropometricMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    where?: AnthropometricMeasurementWhereInput
    orderBy?: AnthropometricMeasurementOrderByWithRelationInput | AnthropometricMeasurementOrderByWithRelationInput[]
    cursor?: AnthropometricMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnthropometricMeasurementScalarFieldEnum | AnthropometricMeasurementScalarFieldEnum[]
  }

  /**
   * UserProfile.growthTracking
   */
  export type UserProfile$growthTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    where?: GrowthTrackingWhereInput
    orderBy?: GrowthTrackingOrderByWithRelationInput | GrowthTrackingOrderByWithRelationInput[]
    cursor?: GrowthTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GrowthTrackingScalarFieldEnum | GrowthTrackingScalarFieldEnum[]
  }

  /**
   * UserProfile.ncdRiskAssessments
   */
  export type UserProfile$ncdRiskAssessmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    where?: NCDRiskAssessmentWhereInput
    orderBy?: NCDRiskAssessmentOrderByWithRelationInput | NCDRiskAssessmentOrderByWithRelationInput[]
    cursor?: NCDRiskAssessmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NCDRiskAssessmentScalarFieldEnum | NCDRiskAssessmentScalarFieldEnum[]
  }

  /**
   * UserProfile.visitRecords
   */
  export type UserProfile$visitRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    where?: VisitRecordWhereInput
    orderBy?: VisitRecordOrderByWithRelationInput | VisitRecordOrderByWithRelationInput[]
    cursor?: VisitRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisitRecordScalarFieldEnum | VisitRecordScalarFieldEnum[]
  }

  /**
   * UserProfile.healthEducation
   */
  export type UserProfile$healthEducationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    where?: HealthEducationWhereInput
    orderBy?: HealthEducationOrderByWithRelationInput | HealthEducationOrderByWithRelationInput[]
    cursor?: HealthEducationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthEducationScalarFieldEnum | HealthEducationScalarFieldEnum[]
  }

  /**
   * UserProfile.nutritionalCounseling
   */
  export type UserProfile$nutritionalCounselingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    where?: NutritionalCounselingWhereInput
    orderBy?: NutritionalCounselingOrderByWithRelationInput | NutritionalCounselingOrderByWithRelationInput[]
    cursor?: NutritionalCounselingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NutritionalCounselingScalarFieldEnum | NutritionalCounselingScalarFieldEnum[]
  }

  /**
   * UserProfile.referrals
   */
  export type UserProfile$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * UserProfile.appointments
   */
  export type UserProfile$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * UserProfile.immunizationReminders
   */
  export type UserProfile$immunizationRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    where?: ImmunizationReminderWhereInput
    orderBy?: ImmunizationReminderOrderByWithRelationInput | ImmunizationReminderOrderByWithRelationInput[]
    cursor?: ImmunizationReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImmunizationReminderScalarFieldEnum | ImmunizationReminderScalarFieldEnum[]
  }

  /**
   * UserProfile.testReminders
   */
  export type UserProfile$testRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    where?: TestReminderWhereInput
    orderBy?: TestReminderOrderByWithRelationInput | TestReminderOrderByWithRelationInput[]
    cursor?: TestReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestReminderScalarFieldEnum | TestReminderScalarFieldEnum[]
  }

  /**
   * UserProfile.virtualCheckups
   */
  export type UserProfile$virtualCheckupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    where?: VirtualCheckupWhereInput
    orderBy?: VirtualCheckupOrderByWithRelationInput | VirtualCheckupOrderByWithRelationInput[]
    cursor?: VirtualCheckupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualCheckupScalarFieldEnum | VirtualCheckupScalarFieldEnum[]
  }

  /**
   * UserProfile.eventRegistrations
   */
  export type UserProfile$eventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * UserProfile.programParticipations
   */
  export type UserProfile$programParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    where?: ProgramParticipationWhereInput
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    cursor?: ProgramParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }

  /**
   * UserProfile.inquiries
   */
  export type UserProfile$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * UserProfile.surveyResponses
   */
  export type UserProfile$surveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    cursor?: SurveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model HealthWorker
   */

  export type AggregateHealthWorker = {
    _count: HealthWorkerCountAggregateOutputType | null
    _min: HealthWorkerMinAggregateOutputType | null
    _max: HealthWorkerMaxAggregateOutputType | null
  }

  export type HealthWorkerMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    name: string | null
    role: string | null
    contactNumber: string | null
    signature: string | null
    isActive: boolean | null
  }

  export type HealthWorkerMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    name: string | null
    role: string | null
    contactNumber: string | null
    signature: string | null
    isActive: boolean | null
  }

  export type HealthWorkerCountAggregateOutputType = {
    id: number
    accountId: number
    name: number
    role: number
    contactNumber: number
    signature: number
    isActive: number
    _all: number
  }


  export type HealthWorkerMinAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    role?: true
    contactNumber?: true
    signature?: true
    isActive?: true
  }

  export type HealthWorkerMaxAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    role?: true
    contactNumber?: true
    signature?: true
    isActive?: true
  }

  export type HealthWorkerCountAggregateInputType = {
    id?: true
    accountId?: true
    name?: true
    role?: true
    contactNumber?: true
    signature?: true
    isActive?: true
    _all?: true
  }

  export type HealthWorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthWorker to aggregate.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthWorkers
    **/
    _count?: true | HealthWorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthWorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthWorkerMaxAggregateInputType
  }

  export type GetHealthWorkerAggregateType<T extends HealthWorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthWorker[P]>
      : GetScalarType<T[P], AggregateHealthWorker[P]>
  }




  export type HealthWorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthWorkerWhereInput
    orderBy?: HealthWorkerOrderByWithAggregationInput | HealthWorkerOrderByWithAggregationInput[]
    by: HealthWorkerScalarFieldEnum[] | HealthWorkerScalarFieldEnum
    having?: HealthWorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthWorkerCountAggregateInputType | true
    _min?: HealthWorkerMinAggregateInputType
    _max?: HealthWorkerMaxAggregateInputType
  }

  export type HealthWorkerGroupByOutputType = {
    id: string
    accountId: string
    name: string
    role: string
    contactNumber: string
    signature: string | null
    isActive: boolean
    _count: HealthWorkerCountAggregateOutputType | null
    _min: HealthWorkerMinAggregateOutputType | null
    _max: HealthWorkerMaxAggregateOutputType | null
  }

  type GetHealthWorkerGroupByPayload<T extends HealthWorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthWorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthWorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthWorkerGroupByOutputType[P]>
            : GetScalarType<T[P], HealthWorkerGroupByOutputType[P]>
        }
      >
    >


  export type HealthWorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    name?: boolean
    role?: boolean
    contactNumber?: boolean
    signature?: boolean
    isActive?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    virtualCheckups?: boolean | HealthWorker$virtualCheckupsArgs<ExtArgs>
    _count?: boolean | HealthWorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthWorker"]>



  export type HealthWorkerSelectScalar = {
    id?: boolean
    accountId?: boolean
    name?: boolean
    role?: boolean
    contactNumber?: boolean
    signature?: boolean
    isActive?: boolean
  }

  export type HealthWorkerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "name" | "role" | "contactNumber" | "signature" | "isActive", ExtArgs["result"]["healthWorker"]>
  export type HealthWorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    virtualCheckups?: boolean | HealthWorker$virtualCheckupsArgs<ExtArgs>
    _count?: boolean | HealthWorkerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $HealthWorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthWorker"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      virtualCheckups: Prisma.$VirtualCheckupPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      name: string
      role: string
      contactNumber: string
      signature: string | null
      isActive: boolean
    }, ExtArgs["result"]["healthWorker"]>
    composites: {}
  }

  type HealthWorkerGetPayload<S extends boolean | null | undefined | HealthWorkerDefaultArgs> = $Result.GetResult<Prisma.$HealthWorkerPayload, S>

  type HealthWorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HealthWorkerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HealthWorkerCountAggregateInputType | true
    }

  export interface HealthWorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthWorker'], meta: { name: 'HealthWorker' } }
    /**
     * Find zero or one HealthWorker that matches the filter.
     * @param {HealthWorkerFindUniqueArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthWorkerFindUniqueArgs>(args: SelectSubset<T, HealthWorkerFindUniqueArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HealthWorker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HealthWorkerFindUniqueOrThrowArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthWorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthWorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthWorker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerFindFirstArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthWorkerFindFirstArgs>(args?: SelectSubset<T, HealthWorkerFindFirstArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthWorker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerFindFirstOrThrowArgs} args - Arguments to find a HealthWorker
     * @example
     * // Get one HealthWorker
     * const healthWorker = await prisma.healthWorker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthWorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthWorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HealthWorkers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthWorkers
     * const healthWorkers = await prisma.healthWorker.findMany()
     * 
     * // Get first 10 HealthWorkers
     * const healthWorkers = await prisma.healthWorker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthWorkerWithIdOnly = await prisma.healthWorker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthWorkerFindManyArgs>(args?: SelectSubset<T, HealthWorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HealthWorker.
     * @param {HealthWorkerCreateArgs} args - Arguments to create a HealthWorker.
     * @example
     * // Create one HealthWorker
     * const HealthWorker = await prisma.healthWorker.create({
     *   data: {
     *     // ... data to create a HealthWorker
     *   }
     * })
     * 
     */
    create<T extends HealthWorkerCreateArgs>(args: SelectSubset<T, HealthWorkerCreateArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HealthWorkers.
     * @param {HealthWorkerCreateManyArgs} args - Arguments to create many HealthWorkers.
     * @example
     * // Create many HealthWorkers
     * const healthWorker = await prisma.healthWorker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthWorkerCreateManyArgs>(args?: SelectSubset<T, HealthWorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HealthWorker.
     * @param {HealthWorkerDeleteArgs} args - Arguments to delete one HealthWorker.
     * @example
     * // Delete one HealthWorker
     * const HealthWorker = await prisma.healthWorker.delete({
     *   where: {
     *     // ... filter to delete one HealthWorker
     *   }
     * })
     * 
     */
    delete<T extends HealthWorkerDeleteArgs>(args: SelectSubset<T, HealthWorkerDeleteArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HealthWorker.
     * @param {HealthWorkerUpdateArgs} args - Arguments to update one HealthWorker.
     * @example
     * // Update one HealthWorker
     * const healthWorker = await prisma.healthWorker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthWorkerUpdateArgs>(args: SelectSubset<T, HealthWorkerUpdateArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HealthWorkers.
     * @param {HealthWorkerDeleteManyArgs} args - Arguments to filter HealthWorkers to delete.
     * @example
     * // Delete a few HealthWorkers
     * const { count } = await prisma.healthWorker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthWorkerDeleteManyArgs>(args?: SelectSubset<T, HealthWorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthWorkers
     * const healthWorker = await prisma.healthWorker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthWorkerUpdateManyArgs>(args: SelectSubset<T, HealthWorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthWorker.
     * @param {HealthWorkerUpsertArgs} args - Arguments to update or create a HealthWorker.
     * @example
     * // Update or create a HealthWorker
     * const healthWorker = await prisma.healthWorker.upsert({
     *   create: {
     *     // ... data to create a HealthWorker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthWorker we want to update
     *   }
     * })
     */
    upsert<T extends HealthWorkerUpsertArgs>(args: SelectSubset<T, HealthWorkerUpsertArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HealthWorkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerCountArgs} args - Arguments to filter HealthWorkers to count.
     * @example
     * // Count the number of HealthWorkers
     * const count = await prisma.healthWorker.count({
     *   where: {
     *     // ... the filter for the HealthWorkers we want to count
     *   }
     * })
    **/
    count<T extends HealthWorkerCountArgs>(
      args?: Subset<T, HealthWorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthWorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthWorkerAggregateArgs>(args: Subset<T, HealthWorkerAggregateArgs>): Prisma.PrismaPromise<GetHealthWorkerAggregateType<T>>

    /**
     * Group by HealthWorker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthWorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthWorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthWorkerGroupByArgs['orderBy'] }
        : { orderBy?: HealthWorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthWorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthWorker model
   */
  readonly fields: HealthWorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthWorker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthWorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    virtualCheckups<T extends HealthWorker$virtualCheckupsArgs<ExtArgs> = {}>(args?: Subset<T, HealthWorker$virtualCheckupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthWorker model
   */
  interface HealthWorkerFieldRefs {
    readonly id: FieldRef<"HealthWorker", 'String'>
    readonly accountId: FieldRef<"HealthWorker", 'String'>
    readonly name: FieldRef<"HealthWorker", 'String'>
    readonly role: FieldRef<"HealthWorker", 'String'>
    readonly contactNumber: FieldRef<"HealthWorker", 'String'>
    readonly signature: FieldRef<"HealthWorker", 'String'>
    readonly isActive: FieldRef<"HealthWorker", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * HealthWorker findUnique
   */
  export type HealthWorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker findUniqueOrThrow
   */
  export type HealthWorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker findFirst
   */
  export type HealthWorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthWorkers.
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthWorkers.
     */
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * HealthWorker findFirstOrThrow
   */
  export type HealthWorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorker to fetch.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthWorkers.
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthWorkers.
     */
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * HealthWorker findMany
   */
  export type HealthWorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter, which HealthWorkers to fetch.
     */
    where?: HealthWorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthWorkers to fetch.
     */
    orderBy?: HealthWorkerOrderByWithRelationInput | HealthWorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthWorkers.
     */
    cursor?: HealthWorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthWorkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthWorkers.
     */
    skip?: number
    distinct?: HealthWorkerScalarFieldEnum | HealthWorkerScalarFieldEnum[]
  }

  /**
   * HealthWorker create
   */
  export type HealthWorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthWorker.
     */
    data: XOR<HealthWorkerCreateInput, HealthWorkerUncheckedCreateInput>
  }

  /**
   * HealthWorker createMany
   */
  export type HealthWorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthWorkers.
     */
    data: HealthWorkerCreateManyInput | HealthWorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthWorker update
   */
  export type HealthWorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthWorker.
     */
    data: XOR<HealthWorkerUpdateInput, HealthWorkerUncheckedUpdateInput>
    /**
     * Choose, which HealthWorker to update.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker updateMany
   */
  export type HealthWorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthWorkers.
     */
    data: XOR<HealthWorkerUpdateManyMutationInput, HealthWorkerUncheckedUpdateManyInput>
    /**
     * Filter which HealthWorkers to update
     */
    where?: HealthWorkerWhereInput
    /**
     * Limit how many HealthWorkers to update.
     */
    limit?: number
  }

  /**
   * HealthWorker upsert
   */
  export type HealthWorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthWorker to update in case it exists.
     */
    where: HealthWorkerWhereUniqueInput
    /**
     * In case the HealthWorker found by the `where` argument doesn't exist, create a new HealthWorker with this data.
     */
    create: XOR<HealthWorkerCreateInput, HealthWorkerUncheckedCreateInput>
    /**
     * In case the HealthWorker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthWorkerUpdateInput, HealthWorkerUncheckedUpdateInput>
  }

  /**
   * HealthWorker delete
   */
  export type HealthWorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
    /**
     * Filter which HealthWorker to delete.
     */
    where: HealthWorkerWhereUniqueInput
  }

  /**
   * HealthWorker deleteMany
   */
  export type HealthWorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthWorkers to delete
     */
    where?: HealthWorkerWhereInput
    /**
     * Limit how many HealthWorkers to delete.
     */
    limit?: number
  }

  /**
   * HealthWorker.virtualCheckups
   */
  export type HealthWorker$virtualCheckupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    where?: VirtualCheckupWhereInput
    orderBy?: VirtualCheckupOrderByWithRelationInput | VirtualCheckupOrderByWithRelationInput[]
    cursor?: VirtualCheckupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualCheckupScalarFieldEnum | VirtualCheckupScalarFieldEnum[]
  }

  /**
   * HealthWorker without action
   */
  export type HealthWorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthWorker
     */
    select?: HealthWorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthWorker
     */
    omit?: HealthWorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthWorkerInclude<ExtArgs> | null
  }


  /**
   * Model FamilyRecord
   */

  export type AggregateFamilyRecord = {
    _count: FamilyRecordCountAggregateOutputType | null
    _min: FamilyRecordMinAggregateOutputType | null
    _max: FamilyRecordMaxAggregateOutputType | null
  }

  export type FamilyRecordMinAggregateOutputType = {
    id: string | null
    familyId: string | null
    headOfFamilyId: string | null
    address: string | null
    contactNumber: string | null
    smsConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyRecordMaxAggregateOutputType = {
    id: string | null
    familyId: string | null
    headOfFamilyId: string | null
    address: string | null
    contactNumber: string | null
    smsConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamilyRecordCountAggregateOutputType = {
    id: number
    familyId: number
    headOfFamilyId: number
    address: number
    contactNumber: number
    smsConsent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FamilyRecordMinAggregateInputType = {
    id?: true
    familyId?: true
    headOfFamilyId?: true
    address?: true
    contactNumber?: true
    smsConsent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyRecordMaxAggregateInputType = {
    id?: true
    familyId?: true
    headOfFamilyId?: true
    address?: true
    contactNumber?: true
    smsConsent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamilyRecordCountAggregateInputType = {
    id?: true
    familyId?: true
    headOfFamilyId?: true
    address?: true
    contactNumber?: true
    smsConsent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FamilyRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyRecord to aggregate.
     */
    where?: FamilyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyRecords to fetch.
     */
    orderBy?: FamilyRecordOrderByWithRelationInput | FamilyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyRecords
    **/
    _count?: true | FamilyRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyRecordMaxAggregateInputType
  }

  export type GetFamilyRecordAggregateType<T extends FamilyRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyRecord[P]>
      : GetScalarType<T[P], AggregateFamilyRecord[P]>
  }




  export type FamilyRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyRecordWhereInput
    orderBy?: FamilyRecordOrderByWithAggregationInput | FamilyRecordOrderByWithAggregationInput[]
    by: FamilyRecordScalarFieldEnum[] | FamilyRecordScalarFieldEnum
    having?: FamilyRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyRecordCountAggregateInputType | true
    _min?: FamilyRecordMinAggregateInputType
    _max?: FamilyRecordMaxAggregateInputType
  }

  export type FamilyRecordGroupByOutputType = {
    id: string
    familyId: string
    headOfFamilyId: string
    address: string
    contactNumber: string
    smsConsent: boolean
    createdAt: Date
    updatedAt: Date
    _count: FamilyRecordCountAggregateOutputType | null
    _min: FamilyRecordMinAggregateOutputType | null
    _max: FamilyRecordMaxAggregateOutputType | null
  }

  type GetFamilyRecordGroupByPayload<T extends FamilyRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyRecordGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyRecordGroupByOutputType[P]>
        }
      >
    >


  export type FamilyRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    familyId?: boolean
    headOfFamilyId?: boolean
    address?: boolean
    contactNumber?: boolean
    smsConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    headOfFamily?: boolean | UserProfileDefaultArgs<ExtArgs>
    members?: boolean | FamilyRecord$membersArgs<ExtArgs>
    familyHealthHistory?: boolean | FamilyRecord$familyHealthHistoryArgs<ExtArgs>
    _count?: boolean | FamilyRecordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyRecord"]>



  export type FamilyRecordSelectScalar = {
    id?: boolean
    familyId?: boolean
    headOfFamilyId?: boolean
    address?: boolean
    contactNumber?: boolean
    smsConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FamilyRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "familyId" | "headOfFamilyId" | "address" | "contactNumber" | "smsConsent" | "createdAt" | "updatedAt", ExtArgs["result"]["familyRecord"]>
  export type FamilyRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    headOfFamily?: boolean | UserProfileDefaultArgs<ExtArgs>
    members?: boolean | FamilyRecord$membersArgs<ExtArgs>
    familyHealthHistory?: boolean | FamilyRecord$familyHealthHistoryArgs<ExtArgs>
    _count?: boolean | FamilyRecordCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FamilyRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyRecord"
    objects: {
      headOfFamily: Prisma.$UserProfilePayload<ExtArgs>
      members: Prisma.$FamilyMemberPayload<ExtArgs>[]
      familyHealthHistory: Prisma.$FamilyHealthHistoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      familyId: string
      headOfFamilyId: string
      address: string
      contactNumber: string
      smsConsent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["familyRecord"]>
    composites: {}
  }

  type FamilyRecordGetPayload<S extends boolean | null | undefined | FamilyRecordDefaultArgs> = $Result.GetResult<Prisma.$FamilyRecordPayload, S>

  type FamilyRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyRecordCountAggregateInputType | true
    }

  export interface FamilyRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyRecord'], meta: { name: 'FamilyRecord' } }
    /**
     * Find zero or one FamilyRecord that matches the filter.
     * @param {FamilyRecordFindUniqueArgs} args - Arguments to find a FamilyRecord
     * @example
     * // Get one FamilyRecord
     * const familyRecord = await prisma.familyRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyRecordFindUniqueArgs>(args: SelectSubset<T, FamilyRecordFindUniqueArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyRecordFindUniqueOrThrowArgs} args - Arguments to find a FamilyRecord
     * @example
     * // Get one FamilyRecord
     * const familyRecord = await prisma.familyRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyRecordFindFirstArgs} args - Arguments to find a FamilyRecord
     * @example
     * // Get one FamilyRecord
     * const familyRecord = await prisma.familyRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyRecordFindFirstArgs>(args?: SelectSubset<T, FamilyRecordFindFirstArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyRecordFindFirstOrThrowArgs} args - Arguments to find a FamilyRecord
     * @example
     * // Get one FamilyRecord
     * const familyRecord = await prisma.familyRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyRecords
     * const familyRecords = await prisma.familyRecord.findMany()
     * 
     * // Get first 10 FamilyRecords
     * const familyRecords = await prisma.familyRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyRecordWithIdOnly = await prisma.familyRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyRecordFindManyArgs>(args?: SelectSubset<T, FamilyRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyRecord.
     * @param {FamilyRecordCreateArgs} args - Arguments to create a FamilyRecord.
     * @example
     * // Create one FamilyRecord
     * const FamilyRecord = await prisma.familyRecord.create({
     *   data: {
     *     // ... data to create a FamilyRecord
     *   }
     * })
     * 
     */
    create<T extends FamilyRecordCreateArgs>(args: SelectSubset<T, FamilyRecordCreateArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyRecords.
     * @param {FamilyRecordCreateManyArgs} args - Arguments to create many FamilyRecords.
     * @example
     * // Create many FamilyRecords
     * const familyRecord = await prisma.familyRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyRecordCreateManyArgs>(args?: SelectSubset<T, FamilyRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyRecord.
     * @param {FamilyRecordDeleteArgs} args - Arguments to delete one FamilyRecord.
     * @example
     * // Delete one FamilyRecord
     * const FamilyRecord = await prisma.familyRecord.delete({
     *   where: {
     *     // ... filter to delete one FamilyRecord
     *   }
     * })
     * 
     */
    delete<T extends FamilyRecordDeleteArgs>(args: SelectSubset<T, FamilyRecordDeleteArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyRecord.
     * @param {FamilyRecordUpdateArgs} args - Arguments to update one FamilyRecord.
     * @example
     * // Update one FamilyRecord
     * const familyRecord = await prisma.familyRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyRecordUpdateArgs>(args: SelectSubset<T, FamilyRecordUpdateArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyRecords.
     * @param {FamilyRecordDeleteManyArgs} args - Arguments to filter FamilyRecords to delete.
     * @example
     * // Delete a few FamilyRecords
     * const { count } = await prisma.familyRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyRecordDeleteManyArgs>(args?: SelectSubset<T, FamilyRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyRecords
     * const familyRecord = await prisma.familyRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyRecordUpdateManyArgs>(args: SelectSubset<T, FamilyRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyRecord.
     * @param {FamilyRecordUpsertArgs} args - Arguments to update or create a FamilyRecord.
     * @example
     * // Update or create a FamilyRecord
     * const familyRecord = await prisma.familyRecord.upsert({
     *   create: {
     *     // ... data to create a FamilyRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyRecord we want to update
     *   }
     * })
     */
    upsert<T extends FamilyRecordUpsertArgs>(args: SelectSubset<T, FamilyRecordUpsertArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyRecordCountArgs} args - Arguments to filter FamilyRecords to count.
     * @example
     * // Count the number of FamilyRecords
     * const count = await prisma.familyRecord.count({
     *   where: {
     *     // ... the filter for the FamilyRecords we want to count
     *   }
     * })
    **/
    count<T extends FamilyRecordCountArgs>(
      args?: Subset<T, FamilyRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyRecordAggregateArgs>(args: Subset<T, FamilyRecordAggregateArgs>): Prisma.PrismaPromise<GetFamilyRecordAggregateType<T>>

    /**
     * Group by FamilyRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyRecordGroupByArgs['orderBy'] }
        : { orderBy?: FamilyRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyRecord model
   */
  readonly fields: FamilyRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    headOfFamily<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends FamilyRecord$membersArgs<ExtArgs> = {}>(args?: Subset<T, FamilyRecord$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    familyHealthHistory<T extends FamilyRecord$familyHealthHistoryArgs<ExtArgs> = {}>(args?: Subset<T, FamilyRecord$familyHealthHistoryArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyRecord model
   */
  interface FamilyRecordFieldRefs {
    readonly id: FieldRef<"FamilyRecord", 'String'>
    readonly familyId: FieldRef<"FamilyRecord", 'String'>
    readonly headOfFamilyId: FieldRef<"FamilyRecord", 'String'>
    readonly address: FieldRef<"FamilyRecord", 'String'>
    readonly contactNumber: FieldRef<"FamilyRecord", 'String'>
    readonly smsConsent: FieldRef<"FamilyRecord", 'Boolean'>
    readonly createdAt: FieldRef<"FamilyRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"FamilyRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FamilyRecord findUnique
   */
  export type FamilyRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * Filter, which FamilyRecord to fetch.
     */
    where: FamilyRecordWhereUniqueInput
  }

  /**
   * FamilyRecord findUniqueOrThrow
   */
  export type FamilyRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * Filter, which FamilyRecord to fetch.
     */
    where: FamilyRecordWhereUniqueInput
  }

  /**
   * FamilyRecord findFirst
   */
  export type FamilyRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * Filter, which FamilyRecord to fetch.
     */
    where?: FamilyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyRecords to fetch.
     */
    orderBy?: FamilyRecordOrderByWithRelationInput | FamilyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyRecords.
     */
    cursor?: FamilyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyRecords.
     */
    distinct?: FamilyRecordScalarFieldEnum | FamilyRecordScalarFieldEnum[]
  }

  /**
   * FamilyRecord findFirstOrThrow
   */
  export type FamilyRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * Filter, which FamilyRecord to fetch.
     */
    where?: FamilyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyRecords to fetch.
     */
    orderBy?: FamilyRecordOrderByWithRelationInput | FamilyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyRecords.
     */
    cursor?: FamilyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyRecords.
     */
    distinct?: FamilyRecordScalarFieldEnum | FamilyRecordScalarFieldEnum[]
  }

  /**
   * FamilyRecord findMany
   */
  export type FamilyRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * Filter, which FamilyRecords to fetch.
     */
    where?: FamilyRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyRecords to fetch.
     */
    orderBy?: FamilyRecordOrderByWithRelationInput | FamilyRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyRecords.
     */
    cursor?: FamilyRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyRecords.
     */
    skip?: number
    distinct?: FamilyRecordScalarFieldEnum | FamilyRecordScalarFieldEnum[]
  }

  /**
   * FamilyRecord create
   */
  export type FamilyRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyRecord.
     */
    data: XOR<FamilyRecordCreateInput, FamilyRecordUncheckedCreateInput>
  }

  /**
   * FamilyRecord createMany
   */
  export type FamilyRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyRecords.
     */
    data: FamilyRecordCreateManyInput | FamilyRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyRecord update
   */
  export type FamilyRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyRecord.
     */
    data: XOR<FamilyRecordUpdateInput, FamilyRecordUncheckedUpdateInput>
    /**
     * Choose, which FamilyRecord to update.
     */
    where: FamilyRecordWhereUniqueInput
  }

  /**
   * FamilyRecord updateMany
   */
  export type FamilyRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyRecords.
     */
    data: XOR<FamilyRecordUpdateManyMutationInput, FamilyRecordUncheckedUpdateManyInput>
    /**
     * Filter which FamilyRecords to update
     */
    where?: FamilyRecordWhereInput
    /**
     * Limit how many FamilyRecords to update.
     */
    limit?: number
  }

  /**
   * FamilyRecord upsert
   */
  export type FamilyRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyRecord to update in case it exists.
     */
    where: FamilyRecordWhereUniqueInput
    /**
     * In case the FamilyRecord found by the `where` argument doesn't exist, create a new FamilyRecord with this data.
     */
    create: XOR<FamilyRecordCreateInput, FamilyRecordUncheckedCreateInput>
    /**
     * In case the FamilyRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyRecordUpdateInput, FamilyRecordUncheckedUpdateInput>
  }

  /**
   * FamilyRecord delete
   */
  export type FamilyRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
    /**
     * Filter which FamilyRecord to delete.
     */
    where: FamilyRecordWhereUniqueInput
  }

  /**
   * FamilyRecord deleteMany
   */
  export type FamilyRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyRecords to delete
     */
    where?: FamilyRecordWhereInput
    /**
     * Limit how many FamilyRecords to delete.
     */
    limit?: number
  }

  /**
   * FamilyRecord.members
   */
  export type FamilyRecord$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    cursor?: FamilyMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyRecord.familyHealthHistory
   */
  export type FamilyRecord$familyHealthHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    where?: FamilyHealthHistoryWhereInput
  }

  /**
   * FamilyRecord without action
   */
  export type FamilyRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyRecord
     */
    select?: FamilyRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyRecord
     */
    omit?: FamilyRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyRecordInclude<ExtArgs> | null
  }


  /**
   * Model FamilyMember
   */

  export type AggregateFamilyMember = {
    _count: FamilyMemberCountAggregateOutputType | null
    _avg: FamilyMemberAvgAggregateOutputType | null
    _sum: FamilyMemberSumAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  export type FamilyMemberAvgAggregateOutputType = {
    age: number | null
  }

  export type FamilyMemberSumAggregateOutputType = {
    age: number | null
  }

  export type FamilyMemberMinAggregateOutputType = {
    id: string | null
    familyRecordId: string | null
    userProfileId: string | null
    memberName: string | null
    relationship: string | null
    gender: string | null
    age: number | null
    occupation: string | null
    civilStatus: string | null
  }

  export type FamilyMemberMaxAggregateOutputType = {
    id: string | null
    familyRecordId: string | null
    userProfileId: string | null
    memberName: string | null
    relationship: string | null
    gender: string | null
    age: number | null
    occupation: string | null
    civilStatus: string | null
  }

  export type FamilyMemberCountAggregateOutputType = {
    id: number
    familyRecordId: number
    userProfileId: number
    memberName: number
    relationship: number
    gender: number
    age: number
    occupation: number
    civilStatus: number
    _all: number
  }


  export type FamilyMemberAvgAggregateInputType = {
    age?: true
  }

  export type FamilyMemberSumAggregateInputType = {
    age?: true
  }

  export type FamilyMemberMinAggregateInputType = {
    id?: true
    familyRecordId?: true
    userProfileId?: true
    memberName?: true
    relationship?: true
    gender?: true
    age?: true
    occupation?: true
    civilStatus?: true
  }

  export type FamilyMemberMaxAggregateInputType = {
    id?: true
    familyRecordId?: true
    userProfileId?: true
    memberName?: true
    relationship?: true
    gender?: true
    age?: true
    occupation?: true
    civilStatus?: true
  }

  export type FamilyMemberCountAggregateInputType = {
    id?: true
    familyRecordId?: true
    userProfileId?: true
    memberName?: true
    relationship?: true
    gender?: true
    age?: true
    occupation?: true
    civilStatus?: true
    _all?: true
  }

  export type FamilyMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMember to aggregate.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyMembers
    **/
    _count?: true | FamilyMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamilyMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamilyMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type GetFamilyMemberAggregateType<T extends FamilyMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyMember[P]>
      : GetScalarType<T[P], AggregateFamilyMember[P]>
  }




  export type FamilyMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyMemberWhereInput
    orderBy?: FamilyMemberOrderByWithAggregationInput | FamilyMemberOrderByWithAggregationInput[]
    by: FamilyMemberScalarFieldEnum[] | FamilyMemberScalarFieldEnum
    having?: FamilyMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyMemberCountAggregateInputType | true
    _avg?: FamilyMemberAvgAggregateInputType
    _sum?: FamilyMemberSumAggregateInputType
    _min?: FamilyMemberMinAggregateInputType
    _max?: FamilyMemberMaxAggregateInputType
  }

  export type FamilyMemberGroupByOutputType = {
    id: string
    familyRecordId: string
    userProfileId: string | null
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation: string | null
    civilStatus: string
    _count: FamilyMemberCountAggregateOutputType | null
    _avg: FamilyMemberAvgAggregateOutputType | null
    _sum: FamilyMemberSumAggregateOutputType | null
    _min: FamilyMemberMinAggregateOutputType | null
    _max: FamilyMemberMaxAggregateOutputType | null
  }

  type GetFamilyMemberGroupByPayload<T extends FamilyMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyMemberGroupByOutputType[P]>
        }
      >
    >


  export type FamilyMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    familyRecordId?: boolean
    userProfileId?: boolean
    memberName?: boolean
    relationship?: boolean
    gender?: boolean
    age?: boolean
    occupation?: boolean
    civilStatus?: boolean
    familyRecord?: boolean | FamilyRecordDefaultArgs<ExtArgs>
    userProfile?: boolean | FamilyMember$userProfileArgs<ExtArgs>
  }, ExtArgs["result"]["familyMember"]>



  export type FamilyMemberSelectScalar = {
    id?: boolean
    familyRecordId?: boolean
    userProfileId?: boolean
    memberName?: boolean
    relationship?: boolean
    gender?: boolean
    age?: boolean
    occupation?: boolean
    civilStatus?: boolean
  }

  export type FamilyMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "familyRecordId" | "userProfileId" | "memberName" | "relationship" | "gender" | "age" | "occupation" | "civilStatus", ExtArgs["result"]["familyMember"]>
  export type FamilyMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyRecord?: boolean | FamilyRecordDefaultArgs<ExtArgs>
    userProfile?: boolean | FamilyMember$userProfileArgs<ExtArgs>
  }

  export type $FamilyMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyMember"
    objects: {
      familyRecord: Prisma.$FamilyRecordPayload<ExtArgs>
      userProfile: Prisma.$UserProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      familyRecordId: string
      userProfileId: string | null
      memberName: string
      relationship: string
      gender: string
      age: number
      occupation: string | null
      civilStatus: string
    }, ExtArgs["result"]["familyMember"]>
    composites: {}
  }

  type FamilyMemberGetPayload<S extends boolean | null | undefined | FamilyMemberDefaultArgs> = $Result.GetResult<Prisma.$FamilyMemberPayload, S>

  type FamilyMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyMemberCountAggregateInputType | true
    }

  export interface FamilyMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyMember'], meta: { name: 'FamilyMember' } }
    /**
     * Find zero or one FamilyMember that matches the filter.
     * @param {FamilyMemberFindUniqueArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyMemberFindUniqueArgs>(args: SelectSubset<T, FamilyMemberFindUniqueArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyMemberFindUniqueOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyMemberFindFirstArgs>(args?: SelectSubset<T, FamilyMemberFindFirstArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindFirstOrThrowArgs} args - Arguments to find a FamilyMember
     * @example
     * // Get one FamilyMember
     * const familyMember = await prisma.familyMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany()
     * 
     * // Get first 10 FamilyMembers
     * const familyMembers = await prisma.familyMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyMemberWithIdOnly = await prisma.familyMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyMemberFindManyArgs>(args?: SelectSubset<T, FamilyMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyMember.
     * @param {FamilyMemberCreateArgs} args - Arguments to create a FamilyMember.
     * @example
     * // Create one FamilyMember
     * const FamilyMember = await prisma.familyMember.create({
     *   data: {
     *     // ... data to create a FamilyMember
     *   }
     * })
     * 
     */
    create<T extends FamilyMemberCreateArgs>(args: SelectSubset<T, FamilyMemberCreateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyMembers.
     * @param {FamilyMemberCreateManyArgs} args - Arguments to create many FamilyMembers.
     * @example
     * // Create many FamilyMembers
     * const familyMember = await prisma.familyMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyMemberCreateManyArgs>(args?: SelectSubset<T, FamilyMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyMember.
     * @param {FamilyMemberDeleteArgs} args - Arguments to delete one FamilyMember.
     * @example
     * // Delete one FamilyMember
     * const FamilyMember = await prisma.familyMember.delete({
     *   where: {
     *     // ... filter to delete one FamilyMember
     *   }
     * })
     * 
     */
    delete<T extends FamilyMemberDeleteArgs>(args: SelectSubset<T, FamilyMemberDeleteArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyMember.
     * @param {FamilyMemberUpdateArgs} args - Arguments to update one FamilyMember.
     * @example
     * // Update one FamilyMember
     * const familyMember = await prisma.familyMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyMemberUpdateArgs>(args: SelectSubset<T, FamilyMemberUpdateArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyMembers.
     * @param {FamilyMemberDeleteManyArgs} args - Arguments to filter FamilyMembers to delete.
     * @example
     * // Delete a few FamilyMembers
     * const { count } = await prisma.familyMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyMemberDeleteManyArgs>(args?: SelectSubset<T, FamilyMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyMembers
     * const familyMember = await prisma.familyMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyMemberUpdateManyArgs>(args: SelectSubset<T, FamilyMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyMember.
     * @param {FamilyMemberUpsertArgs} args - Arguments to update or create a FamilyMember.
     * @example
     * // Update or create a FamilyMember
     * const familyMember = await prisma.familyMember.upsert({
     *   create: {
     *     // ... data to create a FamilyMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyMember we want to update
     *   }
     * })
     */
    upsert<T extends FamilyMemberUpsertArgs>(args: SelectSubset<T, FamilyMemberUpsertArgs<ExtArgs>>): Prisma__FamilyMemberClient<$Result.GetResult<Prisma.$FamilyMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberCountArgs} args - Arguments to filter FamilyMembers to count.
     * @example
     * // Count the number of FamilyMembers
     * const count = await prisma.familyMember.count({
     *   where: {
     *     // ... the filter for the FamilyMembers we want to count
     *   }
     * })
    **/
    count<T extends FamilyMemberCountArgs>(
      args?: Subset<T, FamilyMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyMemberAggregateArgs>(args: Subset<T, FamilyMemberAggregateArgs>): Prisma.PrismaPromise<GetFamilyMemberAggregateType<T>>

    /**
     * Group by FamilyMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyMemberGroupByArgs['orderBy'] }
        : { orderBy?: FamilyMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyMember model
   */
  readonly fields: FamilyMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyRecord<T extends FamilyRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyRecordDefaultArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userProfile<T extends FamilyMember$userProfileArgs<ExtArgs> = {}>(args?: Subset<T, FamilyMember$userProfileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyMember model
   */
  interface FamilyMemberFieldRefs {
    readonly id: FieldRef<"FamilyMember", 'String'>
    readonly familyRecordId: FieldRef<"FamilyMember", 'String'>
    readonly userProfileId: FieldRef<"FamilyMember", 'String'>
    readonly memberName: FieldRef<"FamilyMember", 'String'>
    readonly relationship: FieldRef<"FamilyMember", 'String'>
    readonly gender: FieldRef<"FamilyMember", 'String'>
    readonly age: FieldRef<"FamilyMember", 'Int'>
    readonly occupation: FieldRef<"FamilyMember", 'String'>
    readonly civilStatus: FieldRef<"FamilyMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FamilyMember findUnique
   */
  export type FamilyMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findUniqueOrThrow
   */
  export type FamilyMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember findFirst
   */
  export type FamilyMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findFirstOrThrow
   */
  export type FamilyMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMember to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyMembers.
     */
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember findMany
   */
  export type FamilyMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter, which FamilyMembers to fetch.
     */
    where?: FamilyMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyMembers to fetch.
     */
    orderBy?: FamilyMemberOrderByWithRelationInput | FamilyMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyMembers.
     */
    cursor?: FamilyMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyMembers.
     */
    skip?: number
    distinct?: FamilyMemberScalarFieldEnum | FamilyMemberScalarFieldEnum[]
  }

  /**
   * FamilyMember create
   */
  export type FamilyMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyMember.
     */
    data: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
  }

  /**
   * FamilyMember createMany
   */
  export type FamilyMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyMembers.
     */
    data: FamilyMemberCreateManyInput | FamilyMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyMember update
   */
  export type FamilyMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyMember.
     */
    data: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
    /**
     * Choose, which FamilyMember to update.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember updateMany
   */
  export type FamilyMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyMembers.
     */
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyInput>
    /**
     * Filter which FamilyMembers to update
     */
    where?: FamilyMemberWhereInput
    /**
     * Limit how many FamilyMembers to update.
     */
    limit?: number
  }

  /**
   * FamilyMember upsert
   */
  export type FamilyMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyMember to update in case it exists.
     */
    where: FamilyMemberWhereUniqueInput
    /**
     * In case the FamilyMember found by the `where` argument doesn't exist, create a new FamilyMember with this data.
     */
    create: XOR<FamilyMemberCreateInput, FamilyMemberUncheckedCreateInput>
    /**
     * In case the FamilyMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyMemberUpdateInput, FamilyMemberUncheckedUpdateInput>
  }

  /**
   * FamilyMember delete
   */
  export type FamilyMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
    /**
     * Filter which FamilyMember to delete.
     */
    where: FamilyMemberWhereUniqueInput
  }

  /**
   * FamilyMember deleteMany
   */
  export type FamilyMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyMembers to delete
     */
    where?: FamilyMemberWhereInput
    /**
     * Limit how many FamilyMembers to delete.
     */
    limit?: number
  }

  /**
   * FamilyMember.userProfile
   */
  export type FamilyMember$userProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * FamilyMember without action
   */
  export type FamilyMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyMember
     */
    select?: FamilyMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyMember
     */
    omit?: FamilyMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyMemberInclude<ExtArgs> | null
  }


  /**
   * Model FamilyHealthHistory
   */

  export type AggregateFamilyHealthHistory = {
    _count: FamilyHealthHistoryCountAggregateOutputType | null
    _min: FamilyHealthHistoryMinAggregateOutputType | null
    _max: FamilyHealthHistoryMaxAggregateOutputType | null
  }

  export type FamilyHealthHistoryMinAggregateOutputType = {
    id: string | null
    familyRecordId: string | null
    recordedDate: Date | null
    recordedBy: string | null
  }

  export type FamilyHealthHistoryMaxAggregateOutputType = {
    id: string | null
    familyRecordId: string | null
    recordedDate: Date | null
    recordedBy: string | null
  }

  export type FamilyHealthHistoryCountAggregateOutputType = {
    id: number
    familyRecordId: number
    geneticConditions: number
    chronicDiseases: number
    recordedDate: number
    recordedBy: number
    _all: number
  }


  export type FamilyHealthHistoryMinAggregateInputType = {
    id?: true
    familyRecordId?: true
    recordedDate?: true
    recordedBy?: true
  }

  export type FamilyHealthHistoryMaxAggregateInputType = {
    id?: true
    familyRecordId?: true
    recordedDate?: true
    recordedBy?: true
  }

  export type FamilyHealthHistoryCountAggregateInputType = {
    id?: true
    familyRecordId?: true
    geneticConditions?: true
    chronicDiseases?: true
    recordedDate?: true
    recordedBy?: true
    _all?: true
  }

  export type FamilyHealthHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyHealthHistory to aggregate.
     */
    where?: FamilyHealthHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyHealthHistories to fetch.
     */
    orderBy?: FamilyHealthHistoryOrderByWithRelationInput | FamilyHealthHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamilyHealthHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyHealthHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyHealthHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FamilyHealthHistories
    **/
    _count?: true | FamilyHealthHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamilyHealthHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamilyHealthHistoryMaxAggregateInputType
  }

  export type GetFamilyHealthHistoryAggregateType<T extends FamilyHealthHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFamilyHealthHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamilyHealthHistory[P]>
      : GetScalarType<T[P], AggregateFamilyHealthHistory[P]>
  }




  export type FamilyHealthHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamilyHealthHistoryWhereInput
    orderBy?: FamilyHealthHistoryOrderByWithAggregationInput | FamilyHealthHistoryOrderByWithAggregationInput[]
    by: FamilyHealthHistoryScalarFieldEnum[] | FamilyHealthHistoryScalarFieldEnum
    having?: FamilyHealthHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamilyHealthHistoryCountAggregateInputType | true
    _min?: FamilyHealthHistoryMinAggregateInputType
    _max?: FamilyHealthHistoryMaxAggregateInputType
  }

  export type FamilyHealthHistoryGroupByOutputType = {
    id: string
    familyRecordId: string
    geneticConditions: JsonValue
    chronicDiseases: JsonValue
    recordedDate: Date
    recordedBy: string
    _count: FamilyHealthHistoryCountAggregateOutputType | null
    _min: FamilyHealthHistoryMinAggregateOutputType | null
    _max: FamilyHealthHistoryMaxAggregateOutputType | null
  }

  type GetFamilyHealthHistoryGroupByPayload<T extends FamilyHealthHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamilyHealthHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamilyHealthHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamilyHealthHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], FamilyHealthHistoryGroupByOutputType[P]>
        }
      >
    >


  export type FamilyHealthHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    familyRecordId?: boolean
    geneticConditions?: boolean
    chronicDiseases?: boolean
    recordedDate?: boolean
    recordedBy?: boolean
    familyRecord?: boolean | FamilyRecordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familyHealthHistory"]>



  export type FamilyHealthHistorySelectScalar = {
    id?: boolean
    familyRecordId?: boolean
    geneticConditions?: boolean
    chronicDiseases?: boolean
    recordedDate?: boolean
    recordedBy?: boolean
  }

  export type FamilyHealthHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "familyRecordId" | "geneticConditions" | "chronicDiseases" | "recordedDate" | "recordedBy", ExtArgs["result"]["familyHealthHistory"]>
  export type FamilyHealthHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familyRecord?: boolean | FamilyRecordDefaultArgs<ExtArgs>
  }

  export type $FamilyHealthHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FamilyHealthHistory"
    objects: {
      familyRecord: Prisma.$FamilyRecordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      familyRecordId: string
      geneticConditions: Prisma.JsonValue
      chronicDiseases: Prisma.JsonValue
      recordedDate: Date
      recordedBy: string
    }, ExtArgs["result"]["familyHealthHistory"]>
    composites: {}
  }

  type FamilyHealthHistoryGetPayload<S extends boolean | null | undefined | FamilyHealthHistoryDefaultArgs> = $Result.GetResult<Prisma.$FamilyHealthHistoryPayload, S>

  type FamilyHealthHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FamilyHealthHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FamilyHealthHistoryCountAggregateInputType | true
    }

  export interface FamilyHealthHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FamilyHealthHistory'], meta: { name: 'FamilyHealthHistory' } }
    /**
     * Find zero or one FamilyHealthHistory that matches the filter.
     * @param {FamilyHealthHistoryFindUniqueArgs} args - Arguments to find a FamilyHealthHistory
     * @example
     * // Get one FamilyHealthHistory
     * const familyHealthHistory = await prisma.familyHealthHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamilyHealthHistoryFindUniqueArgs>(args: SelectSubset<T, FamilyHealthHistoryFindUniqueArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FamilyHealthHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FamilyHealthHistoryFindUniqueOrThrowArgs} args - Arguments to find a FamilyHealthHistory
     * @example
     * // Get one FamilyHealthHistory
     * const familyHealthHistory = await prisma.familyHealthHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamilyHealthHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FamilyHealthHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyHealthHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyHealthHistoryFindFirstArgs} args - Arguments to find a FamilyHealthHistory
     * @example
     * // Get one FamilyHealthHistory
     * const familyHealthHistory = await prisma.familyHealthHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamilyHealthHistoryFindFirstArgs>(args?: SelectSubset<T, FamilyHealthHistoryFindFirstArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FamilyHealthHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyHealthHistoryFindFirstOrThrowArgs} args - Arguments to find a FamilyHealthHistory
     * @example
     * // Get one FamilyHealthHistory
     * const familyHealthHistory = await prisma.familyHealthHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamilyHealthHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FamilyHealthHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FamilyHealthHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyHealthHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FamilyHealthHistories
     * const familyHealthHistories = await prisma.familyHealthHistory.findMany()
     * 
     * // Get first 10 FamilyHealthHistories
     * const familyHealthHistories = await prisma.familyHealthHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familyHealthHistoryWithIdOnly = await prisma.familyHealthHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamilyHealthHistoryFindManyArgs>(args?: SelectSubset<T, FamilyHealthHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FamilyHealthHistory.
     * @param {FamilyHealthHistoryCreateArgs} args - Arguments to create a FamilyHealthHistory.
     * @example
     * // Create one FamilyHealthHistory
     * const FamilyHealthHistory = await prisma.familyHealthHistory.create({
     *   data: {
     *     // ... data to create a FamilyHealthHistory
     *   }
     * })
     * 
     */
    create<T extends FamilyHealthHistoryCreateArgs>(args: SelectSubset<T, FamilyHealthHistoryCreateArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FamilyHealthHistories.
     * @param {FamilyHealthHistoryCreateManyArgs} args - Arguments to create many FamilyHealthHistories.
     * @example
     * // Create many FamilyHealthHistories
     * const familyHealthHistory = await prisma.familyHealthHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamilyHealthHistoryCreateManyArgs>(args?: SelectSubset<T, FamilyHealthHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FamilyHealthHistory.
     * @param {FamilyHealthHistoryDeleteArgs} args - Arguments to delete one FamilyHealthHistory.
     * @example
     * // Delete one FamilyHealthHistory
     * const FamilyHealthHistory = await prisma.familyHealthHistory.delete({
     *   where: {
     *     // ... filter to delete one FamilyHealthHistory
     *   }
     * })
     * 
     */
    delete<T extends FamilyHealthHistoryDeleteArgs>(args: SelectSubset<T, FamilyHealthHistoryDeleteArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FamilyHealthHistory.
     * @param {FamilyHealthHistoryUpdateArgs} args - Arguments to update one FamilyHealthHistory.
     * @example
     * // Update one FamilyHealthHistory
     * const familyHealthHistory = await prisma.familyHealthHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamilyHealthHistoryUpdateArgs>(args: SelectSubset<T, FamilyHealthHistoryUpdateArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FamilyHealthHistories.
     * @param {FamilyHealthHistoryDeleteManyArgs} args - Arguments to filter FamilyHealthHistories to delete.
     * @example
     * // Delete a few FamilyHealthHistories
     * const { count } = await prisma.familyHealthHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamilyHealthHistoryDeleteManyArgs>(args?: SelectSubset<T, FamilyHealthHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FamilyHealthHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyHealthHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FamilyHealthHistories
     * const familyHealthHistory = await prisma.familyHealthHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamilyHealthHistoryUpdateManyArgs>(args: SelectSubset<T, FamilyHealthHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FamilyHealthHistory.
     * @param {FamilyHealthHistoryUpsertArgs} args - Arguments to update or create a FamilyHealthHistory.
     * @example
     * // Update or create a FamilyHealthHistory
     * const familyHealthHistory = await prisma.familyHealthHistory.upsert({
     *   create: {
     *     // ... data to create a FamilyHealthHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FamilyHealthHistory we want to update
     *   }
     * })
     */
    upsert<T extends FamilyHealthHistoryUpsertArgs>(args: SelectSubset<T, FamilyHealthHistoryUpsertArgs<ExtArgs>>): Prisma__FamilyHealthHistoryClient<$Result.GetResult<Prisma.$FamilyHealthHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FamilyHealthHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyHealthHistoryCountArgs} args - Arguments to filter FamilyHealthHistories to count.
     * @example
     * // Count the number of FamilyHealthHistories
     * const count = await prisma.familyHealthHistory.count({
     *   where: {
     *     // ... the filter for the FamilyHealthHistories we want to count
     *   }
     * })
    **/
    count<T extends FamilyHealthHistoryCountArgs>(
      args?: Subset<T, FamilyHealthHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamilyHealthHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FamilyHealthHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyHealthHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamilyHealthHistoryAggregateArgs>(args: Subset<T, FamilyHealthHistoryAggregateArgs>): Prisma.PrismaPromise<GetFamilyHealthHistoryAggregateType<T>>

    /**
     * Group by FamilyHealthHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamilyHealthHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamilyHealthHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamilyHealthHistoryGroupByArgs['orderBy'] }
        : { orderBy?: FamilyHealthHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamilyHealthHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamilyHealthHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FamilyHealthHistory model
   */
  readonly fields: FamilyHealthHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FamilyHealthHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamilyHealthHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familyRecord<T extends FamilyRecordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FamilyRecordDefaultArgs<ExtArgs>>): Prisma__FamilyRecordClient<$Result.GetResult<Prisma.$FamilyRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FamilyHealthHistory model
   */
  interface FamilyHealthHistoryFieldRefs {
    readonly id: FieldRef<"FamilyHealthHistory", 'String'>
    readonly familyRecordId: FieldRef<"FamilyHealthHistory", 'String'>
    readonly geneticConditions: FieldRef<"FamilyHealthHistory", 'Json'>
    readonly chronicDiseases: FieldRef<"FamilyHealthHistory", 'Json'>
    readonly recordedDate: FieldRef<"FamilyHealthHistory", 'DateTime'>
    readonly recordedBy: FieldRef<"FamilyHealthHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FamilyHealthHistory findUnique
   */
  export type FamilyHealthHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FamilyHealthHistory to fetch.
     */
    where: FamilyHealthHistoryWhereUniqueInput
  }

  /**
   * FamilyHealthHistory findUniqueOrThrow
   */
  export type FamilyHealthHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FamilyHealthHistory to fetch.
     */
    where: FamilyHealthHistoryWhereUniqueInput
  }

  /**
   * FamilyHealthHistory findFirst
   */
  export type FamilyHealthHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FamilyHealthHistory to fetch.
     */
    where?: FamilyHealthHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyHealthHistories to fetch.
     */
    orderBy?: FamilyHealthHistoryOrderByWithRelationInput | FamilyHealthHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyHealthHistories.
     */
    cursor?: FamilyHealthHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyHealthHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyHealthHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyHealthHistories.
     */
    distinct?: FamilyHealthHistoryScalarFieldEnum | FamilyHealthHistoryScalarFieldEnum[]
  }

  /**
   * FamilyHealthHistory findFirstOrThrow
   */
  export type FamilyHealthHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FamilyHealthHistory to fetch.
     */
    where?: FamilyHealthHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyHealthHistories to fetch.
     */
    orderBy?: FamilyHealthHistoryOrderByWithRelationInput | FamilyHealthHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FamilyHealthHistories.
     */
    cursor?: FamilyHealthHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyHealthHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyHealthHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FamilyHealthHistories.
     */
    distinct?: FamilyHealthHistoryScalarFieldEnum | FamilyHealthHistoryScalarFieldEnum[]
  }

  /**
   * FamilyHealthHistory findMany
   */
  export type FamilyHealthHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FamilyHealthHistories to fetch.
     */
    where?: FamilyHealthHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FamilyHealthHistories to fetch.
     */
    orderBy?: FamilyHealthHistoryOrderByWithRelationInput | FamilyHealthHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FamilyHealthHistories.
     */
    cursor?: FamilyHealthHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FamilyHealthHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FamilyHealthHistories.
     */
    skip?: number
    distinct?: FamilyHealthHistoryScalarFieldEnum | FamilyHealthHistoryScalarFieldEnum[]
  }

  /**
   * FamilyHealthHistory create
   */
  export type FamilyHealthHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FamilyHealthHistory.
     */
    data: XOR<FamilyHealthHistoryCreateInput, FamilyHealthHistoryUncheckedCreateInput>
  }

  /**
   * FamilyHealthHistory createMany
   */
  export type FamilyHealthHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FamilyHealthHistories.
     */
    data: FamilyHealthHistoryCreateManyInput | FamilyHealthHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FamilyHealthHistory update
   */
  export type FamilyHealthHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FamilyHealthHistory.
     */
    data: XOR<FamilyHealthHistoryUpdateInput, FamilyHealthHistoryUncheckedUpdateInput>
    /**
     * Choose, which FamilyHealthHistory to update.
     */
    where: FamilyHealthHistoryWhereUniqueInput
  }

  /**
   * FamilyHealthHistory updateMany
   */
  export type FamilyHealthHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FamilyHealthHistories.
     */
    data: XOR<FamilyHealthHistoryUpdateManyMutationInput, FamilyHealthHistoryUncheckedUpdateManyInput>
    /**
     * Filter which FamilyHealthHistories to update
     */
    where?: FamilyHealthHistoryWhereInput
    /**
     * Limit how many FamilyHealthHistories to update.
     */
    limit?: number
  }

  /**
   * FamilyHealthHistory upsert
   */
  export type FamilyHealthHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FamilyHealthHistory to update in case it exists.
     */
    where: FamilyHealthHistoryWhereUniqueInput
    /**
     * In case the FamilyHealthHistory found by the `where` argument doesn't exist, create a new FamilyHealthHistory with this data.
     */
    create: XOR<FamilyHealthHistoryCreateInput, FamilyHealthHistoryUncheckedCreateInput>
    /**
     * In case the FamilyHealthHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamilyHealthHistoryUpdateInput, FamilyHealthHistoryUncheckedUpdateInput>
  }

  /**
   * FamilyHealthHistory delete
   */
  export type FamilyHealthHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
    /**
     * Filter which FamilyHealthHistory to delete.
     */
    where: FamilyHealthHistoryWhereUniqueInput
  }

  /**
   * FamilyHealthHistory deleteMany
   */
  export type FamilyHealthHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FamilyHealthHistories to delete
     */
    where?: FamilyHealthHistoryWhereInput
    /**
     * Limit how many FamilyHealthHistories to delete.
     */
    limit?: number
  }

  /**
   * FamilyHealthHistory without action
   */
  export type FamilyHealthHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FamilyHealthHistory
     */
    select?: FamilyHealthHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the FamilyHealthHistory
     */
    omit?: FamilyHealthHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamilyHealthHistoryInclude<ExtArgs> | null
  }


  /**
   * Model MaternalHealth
   */

  export type AggregateMaternalHealth = {
    _count: MaternalHealthCountAggregateOutputType | null
    _avg: MaternalHealthAvgAggregateOutputType | null
    _sum: MaternalHealthSumAggregateOutputType | null
    _min: MaternalHealthMinAggregateOutputType | null
    _max: MaternalHealthMaxAggregateOutputType | null
  }

  export type MaternalHealthAvgAggregateOutputType = {
    mothersAge: number | null
    numberOfChildren: number | null
    menarcheAge: number | null
  }

  export type MaternalHealthSumAggregateOutputType = {
    mothersAge: number | null
    numberOfChildren: number | null
    menarcheAge: number | null
  }

  export type MaternalHealthMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    mothersName: string | null
    mothersAge: number | null
    mothersBirthday: Date | null
    mothersMaidenName: string | null
    mothersReligion: string | null
    mothersEducation: string | null
    mothersOccupation: string | null
    numberOfChildren: number | null
    gravidaPara: string | null
    menarcheAge: number | null
    lastMenstrualPeriod: Date | null
    expectedDeliveryDate: Date | null
    tetanusToxoidStatus: string | null
    createdAt: Date | null
  }

  export type MaternalHealthMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    mothersName: string | null
    mothersAge: number | null
    mothersBirthday: Date | null
    mothersMaidenName: string | null
    mothersReligion: string | null
    mothersEducation: string | null
    mothersOccupation: string | null
    numberOfChildren: number | null
    gravidaPara: string | null
    menarcheAge: number | null
    lastMenstrualPeriod: Date | null
    expectedDeliveryDate: Date | null
    tetanusToxoidStatus: string | null
    createdAt: Date | null
  }

  export type MaternalHealthCountAggregateOutputType = {
    id: number
    userProfileId: number
    mothersName: number
    mothersAge: number
    mothersBirthday: number
    mothersMaidenName: number
    mothersReligion: number
    mothersEducation: number
    mothersOccupation: number
    numberOfChildren: number
    gravidaPara: number
    menarcheAge: number
    lastMenstrualPeriod: number
    expectedDeliveryDate: number
    tetanusToxoidStatus: number
    createdAt: number
    _all: number
  }


  export type MaternalHealthAvgAggregateInputType = {
    mothersAge?: true
    numberOfChildren?: true
    menarcheAge?: true
  }

  export type MaternalHealthSumAggregateInputType = {
    mothersAge?: true
    numberOfChildren?: true
    menarcheAge?: true
  }

  export type MaternalHealthMinAggregateInputType = {
    id?: true
    userProfileId?: true
    mothersName?: true
    mothersAge?: true
    mothersBirthday?: true
    mothersMaidenName?: true
    mothersReligion?: true
    mothersEducation?: true
    mothersOccupation?: true
    numberOfChildren?: true
    gravidaPara?: true
    menarcheAge?: true
    lastMenstrualPeriod?: true
    expectedDeliveryDate?: true
    tetanusToxoidStatus?: true
    createdAt?: true
  }

  export type MaternalHealthMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    mothersName?: true
    mothersAge?: true
    mothersBirthday?: true
    mothersMaidenName?: true
    mothersReligion?: true
    mothersEducation?: true
    mothersOccupation?: true
    numberOfChildren?: true
    gravidaPara?: true
    menarcheAge?: true
    lastMenstrualPeriod?: true
    expectedDeliveryDate?: true
    tetanusToxoidStatus?: true
    createdAt?: true
  }

  export type MaternalHealthCountAggregateInputType = {
    id?: true
    userProfileId?: true
    mothersName?: true
    mothersAge?: true
    mothersBirthday?: true
    mothersMaidenName?: true
    mothersReligion?: true
    mothersEducation?: true
    mothersOccupation?: true
    numberOfChildren?: true
    gravidaPara?: true
    menarcheAge?: true
    lastMenstrualPeriod?: true
    expectedDeliveryDate?: true
    tetanusToxoidStatus?: true
    createdAt?: true
    _all?: true
  }

  export type MaternalHealthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaternalHealth to aggregate.
     */
    where?: MaternalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaternalHealths to fetch.
     */
    orderBy?: MaternalHealthOrderByWithRelationInput | MaternalHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaternalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaternalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaternalHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaternalHealths
    **/
    _count?: true | MaternalHealthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaternalHealthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaternalHealthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaternalHealthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaternalHealthMaxAggregateInputType
  }

  export type GetMaternalHealthAggregateType<T extends MaternalHealthAggregateArgs> = {
        [P in keyof T & keyof AggregateMaternalHealth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaternalHealth[P]>
      : GetScalarType<T[P], AggregateMaternalHealth[P]>
  }




  export type MaternalHealthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaternalHealthWhereInput
    orderBy?: MaternalHealthOrderByWithAggregationInput | MaternalHealthOrderByWithAggregationInput[]
    by: MaternalHealthScalarFieldEnum[] | MaternalHealthScalarFieldEnum
    having?: MaternalHealthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaternalHealthCountAggregateInputType | true
    _avg?: MaternalHealthAvgAggregateInputType
    _sum?: MaternalHealthSumAggregateInputType
    _min?: MaternalHealthMinAggregateInputType
    _max?: MaternalHealthMaxAggregateInputType
  }

  export type MaternalHealthGroupByOutputType = {
    id: string
    userProfileId: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date
    mothersMaidenName: string
    mothersReligion: string | null
    mothersEducation: string | null
    mothersOccupation: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date
    expectedDeliveryDate: Date
    tetanusToxoidStatus: string | null
    createdAt: Date
    _count: MaternalHealthCountAggregateOutputType | null
    _avg: MaternalHealthAvgAggregateOutputType | null
    _sum: MaternalHealthSumAggregateOutputType | null
    _min: MaternalHealthMinAggregateOutputType | null
    _max: MaternalHealthMaxAggregateOutputType | null
  }

  type GetMaternalHealthGroupByPayload<T extends MaternalHealthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaternalHealthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaternalHealthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaternalHealthGroupByOutputType[P]>
            : GetScalarType<T[P], MaternalHealthGroupByOutputType[P]>
        }
      >
    >


  export type MaternalHealthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    mothersName?: boolean
    mothersAge?: boolean
    mothersBirthday?: boolean
    mothersMaidenName?: boolean
    mothersReligion?: boolean
    mothersEducation?: boolean
    mothersOccupation?: boolean
    numberOfChildren?: boolean
    gravidaPara?: boolean
    menarcheAge?: boolean
    lastMenstrualPeriod?: boolean
    expectedDeliveryDate?: boolean
    tetanusToxoidStatus?: boolean
    createdAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    prenatalVisits?: boolean | MaternalHealth$prenatalVisitsArgs<ExtArgs>
    birthInformation?: boolean | MaternalHealth$birthInformationArgs<ExtArgs>
    _count?: boolean | MaternalHealthCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maternalHealth"]>



  export type MaternalHealthSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    mothersName?: boolean
    mothersAge?: boolean
    mothersBirthday?: boolean
    mothersMaidenName?: boolean
    mothersReligion?: boolean
    mothersEducation?: boolean
    mothersOccupation?: boolean
    numberOfChildren?: boolean
    gravidaPara?: boolean
    menarcheAge?: boolean
    lastMenstrualPeriod?: boolean
    expectedDeliveryDate?: boolean
    tetanusToxoidStatus?: boolean
    createdAt?: boolean
  }

  export type MaternalHealthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "mothersName" | "mothersAge" | "mothersBirthday" | "mothersMaidenName" | "mothersReligion" | "mothersEducation" | "mothersOccupation" | "numberOfChildren" | "gravidaPara" | "menarcheAge" | "lastMenstrualPeriod" | "expectedDeliveryDate" | "tetanusToxoidStatus" | "createdAt", ExtArgs["result"]["maternalHealth"]>
  export type MaternalHealthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    prenatalVisits?: boolean | MaternalHealth$prenatalVisitsArgs<ExtArgs>
    birthInformation?: boolean | MaternalHealth$birthInformationArgs<ExtArgs>
    _count?: boolean | MaternalHealthCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MaternalHealthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaternalHealth"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
      prenatalVisits: Prisma.$PrenatalVisitPayload<ExtArgs>[]
      birthInformation: Prisma.$BirthInformationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      mothersName: string
      mothersAge: number
      mothersBirthday: Date
      mothersMaidenName: string
      mothersReligion: string | null
      mothersEducation: string | null
      mothersOccupation: string | null
      numberOfChildren: number
      gravidaPara: string
      menarcheAge: number
      lastMenstrualPeriod: Date
      expectedDeliveryDate: Date
      tetanusToxoidStatus: string | null
      createdAt: Date
    }, ExtArgs["result"]["maternalHealth"]>
    composites: {}
  }

  type MaternalHealthGetPayload<S extends boolean | null | undefined | MaternalHealthDefaultArgs> = $Result.GetResult<Prisma.$MaternalHealthPayload, S>

  type MaternalHealthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaternalHealthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaternalHealthCountAggregateInputType | true
    }

  export interface MaternalHealthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaternalHealth'], meta: { name: 'MaternalHealth' } }
    /**
     * Find zero or one MaternalHealth that matches the filter.
     * @param {MaternalHealthFindUniqueArgs} args - Arguments to find a MaternalHealth
     * @example
     * // Get one MaternalHealth
     * const maternalHealth = await prisma.maternalHealth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaternalHealthFindUniqueArgs>(args: SelectSubset<T, MaternalHealthFindUniqueArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaternalHealth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaternalHealthFindUniqueOrThrowArgs} args - Arguments to find a MaternalHealth
     * @example
     * // Get one MaternalHealth
     * const maternalHealth = await prisma.maternalHealth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaternalHealthFindUniqueOrThrowArgs>(args: SelectSubset<T, MaternalHealthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaternalHealth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaternalHealthFindFirstArgs} args - Arguments to find a MaternalHealth
     * @example
     * // Get one MaternalHealth
     * const maternalHealth = await prisma.maternalHealth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaternalHealthFindFirstArgs>(args?: SelectSubset<T, MaternalHealthFindFirstArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaternalHealth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaternalHealthFindFirstOrThrowArgs} args - Arguments to find a MaternalHealth
     * @example
     * // Get one MaternalHealth
     * const maternalHealth = await prisma.maternalHealth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaternalHealthFindFirstOrThrowArgs>(args?: SelectSubset<T, MaternalHealthFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaternalHealths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaternalHealthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaternalHealths
     * const maternalHealths = await prisma.maternalHealth.findMany()
     * 
     * // Get first 10 MaternalHealths
     * const maternalHealths = await prisma.maternalHealth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maternalHealthWithIdOnly = await prisma.maternalHealth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaternalHealthFindManyArgs>(args?: SelectSubset<T, MaternalHealthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaternalHealth.
     * @param {MaternalHealthCreateArgs} args - Arguments to create a MaternalHealth.
     * @example
     * // Create one MaternalHealth
     * const MaternalHealth = await prisma.maternalHealth.create({
     *   data: {
     *     // ... data to create a MaternalHealth
     *   }
     * })
     * 
     */
    create<T extends MaternalHealthCreateArgs>(args: SelectSubset<T, MaternalHealthCreateArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaternalHealths.
     * @param {MaternalHealthCreateManyArgs} args - Arguments to create many MaternalHealths.
     * @example
     * // Create many MaternalHealths
     * const maternalHealth = await prisma.maternalHealth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaternalHealthCreateManyArgs>(args?: SelectSubset<T, MaternalHealthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MaternalHealth.
     * @param {MaternalHealthDeleteArgs} args - Arguments to delete one MaternalHealth.
     * @example
     * // Delete one MaternalHealth
     * const MaternalHealth = await prisma.maternalHealth.delete({
     *   where: {
     *     // ... filter to delete one MaternalHealth
     *   }
     * })
     * 
     */
    delete<T extends MaternalHealthDeleteArgs>(args: SelectSubset<T, MaternalHealthDeleteArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaternalHealth.
     * @param {MaternalHealthUpdateArgs} args - Arguments to update one MaternalHealth.
     * @example
     * // Update one MaternalHealth
     * const maternalHealth = await prisma.maternalHealth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaternalHealthUpdateArgs>(args: SelectSubset<T, MaternalHealthUpdateArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaternalHealths.
     * @param {MaternalHealthDeleteManyArgs} args - Arguments to filter MaternalHealths to delete.
     * @example
     * // Delete a few MaternalHealths
     * const { count } = await prisma.maternalHealth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaternalHealthDeleteManyArgs>(args?: SelectSubset<T, MaternalHealthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaternalHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaternalHealthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaternalHealths
     * const maternalHealth = await prisma.maternalHealth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaternalHealthUpdateManyArgs>(args: SelectSubset<T, MaternalHealthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaternalHealth.
     * @param {MaternalHealthUpsertArgs} args - Arguments to update or create a MaternalHealth.
     * @example
     * // Update or create a MaternalHealth
     * const maternalHealth = await prisma.maternalHealth.upsert({
     *   create: {
     *     // ... data to create a MaternalHealth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaternalHealth we want to update
     *   }
     * })
     */
    upsert<T extends MaternalHealthUpsertArgs>(args: SelectSubset<T, MaternalHealthUpsertArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaternalHealths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaternalHealthCountArgs} args - Arguments to filter MaternalHealths to count.
     * @example
     * // Count the number of MaternalHealths
     * const count = await prisma.maternalHealth.count({
     *   where: {
     *     // ... the filter for the MaternalHealths we want to count
     *   }
     * })
    **/
    count<T extends MaternalHealthCountArgs>(
      args?: Subset<T, MaternalHealthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaternalHealthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaternalHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaternalHealthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaternalHealthAggregateArgs>(args: Subset<T, MaternalHealthAggregateArgs>): Prisma.PrismaPromise<GetMaternalHealthAggregateType<T>>

    /**
     * Group by MaternalHealth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaternalHealthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaternalHealthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaternalHealthGroupByArgs['orderBy'] }
        : { orderBy?: MaternalHealthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaternalHealthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaternalHealthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaternalHealth model
   */
  readonly fields: MaternalHealthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaternalHealth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaternalHealthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prenatalVisits<T extends MaternalHealth$prenatalVisitsArgs<ExtArgs> = {}>(args?: Subset<T, MaternalHealth$prenatalVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    birthInformation<T extends MaternalHealth$birthInformationArgs<ExtArgs> = {}>(args?: Subset<T, MaternalHealth$birthInformationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaternalHealth model
   */
  interface MaternalHealthFieldRefs {
    readonly id: FieldRef<"MaternalHealth", 'String'>
    readonly userProfileId: FieldRef<"MaternalHealth", 'String'>
    readonly mothersName: FieldRef<"MaternalHealth", 'String'>
    readonly mothersAge: FieldRef<"MaternalHealth", 'Int'>
    readonly mothersBirthday: FieldRef<"MaternalHealth", 'DateTime'>
    readonly mothersMaidenName: FieldRef<"MaternalHealth", 'String'>
    readonly mothersReligion: FieldRef<"MaternalHealth", 'String'>
    readonly mothersEducation: FieldRef<"MaternalHealth", 'String'>
    readonly mothersOccupation: FieldRef<"MaternalHealth", 'String'>
    readonly numberOfChildren: FieldRef<"MaternalHealth", 'Int'>
    readonly gravidaPara: FieldRef<"MaternalHealth", 'String'>
    readonly menarcheAge: FieldRef<"MaternalHealth", 'Int'>
    readonly lastMenstrualPeriod: FieldRef<"MaternalHealth", 'DateTime'>
    readonly expectedDeliveryDate: FieldRef<"MaternalHealth", 'DateTime'>
    readonly tetanusToxoidStatus: FieldRef<"MaternalHealth", 'String'>
    readonly createdAt: FieldRef<"MaternalHealth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaternalHealth findUnique
   */
  export type MaternalHealthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MaternalHealth to fetch.
     */
    where: MaternalHealthWhereUniqueInput
  }

  /**
   * MaternalHealth findUniqueOrThrow
   */
  export type MaternalHealthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MaternalHealth to fetch.
     */
    where: MaternalHealthWhereUniqueInput
  }

  /**
   * MaternalHealth findFirst
   */
  export type MaternalHealthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MaternalHealth to fetch.
     */
    where?: MaternalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaternalHealths to fetch.
     */
    orderBy?: MaternalHealthOrderByWithRelationInput | MaternalHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaternalHealths.
     */
    cursor?: MaternalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaternalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaternalHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaternalHealths.
     */
    distinct?: MaternalHealthScalarFieldEnum | MaternalHealthScalarFieldEnum[]
  }

  /**
   * MaternalHealth findFirstOrThrow
   */
  export type MaternalHealthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MaternalHealth to fetch.
     */
    where?: MaternalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaternalHealths to fetch.
     */
    orderBy?: MaternalHealthOrderByWithRelationInput | MaternalHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaternalHealths.
     */
    cursor?: MaternalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaternalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaternalHealths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaternalHealths.
     */
    distinct?: MaternalHealthScalarFieldEnum | MaternalHealthScalarFieldEnum[]
  }

  /**
   * MaternalHealth findMany
   */
  export type MaternalHealthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * Filter, which MaternalHealths to fetch.
     */
    where?: MaternalHealthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaternalHealths to fetch.
     */
    orderBy?: MaternalHealthOrderByWithRelationInput | MaternalHealthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaternalHealths.
     */
    cursor?: MaternalHealthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaternalHealths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaternalHealths.
     */
    skip?: number
    distinct?: MaternalHealthScalarFieldEnum | MaternalHealthScalarFieldEnum[]
  }

  /**
   * MaternalHealth create
   */
  export type MaternalHealthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * The data needed to create a MaternalHealth.
     */
    data: XOR<MaternalHealthCreateInput, MaternalHealthUncheckedCreateInput>
  }

  /**
   * MaternalHealth createMany
   */
  export type MaternalHealthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaternalHealths.
     */
    data: MaternalHealthCreateManyInput | MaternalHealthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaternalHealth update
   */
  export type MaternalHealthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * The data needed to update a MaternalHealth.
     */
    data: XOR<MaternalHealthUpdateInput, MaternalHealthUncheckedUpdateInput>
    /**
     * Choose, which MaternalHealth to update.
     */
    where: MaternalHealthWhereUniqueInput
  }

  /**
   * MaternalHealth updateMany
   */
  export type MaternalHealthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaternalHealths.
     */
    data: XOR<MaternalHealthUpdateManyMutationInput, MaternalHealthUncheckedUpdateManyInput>
    /**
     * Filter which MaternalHealths to update
     */
    where?: MaternalHealthWhereInput
    /**
     * Limit how many MaternalHealths to update.
     */
    limit?: number
  }

  /**
   * MaternalHealth upsert
   */
  export type MaternalHealthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * The filter to search for the MaternalHealth to update in case it exists.
     */
    where: MaternalHealthWhereUniqueInput
    /**
     * In case the MaternalHealth found by the `where` argument doesn't exist, create a new MaternalHealth with this data.
     */
    create: XOR<MaternalHealthCreateInput, MaternalHealthUncheckedCreateInput>
    /**
     * In case the MaternalHealth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaternalHealthUpdateInput, MaternalHealthUncheckedUpdateInput>
  }

  /**
   * MaternalHealth delete
   */
  export type MaternalHealthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
    /**
     * Filter which MaternalHealth to delete.
     */
    where: MaternalHealthWhereUniqueInput
  }

  /**
   * MaternalHealth deleteMany
   */
  export type MaternalHealthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaternalHealths to delete
     */
    where?: MaternalHealthWhereInput
    /**
     * Limit how many MaternalHealths to delete.
     */
    limit?: number
  }

  /**
   * MaternalHealth.prenatalVisits
   */
  export type MaternalHealth$prenatalVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    where?: PrenatalVisitWhereInput
    orderBy?: PrenatalVisitOrderByWithRelationInput | PrenatalVisitOrderByWithRelationInput[]
    cursor?: PrenatalVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrenatalVisitScalarFieldEnum | PrenatalVisitScalarFieldEnum[]
  }

  /**
   * MaternalHealth.birthInformation
   */
  export type MaternalHealth$birthInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    where?: BirthInformationWhereInput
    orderBy?: BirthInformationOrderByWithRelationInput | BirthInformationOrderByWithRelationInput[]
    cursor?: BirthInformationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BirthInformationScalarFieldEnum | BirthInformationScalarFieldEnum[]
  }

  /**
   * MaternalHealth without action
   */
  export type MaternalHealthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaternalHealth
     */
    select?: MaternalHealthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaternalHealth
     */
    omit?: MaternalHealthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaternalHealthInclude<ExtArgs> | null
  }


  /**
   * Model PrenatalVisit
   */

  export type AggregatePrenatalVisit = {
    _count: PrenatalVisitCountAggregateOutputType | null
    _avg: PrenatalVisitAvgAggregateOutputType | null
    _sum: PrenatalVisitSumAggregateOutputType | null
    _min: PrenatalVisitMinAggregateOutputType | null
    _max: PrenatalVisitMaxAggregateOutputType | null
  }

  export type PrenatalVisitAvgAggregateOutputType = {
    gestationalAgeWeeks: number | null
    weightKg: number | null
    heightCm: number | null
    fundalHeightCm: number | null
  }

  export type PrenatalVisitSumAggregateOutputType = {
    gestationalAgeWeeks: number | null
    weightKg: number | null
    heightCm: number | null
    fundalHeightCm: number | null
  }

  export type PrenatalVisitMinAggregateOutputType = {
    id: string | null
    maternalHealthId: string | null
    visitDate: Date | null
    gestationalAgeWeeks: number | null
    weightKg: number | null
    heightCm: number | null
    bloodPressure: string | null
    fundalHeightCm: number | null
    fetalHeartTone: string | null
    nextVisitDate: Date | null
    recordedBy: string | null
  }

  export type PrenatalVisitMaxAggregateOutputType = {
    id: string | null
    maternalHealthId: string | null
    visitDate: Date | null
    gestationalAgeWeeks: number | null
    weightKg: number | null
    heightCm: number | null
    bloodPressure: string | null
    fundalHeightCm: number | null
    fetalHeartTone: string | null
    nextVisitDate: Date | null
    recordedBy: string | null
  }

  export type PrenatalVisitCountAggregateOutputType = {
    id: number
    maternalHealthId: number
    visitDate: number
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: number
    fundalHeightCm: number
    fetalHeartTone: number
    nextVisitDate: number
    recordedBy: number
    _all: number
  }


  export type PrenatalVisitAvgAggregateInputType = {
    gestationalAgeWeeks?: true
    weightKg?: true
    heightCm?: true
    fundalHeightCm?: true
  }

  export type PrenatalVisitSumAggregateInputType = {
    gestationalAgeWeeks?: true
    weightKg?: true
    heightCm?: true
    fundalHeightCm?: true
  }

  export type PrenatalVisitMinAggregateInputType = {
    id?: true
    maternalHealthId?: true
    visitDate?: true
    gestationalAgeWeeks?: true
    weightKg?: true
    heightCm?: true
    bloodPressure?: true
    fundalHeightCm?: true
    fetalHeartTone?: true
    nextVisitDate?: true
    recordedBy?: true
  }

  export type PrenatalVisitMaxAggregateInputType = {
    id?: true
    maternalHealthId?: true
    visitDate?: true
    gestationalAgeWeeks?: true
    weightKg?: true
    heightCm?: true
    bloodPressure?: true
    fundalHeightCm?: true
    fetalHeartTone?: true
    nextVisitDate?: true
    recordedBy?: true
  }

  export type PrenatalVisitCountAggregateInputType = {
    id?: true
    maternalHealthId?: true
    visitDate?: true
    gestationalAgeWeeks?: true
    weightKg?: true
    heightCm?: true
    bloodPressure?: true
    fundalHeightCm?: true
    fetalHeartTone?: true
    nextVisitDate?: true
    recordedBy?: true
    _all?: true
  }

  export type PrenatalVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrenatalVisit to aggregate.
     */
    where?: PrenatalVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrenatalVisits to fetch.
     */
    orderBy?: PrenatalVisitOrderByWithRelationInput | PrenatalVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrenatalVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrenatalVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrenatalVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrenatalVisits
    **/
    _count?: true | PrenatalVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrenatalVisitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrenatalVisitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrenatalVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrenatalVisitMaxAggregateInputType
  }

  export type GetPrenatalVisitAggregateType<T extends PrenatalVisitAggregateArgs> = {
        [P in keyof T & keyof AggregatePrenatalVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrenatalVisit[P]>
      : GetScalarType<T[P], AggregatePrenatalVisit[P]>
  }




  export type PrenatalVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrenatalVisitWhereInput
    orderBy?: PrenatalVisitOrderByWithAggregationInput | PrenatalVisitOrderByWithAggregationInput[]
    by: PrenatalVisitScalarFieldEnum[] | PrenatalVisitScalarFieldEnum
    having?: PrenatalVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrenatalVisitCountAggregateInputType | true
    _avg?: PrenatalVisitAvgAggregateInputType
    _sum?: PrenatalVisitSumAggregateInputType
    _min?: PrenatalVisitMinAggregateInputType
    _max?: PrenatalVisitMaxAggregateInputType
  }

  export type PrenatalVisitGroupByOutputType = {
    id: string
    maternalHealthId: string
    visitDate: Date
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate: Date | null
    recordedBy: string
    _count: PrenatalVisitCountAggregateOutputType | null
    _avg: PrenatalVisitAvgAggregateOutputType | null
    _sum: PrenatalVisitSumAggregateOutputType | null
    _min: PrenatalVisitMinAggregateOutputType | null
    _max: PrenatalVisitMaxAggregateOutputType | null
  }

  type GetPrenatalVisitGroupByPayload<T extends PrenatalVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrenatalVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrenatalVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrenatalVisitGroupByOutputType[P]>
            : GetScalarType<T[P], PrenatalVisitGroupByOutputType[P]>
        }
      >
    >


  export type PrenatalVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    maternalHealthId?: boolean
    visitDate?: boolean
    gestationalAgeWeeks?: boolean
    weightKg?: boolean
    heightCm?: boolean
    bloodPressure?: boolean
    fundalHeightCm?: boolean
    fetalHeartTone?: boolean
    nextVisitDate?: boolean
    recordedBy?: boolean
    maternalHealth?: boolean | MaternalHealthDefaultArgs<ExtArgs>
    laboratoryTests?: boolean | PrenatalVisit$laboratoryTestsArgs<ExtArgs>
    interventions?: boolean | PrenatalVisit$interventionsArgs<ExtArgs>
    _count?: boolean | PrenatalVisitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prenatalVisit"]>



  export type PrenatalVisitSelectScalar = {
    id?: boolean
    maternalHealthId?: boolean
    visitDate?: boolean
    gestationalAgeWeeks?: boolean
    weightKg?: boolean
    heightCm?: boolean
    bloodPressure?: boolean
    fundalHeightCm?: boolean
    fetalHeartTone?: boolean
    nextVisitDate?: boolean
    recordedBy?: boolean
  }

  export type PrenatalVisitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "maternalHealthId" | "visitDate" | "gestationalAgeWeeks" | "weightKg" | "heightCm" | "bloodPressure" | "fundalHeightCm" | "fetalHeartTone" | "nextVisitDate" | "recordedBy", ExtArgs["result"]["prenatalVisit"]>
  export type PrenatalVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maternalHealth?: boolean | MaternalHealthDefaultArgs<ExtArgs>
    laboratoryTests?: boolean | PrenatalVisit$laboratoryTestsArgs<ExtArgs>
    interventions?: boolean | PrenatalVisit$interventionsArgs<ExtArgs>
    _count?: boolean | PrenatalVisitCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PrenatalVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrenatalVisit"
    objects: {
      maternalHealth: Prisma.$MaternalHealthPayload<ExtArgs>
      laboratoryTests: Prisma.$LaboratoryTestPayload<ExtArgs>[]
      interventions: Prisma.$InterventionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      maternalHealthId: string
      visitDate: Date
      gestationalAgeWeeks: number
      weightKg: number
      heightCm: number
      bloodPressure: string
      fundalHeightCm: number
      fetalHeartTone: string
      nextVisitDate: Date | null
      recordedBy: string
    }, ExtArgs["result"]["prenatalVisit"]>
    composites: {}
  }

  type PrenatalVisitGetPayload<S extends boolean | null | undefined | PrenatalVisitDefaultArgs> = $Result.GetResult<Prisma.$PrenatalVisitPayload, S>

  type PrenatalVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrenatalVisitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrenatalVisitCountAggregateInputType | true
    }

  export interface PrenatalVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrenatalVisit'], meta: { name: 'PrenatalVisit' } }
    /**
     * Find zero or one PrenatalVisit that matches the filter.
     * @param {PrenatalVisitFindUniqueArgs} args - Arguments to find a PrenatalVisit
     * @example
     * // Get one PrenatalVisit
     * const prenatalVisit = await prisma.prenatalVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrenatalVisitFindUniqueArgs>(args: SelectSubset<T, PrenatalVisitFindUniqueArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrenatalVisit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrenatalVisitFindUniqueOrThrowArgs} args - Arguments to find a PrenatalVisit
     * @example
     * // Get one PrenatalVisit
     * const prenatalVisit = await prisma.prenatalVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrenatalVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, PrenatalVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrenatalVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrenatalVisitFindFirstArgs} args - Arguments to find a PrenatalVisit
     * @example
     * // Get one PrenatalVisit
     * const prenatalVisit = await prisma.prenatalVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrenatalVisitFindFirstArgs>(args?: SelectSubset<T, PrenatalVisitFindFirstArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrenatalVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrenatalVisitFindFirstOrThrowArgs} args - Arguments to find a PrenatalVisit
     * @example
     * // Get one PrenatalVisit
     * const prenatalVisit = await prisma.prenatalVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrenatalVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, PrenatalVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrenatalVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrenatalVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrenatalVisits
     * const prenatalVisits = await prisma.prenatalVisit.findMany()
     * 
     * // Get first 10 PrenatalVisits
     * const prenatalVisits = await prisma.prenatalVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prenatalVisitWithIdOnly = await prisma.prenatalVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrenatalVisitFindManyArgs>(args?: SelectSubset<T, PrenatalVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrenatalVisit.
     * @param {PrenatalVisitCreateArgs} args - Arguments to create a PrenatalVisit.
     * @example
     * // Create one PrenatalVisit
     * const PrenatalVisit = await prisma.prenatalVisit.create({
     *   data: {
     *     // ... data to create a PrenatalVisit
     *   }
     * })
     * 
     */
    create<T extends PrenatalVisitCreateArgs>(args: SelectSubset<T, PrenatalVisitCreateArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrenatalVisits.
     * @param {PrenatalVisitCreateManyArgs} args - Arguments to create many PrenatalVisits.
     * @example
     * // Create many PrenatalVisits
     * const prenatalVisit = await prisma.prenatalVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrenatalVisitCreateManyArgs>(args?: SelectSubset<T, PrenatalVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PrenatalVisit.
     * @param {PrenatalVisitDeleteArgs} args - Arguments to delete one PrenatalVisit.
     * @example
     * // Delete one PrenatalVisit
     * const PrenatalVisit = await prisma.prenatalVisit.delete({
     *   where: {
     *     // ... filter to delete one PrenatalVisit
     *   }
     * })
     * 
     */
    delete<T extends PrenatalVisitDeleteArgs>(args: SelectSubset<T, PrenatalVisitDeleteArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrenatalVisit.
     * @param {PrenatalVisitUpdateArgs} args - Arguments to update one PrenatalVisit.
     * @example
     * // Update one PrenatalVisit
     * const prenatalVisit = await prisma.prenatalVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrenatalVisitUpdateArgs>(args: SelectSubset<T, PrenatalVisitUpdateArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrenatalVisits.
     * @param {PrenatalVisitDeleteManyArgs} args - Arguments to filter PrenatalVisits to delete.
     * @example
     * // Delete a few PrenatalVisits
     * const { count } = await prisma.prenatalVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrenatalVisitDeleteManyArgs>(args?: SelectSubset<T, PrenatalVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrenatalVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrenatalVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrenatalVisits
     * const prenatalVisit = await prisma.prenatalVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrenatalVisitUpdateManyArgs>(args: SelectSubset<T, PrenatalVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PrenatalVisit.
     * @param {PrenatalVisitUpsertArgs} args - Arguments to update or create a PrenatalVisit.
     * @example
     * // Update or create a PrenatalVisit
     * const prenatalVisit = await prisma.prenatalVisit.upsert({
     *   create: {
     *     // ... data to create a PrenatalVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrenatalVisit we want to update
     *   }
     * })
     */
    upsert<T extends PrenatalVisitUpsertArgs>(args: SelectSubset<T, PrenatalVisitUpsertArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrenatalVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrenatalVisitCountArgs} args - Arguments to filter PrenatalVisits to count.
     * @example
     * // Count the number of PrenatalVisits
     * const count = await prisma.prenatalVisit.count({
     *   where: {
     *     // ... the filter for the PrenatalVisits we want to count
     *   }
     * })
    **/
    count<T extends PrenatalVisitCountArgs>(
      args?: Subset<T, PrenatalVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrenatalVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrenatalVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrenatalVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrenatalVisitAggregateArgs>(args: Subset<T, PrenatalVisitAggregateArgs>): Prisma.PrismaPromise<GetPrenatalVisitAggregateType<T>>

    /**
     * Group by PrenatalVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrenatalVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrenatalVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrenatalVisitGroupByArgs['orderBy'] }
        : { orderBy?: PrenatalVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrenatalVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrenatalVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrenatalVisit model
   */
  readonly fields: PrenatalVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrenatalVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrenatalVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    maternalHealth<T extends MaternalHealthDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaternalHealthDefaultArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    laboratoryTests<T extends PrenatalVisit$laboratoryTestsArgs<ExtArgs> = {}>(args?: Subset<T, PrenatalVisit$laboratoryTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interventions<T extends PrenatalVisit$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, PrenatalVisit$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrenatalVisit model
   */
  interface PrenatalVisitFieldRefs {
    readonly id: FieldRef<"PrenatalVisit", 'String'>
    readonly maternalHealthId: FieldRef<"PrenatalVisit", 'String'>
    readonly visitDate: FieldRef<"PrenatalVisit", 'DateTime'>
    readonly gestationalAgeWeeks: FieldRef<"PrenatalVisit", 'Int'>
    readonly weightKg: FieldRef<"PrenatalVisit", 'Float'>
    readonly heightCm: FieldRef<"PrenatalVisit", 'Float'>
    readonly bloodPressure: FieldRef<"PrenatalVisit", 'String'>
    readonly fundalHeightCm: FieldRef<"PrenatalVisit", 'Float'>
    readonly fetalHeartTone: FieldRef<"PrenatalVisit", 'String'>
    readonly nextVisitDate: FieldRef<"PrenatalVisit", 'DateTime'>
    readonly recordedBy: FieldRef<"PrenatalVisit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrenatalVisit findUnique
   */
  export type PrenatalVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * Filter, which PrenatalVisit to fetch.
     */
    where: PrenatalVisitWhereUniqueInput
  }

  /**
   * PrenatalVisit findUniqueOrThrow
   */
  export type PrenatalVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * Filter, which PrenatalVisit to fetch.
     */
    where: PrenatalVisitWhereUniqueInput
  }

  /**
   * PrenatalVisit findFirst
   */
  export type PrenatalVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * Filter, which PrenatalVisit to fetch.
     */
    where?: PrenatalVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrenatalVisits to fetch.
     */
    orderBy?: PrenatalVisitOrderByWithRelationInput | PrenatalVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrenatalVisits.
     */
    cursor?: PrenatalVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrenatalVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrenatalVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrenatalVisits.
     */
    distinct?: PrenatalVisitScalarFieldEnum | PrenatalVisitScalarFieldEnum[]
  }

  /**
   * PrenatalVisit findFirstOrThrow
   */
  export type PrenatalVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * Filter, which PrenatalVisit to fetch.
     */
    where?: PrenatalVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrenatalVisits to fetch.
     */
    orderBy?: PrenatalVisitOrderByWithRelationInput | PrenatalVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrenatalVisits.
     */
    cursor?: PrenatalVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrenatalVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrenatalVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrenatalVisits.
     */
    distinct?: PrenatalVisitScalarFieldEnum | PrenatalVisitScalarFieldEnum[]
  }

  /**
   * PrenatalVisit findMany
   */
  export type PrenatalVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * Filter, which PrenatalVisits to fetch.
     */
    where?: PrenatalVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrenatalVisits to fetch.
     */
    orderBy?: PrenatalVisitOrderByWithRelationInput | PrenatalVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrenatalVisits.
     */
    cursor?: PrenatalVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrenatalVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrenatalVisits.
     */
    skip?: number
    distinct?: PrenatalVisitScalarFieldEnum | PrenatalVisitScalarFieldEnum[]
  }

  /**
   * PrenatalVisit create
   */
  export type PrenatalVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a PrenatalVisit.
     */
    data: XOR<PrenatalVisitCreateInput, PrenatalVisitUncheckedCreateInput>
  }

  /**
   * PrenatalVisit createMany
   */
  export type PrenatalVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrenatalVisits.
     */
    data: PrenatalVisitCreateManyInput | PrenatalVisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrenatalVisit update
   */
  export type PrenatalVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a PrenatalVisit.
     */
    data: XOR<PrenatalVisitUpdateInput, PrenatalVisitUncheckedUpdateInput>
    /**
     * Choose, which PrenatalVisit to update.
     */
    where: PrenatalVisitWhereUniqueInput
  }

  /**
   * PrenatalVisit updateMany
   */
  export type PrenatalVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrenatalVisits.
     */
    data: XOR<PrenatalVisitUpdateManyMutationInput, PrenatalVisitUncheckedUpdateManyInput>
    /**
     * Filter which PrenatalVisits to update
     */
    where?: PrenatalVisitWhereInput
    /**
     * Limit how many PrenatalVisits to update.
     */
    limit?: number
  }

  /**
   * PrenatalVisit upsert
   */
  export type PrenatalVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the PrenatalVisit to update in case it exists.
     */
    where: PrenatalVisitWhereUniqueInput
    /**
     * In case the PrenatalVisit found by the `where` argument doesn't exist, create a new PrenatalVisit with this data.
     */
    create: XOR<PrenatalVisitCreateInput, PrenatalVisitUncheckedCreateInput>
    /**
     * In case the PrenatalVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrenatalVisitUpdateInput, PrenatalVisitUncheckedUpdateInput>
  }

  /**
   * PrenatalVisit delete
   */
  export type PrenatalVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
    /**
     * Filter which PrenatalVisit to delete.
     */
    where: PrenatalVisitWhereUniqueInput
  }

  /**
   * PrenatalVisit deleteMany
   */
  export type PrenatalVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrenatalVisits to delete
     */
    where?: PrenatalVisitWhereInput
    /**
     * Limit how many PrenatalVisits to delete.
     */
    limit?: number
  }

  /**
   * PrenatalVisit.laboratoryTests
   */
  export type PrenatalVisit$laboratoryTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    where?: LaboratoryTestWhereInput
    orderBy?: LaboratoryTestOrderByWithRelationInput | LaboratoryTestOrderByWithRelationInput[]
    cursor?: LaboratoryTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaboratoryTestScalarFieldEnum | LaboratoryTestScalarFieldEnum[]
  }

  /**
   * PrenatalVisit.interventions
   */
  export type PrenatalVisit$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    cursor?: InterventionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * PrenatalVisit without action
   */
  export type PrenatalVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrenatalVisit
     */
    select?: PrenatalVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrenatalVisit
     */
    omit?: PrenatalVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrenatalVisitInclude<ExtArgs> | null
  }


  /**
   * Model LaboratoryTest
   */

  export type AggregateLaboratoryTest = {
    _count: LaboratoryTestCountAggregateOutputType | null
    _min: LaboratoryTestMinAggregateOutputType | null
    _max: LaboratoryTestMaxAggregateOutputType | null
  }

  export type LaboratoryTestMinAggregateOutputType = {
    id: string | null
    prenatalVisitId: string | null
    userProfileId: string | null
    testDate: Date | null
    testType: string | null
    testCompleted: boolean | null
    recordedBy: string | null
  }

  export type LaboratoryTestMaxAggregateOutputType = {
    id: string | null
    prenatalVisitId: string | null
    userProfileId: string | null
    testDate: Date | null
    testType: string | null
    testCompleted: boolean | null
    recordedBy: string | null
  }

  export type LaboratoryTestCountAggregateOutputType = {
    id: number
    prenatalVisitId: number
    userProfileId: number
    testDate: number
    testType: number
    testCompleted: number
    recordedBy: number
    _all: number
  }


  export type LaboratoryTestMinAggregateInputType = {
    id?: true
    prenatalVisitId?: true
    userProfileId?: true
    testDate?: true
    testType?: true
    testCompleted?: true
    recordedBy?: true
  }

  export type LaboratoryTestMaxAggregateInputType = {
    id?: true
    prenatalVisitId?: true
    userProfileId?: true
    testDate?: true
    testType?: true
    testCompleted?: true
    recordedBy?: true
  }

  export type LaboratoryTestCountAggregateInputType = {
    id?: true
    prenatalVisitId?: true
    userProfileId?: true
    testDate?: true
    testType?: true
    testCompleted?: true
    recordedBy?: true
    _all?: true
  }

  export type LaboratoryTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaboratoryTest to aggregate.
     */
    where?: LaboratoryTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryTests to fetch.
     */
    orderBy?: LaboratoryTestOrderByWithRelationInput | LaboratoryTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaboratoryTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LaboratoryTests
    **/
    _count?: true | LaboratoryTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaboratoryTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaboratoryTestMaxAggregateInputType
  }

  export type GetLaboratoryTestAggregateType<T extends LaboratoryTestAggregateArgs> = {
        [P in keyof T & keyof AggregateLaboratoryTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaboratoryTest[P]>
      : GetScalarType<T[P], AggregateLaboratoryTest[P]>
  }




  export type LaboratoryTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaboratoryTestWhereInput
    orderBy?: LaboratoryTestOrderByWithAggregationInput | LaboratoryTestOrderByWithAggregationInput[]
    by: LaboratoryTestScalarFieldEnum[] | LaboratoryTestScalarFieldEnum
    having?: LaboratoryTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaboratoryTestCountAggregateInputType | true
    _min?: LaboratoryTestMinAggregateInputType
    _max?: LaboratoryTestMaxAggregateInputType
  }

  export type LaboratoryTestGroupByOutputType = {
    id: string
    prenatalVisitId: string
    userProfileId: string
    testDate: Date
    testType: string
    testCompleted: boolean
    recordedBy: string
    _count: LaboratoryTestCountAggregateOutputType | null
    _min: LaboratoryTestMinAggregateOutputType | null
    _max: LaboratoryTestMaxAggregateOutputType | null
  }

  type GetLaboratoryTestGroupByPayload<T extends LaboratoryTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaboratoryTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaboratoryTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaboratoryTestGroupByOutputType[P]>
            : GetScalarType<T[P], LaboratoryTestGroupByOutputType[P]>
        }
      >
    >


  export type LaboratoryTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prenatalVisitId?: boolean
    userProfileId?: boolean
    testDate?: boolean
    testType?: boolean
    testCompleted?: boolean
    recordedBy?: boolean
    prenatalVisit?: boolean | PrenatalVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["laboratoryTest"]>



  export type LaboratoryTestSelectScalar = {
    id?: boolean
    prenatalVisitId?: boolean
    userProfileId?: boolean
    testDate?: boolean
    testType?: boolean
    testCompleted?: boolean
    recordedBy?: boolean
  }

  export type LaboratoryTestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prenatalVisitId" | "userProfileId" | "testDate" | "testType" | "testCompleted" | "recordedBy", ExtArgs["result"]["laboratoryTest"]>
  export type LaboratoryTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prenatalVisit?: boolean | PrenatalVisitDefaultArgs<ExtArgs>
  }

  export type $LaboratoryTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LaboratoryTest"
    objects: {
      prenatalVisit: Prisma.$PrenatalVisitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prenatalVisitId: string
      userProfileId: string
      testDate: Date
      testType: string
      testCompleted: boolean
      recordedBy: string
    }, ExtArgs["result"]["laboratoryTest"]>
    composites: {}
  }

  type LaboratoryTestGetPayload<S extends boolean | null | undefined | LaboratoryTestDefaultArgs> = $Result.GetResult<Prisma.$LaboratoryTestPayload, S>

  type LaboratoryTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaboratoryTestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaboratoryTestCountAggregateInputType | true
    }

  export interface LaboratoryTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LaboratoryTest'], meta: { name: 'LaboratoryTest' } }
    /**
     * Find zero or one LaboratoryTest that matches the filter.
     * @param {LaboratoryTestFindUniqueArgs} args - Arguments to find a LaboratoryTest
     * @example
     * // Get one LaboratoryTest
     * const laboratoryTest = await prisma.laboratoryTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaboratoryTestFindUniqueArgs>(args: SelectSubset<T, LaboratoryTestFindUniqueArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LaboratoryTest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaboratoryTestFindUniqueOrThrowArgs} args - Arguments to find a LaboratoryTest
     * @example
     * // Get one LaboratoryTest
     * const laboratoryTest = await prisma.laboratoryTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaboratoryTestFindUniqueOrThrowArgs>(args: SelectSubset<T, LaboratoryTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaboratoryTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryTestFindFirstArgs} args - Arguments to find a LaboratoryTest
     * @example
     * // Get one LaboratoryTest
     * const laboratoryTest = await prisma.laboratoryTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaboratoryTestFindFirstArgs>(args?: SelectSubset<T, LaboratoryTestFindFirstArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LaboratoryTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryTestFindFirstOrThrowArgs} args - Arguments to find a LaboratoryTest
     * @example
     * // Get one LaboratoryTest
     * const laboratoryTest = await prisma.laboratoryTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaboratoryTestFindFirstOrThrowArgs>(args?: SelectSubset<T, LaboratoryTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LaboratoryTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LaboratoryTests
     * const laboratoryTests = await prisma.laboratoryTest.findMany()
     * 
     * // Get first 10 LaboratoryTests
     * const laboratoryTests = await prisma.laboratoryTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laboratoryTestWithIdOnly = await prisma.laboratoryTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaboratoryTestFindManyArgs>(args?: SelectSubset<T, LaboratoryTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LaboratoryTest.
     * @param {LaboratoryTestCreateArgs} args - Arguments to create a LaboratoryTest.
     * @example
     * // Create one LaboratoryTest
     * const LaboratoryTest = await prisma.laboratoryTest.create({
     *   data: {
     *     // ... data to create a LaboratoryTest
     *   }
     * })
     * 
     */
    create<T extends LaboratoryTestCreateArgs>(args: SelectSubset<T, LaboratoryTestCreateArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LaboratoryTests.
     * @param {LaboratoryTestCreateManyArgs} args - Arguments to create many LaboratoryTests.
     * @example
     * // Create many LaboratoryTests
     * const laboratoryTest = await prisma.laboratoryTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaboratoryTestCreateManyArgs>(args?: SelectSubset<T, LaboratoryTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LaboratoryTest.
     * @param {LaboratoryTestDeleteArgs} args - Arguments to delete one LaboratoryTest.
     * @example
     * // Delete one LaboratoryTest
     * const LaboratoryTest = await prisma.laboratoryTest.delete({
     *   where: {
     *     // ... filter to delete one LaboratoryTest
     *   }
     * })
     * 
     */
    delete<T extends LaboratoryTestDeleteArgs>(args: SelectSubset<T, LaboratoryTestDeleteArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LaboratoryTest.
     * @param {LaboratoryTestUpdateArgs} args - Arguments to update one LaboratoryTest.
     * @example
     * // Update one LaboratoryTest
     * const laboratoryTest = await prisma.laboratoryTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaboratoryTestUpdateArgs>(args: SelectSubset<T, LaboratoryTestUpdateArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LaboratoryTests.
     * @param {LaboratoryTestDeleteManyArgs} args - Arguments to filter LaboratoryTests to delete.
     * @example
     * // Delete a few LaboratoryTests
     * const { count } = await prisma.laboratoryTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaboratoryTestDeleteManyArgs>(args?: SelectSubset<T, LaboratoryTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LaboratoryTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LaboratoryTests
     * const laboratoryTest = await prisma.laboratoryTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaboratoryTestUpdateManyArgs>(args: SelectSubset<T, LaboratoryTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LaboratoryTest.
     * @param {LaboratoryTestUpsertArgs} args - Arguments to update or create a LaboratoryTest.
     * @example
     * // Update or create a LaboratoryTest
     * const laboratoryTest = await prisma.laboratoryTest.upsert({
     *   create: {
     *     // ... data to create a LaboratoryTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LaboratoryTest we want to update
     *   }
     * })
     */
    upsert<T extends LaboratoryTestUpsertArgs>(args: SelectSubset<T, LaboratoryTestUpsertArgs<ExtArgs>>): Prisma__LaboratoryTestClient<$Result.GetResult<Prisma.$LaboratoryTestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LaboratoryTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryTestCountArgs} args - Arguments to filter LaboratoryTests to count.
     * @example
     * // Count the number of LaboratoryTests
     * const count = await prisma.laboratoryTest.count({
     *   where: {
     *     // ... the filter for the LaboratoryTests we want to count
     *   }
     * })
    **/
    count<T extends LaboratoryTestCountArgs>(
      args?: Subset<T, LaboratoryTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaboratoryTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LaboratoryTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaboratoryTestAggregateArgs>(args: Subset<T, LaboratoryTestAggregateArgs>): Prisma.PrismaPromise<GetLaboratoryTestAggregateType<T>>

    /**
     * Group by LaboratoryTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaboratoryTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaboratoryTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaboratoryTestGroupByArgs['orderBy'] }
        : { orderBy?: LaboratoryTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaboratoryTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaboratoryTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LaboratoryTest model
   */
  readonly fields: LaboratoryTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LaboratoryTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaboratoryTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prenatalVisit<T extends PrenatalVisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrenatalVisitDefaultArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LaboratoryTest model
   */
  interface LaboratoryTestFieldRefs {
    readonly id: FieldRef<"LaboratoryTest", 'String'>
    readonly prenatalVisitId: FieldRef<"LaboratoryTest", 'String'>
    readonly userProfileId: FieldRef<"LaboratoryTest", 'String'>
    readonly testDate: FieldRef<"LaboratoryTest", 'DateTime'>
    readonly testType: FieldRef<"LaboratoryTest", 'String'>
    readonly testCompleted: FieldRef<"LaboratoryTest", 'Boolean'>
    readonly recordedBy: FieldRef<"LaboratoryTest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LaboratoryTest findUnique
   */
  export type LaboratoryTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryTest to fetch.
     */
    where: LaboratoryTestWhereUniqueInput
  }

  /**
   * LaboratoryTest findUniqueOrThrow
   */
  export type LaboratoryTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryTest to fetch.
     */
    where: LaboratoryTestWhereUniqueInput
  }

  /**
   * LaboratoryTest findFirst
   */
  export type LaboratoryTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryTest to fetch.
     */
    where?: LaboratoryTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryTests to fetch.
     */
    orderBy?: LaboratoryTestOrderByWithRelationInput | LaboratoryTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaboratoryTests.
     */
    cursor?: LaboratoryTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaboratoryTests.
     */
    distinct?: LaboratoryTestScalarFieldEnum | LaboratoryTestScalarFieldEnum[]
  }

  /**
   * LaboratoryTest findFirstOrThrow
   */
  export type LaboratoryTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryTest to fetch.
     */
    where?: LaboratoryTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryTests to fetch.
     */
    orderBy?: LaboratoryTestOrderByWithRelationInput | LaboratoryTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LaboratoryTests.
     */
    cursor?: LaboratoryTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LaboratoryTests.
     */
    distinct?: LaboratoryTestScalarFieldEnum | LaboratoryTestScalarFieldEnum[]
  }

  /**
   * LaboratoryTest findMany
   */
  export type LaboratoryTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * Filter, which LaboratoryTests to fetch.
     */
    where?: LaboratoryTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LaboratoryTests to fetch.
     */
    orderBy?: LaboratoryTestOrderByWithRelationInput | LaboratoryTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LaboratoryTests.
     */
    cursor?: LaboratoryTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LaboratoryTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LaboratoryTests.
     */
    skip?: number
    distinct?: LaboratoryTestScalarFieldEnum | LaboratoryTestScalarFieldEnum[]
  }

  /**
   * LaboratoryTest create
   */
  export type LaboratoryTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * The data needed to create a LaboratoryTest.
     */
    data: XOR<LaboratoryTestCreateInput, LaboratoryTestUncheckedCreateInput>
  }

  /**
   * LaboratoryTest createMany
   */
  export type LaboratoryTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LaboratoryTests.
     */
    data: LaboratoryTestCreateManyInput | LaboratoryTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LaboratoryTest update
   */
  export type LaboratoryTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * The data needed to update a LaboratoryTest.
     */
    data: XOR<LaboratoryTestUpdateInput, LaboratoryTestUncheckedUpdateInput>
    /**
     * Choose, which LaboratoryTest to update.
     */
    where: LaboratoryTestWhereUniqueInput
  }

  /**
   * LaboratoryTest updateMany
   */
  export type LaboratoryTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LaboratoryTests.
     */
    data: XOR<LaboratoryTestUpdateManyMutationInput, LaboratoryTestUncheckedUpdateManyInput>
    /**
     * Filter which LaboratoryTests to update
     */
    where?: LaboratoryTestWhereInput
    /**
     * Limit how many LaboratoryTests to update.
     */
    limit?: number
  }

  /**
   * LaboratoryTest upsert
   */
  export type LaboratoryTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * The filter to search for the LaboratoryTest to update in case it exists.
     */
    where: LaboratoryTestWhereUniqueInput
    /**
     * In case the LaboratoryTest found by the `where` argument doesn't exist, create a new LaboratoryTest with this data.
     */
    create: XOR<LaboratoryTestCreateInput, LaboratoryTestUncheckedCreateInput>
    /**
     * In case the LaboratoryTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaboratoryTestUpdateInput, LaboratoryTestUncheckedUpdateInput>
  }

  /**
   * LaboratoryTest delete
   */
  export type LaboratoryTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
    /**
     * Filter which LaboratoryTest to delete.
     */
    where: LaboratoryTestWhereUniqueInput
  }

  /**
   * LaboratoryTest deleteMany
   */
  export type LaboratoryTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LaboratoryTests to delete
     */
    where?: LaboratoryTestWhereInput
    /**
     * Limit how many LaboratoryTests to delete.
     */
    limit?: number
  }

  /**
   * LaboratoryTest without action
   */
  export type LaboratoryTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaboratoryTest
     */
    select?: LaboratoryTestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LaboratoryTest
     */
    omit?: LaboratoryTestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaboratoryTestInclude<ExtArgs> | null
  }


  /**
   * Model Intervention
   */

  export type AggregateIntervention = {
    _count: InterventionCountAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  export type InterventionMinAggregateOutputType = {
    id: string | null
    prenatalVisitId: string | null
    tetanusToxoidDose: string | null
    tetanusToxoidLocation: string | null
    tetanusToxoidDate: Date | null
    ironSupplementation: boolean | null
    ironMedication: string | null
    vitaminSupplementation: boolean | null
    vitaminMedication: string | null
    calciumSupplementation: boolean | null
    calciumMedication: string | null
  }

  export type InterventionMaxAggregateOutputType = {
    id: string | null
    prenatalVisitId: string | null
    tetanusToxoidDose: string | null
    tetanusToxoidLocation: string | null
    tetanusToxoidDate: Date | null
    ironSupplementation: boolean | null
    ironMedication: string | null
    vitaminSupplementation: boolean | null
    vitaminMedication: string | null
    calciumSupplementation: boolean | null
    calciumMedication: string | null
  }

  export type InterventionCountAggregateOutputType = {
    id: number
    prenatalVisitId: number
    tetanusToxoidDose: number
    tetanusToxoidLocation: number
    tetanusToxoidDate: number
    ironSupplementation: number
    ironMedication: number
    vitaminSupplementation: number
    vitaminMedication: number
    calciumSupplementation: number
    calciumMedication: number
    healthEducationTopics: number
    _all: number
  }


  export type InterventionMinAggregateInputType = {
    id?: true
    prenatalVisitId?: true
    tetanusToxoidDose?: true
    tetanusToxoidLocation?: true
    tetanusToxoidDate?: true
    ironSupplementation?: true
    ironMedication?: true
    vitaminSupplementation?: true
    vitaminMedication?: true
    calciumSupplementation?: true
    calciumMedication?: true
  }

  export type InterventionMaxAggregateInputType = {
    id?: true
    prenatalVisitId?: true
    tetanusToxoidDose?: true
    tetanusToxoidLocation?: true
    tetanusToxoidDate?: true
    ironSupplementation?: true
    ironMedication?: true
    vitaminSupplementation?: true
    vitaminMedication?: true
    calciumSupplementation?: true
    calciumMedication?: true
  }

  export type InterventionCountAggregateInputType = {
    id?: true
    prenatalVisitId?: true
    tetanusToxoidDose?: true
    tetanusToxoidLocation?: true
    tetanusToxoidDate?: true
    ironSupplementation?: true
    ironMedication?: true
    vitaminSupplementation?: true
    vitaminMedication?: true
    calciumSupplementation?: true
    calciumMedication?: true
    healthEducationTopics?: true
    _all?: true
  }

  export type InterventionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intervention to aggregate.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interventions
    **/
    _count?: true | InterventionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionMaxAggregateInputType
  }

  export type GetInterventionAggregateType<T extends InterventionAggregateArgs> = {
        [P in keyof T & keyof AggregateIntervention]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntervention[P]>
      : GetScalarType<T[P], AggregateIntervention[P]>
  }




  export type InterventionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionWhereInput
    orderBy?: InterventionOrderByWithAggregationInput | InterventionOrderByWithAggregationInput[]
    by: InterventionScalarFieldEnum[] | InterventionScalarFieldEnum
    having?: InterventionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionCountAggregateInputType | true
    _min?: InterventionMinAggregateInputType
    _max?: InterventionMaxAggregateInputType
  }

  export type InterventionGroupByOutputType = {
    id: string
    prenatalVisitId: string
    tetanusToxoidDose: string | null
    tetanusToxoidLocation: string | null
    tetanusToxoidDate: Date | null
    ironSupplementation: boolean
    ironMedication: string | null
    vitaminSupplementation: boolean
    vitaminMedication: string | null
    calciumSupplementation: boolean
    calciumMedication: string | null
    healthEducationTopics: JsonValue
    _count: InterventionCountAggregateOutputType | null
    _min: InterventionMinAggregateOutputType | null
    _max: InterventionMaxAggregateOutputType | null
  }

  type GetInterventionGroupByPayload<T extends InterventionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionGroupByOutputType[P]>
        }
      >
    >


  export type InterventionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prenatalVisitId?: boolean
    tetanusToxoidDose?: boolean
    tetanusToxoidLocation?: boolean
    tetanusToxoidDate?: boolean
    ironSupplementation?: boolean
    ironMedication?: boolean
    vitaminSupplementation?: boolean
    vitaminMedication?: boolean
    calciumSupplementation?: boolean
    calciumMedication?: boolean
    healthEducationTopics?: boolean
    prenatalVisit?: boolean | PrenatalVisitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervention"]>



  export type InterventionSelectScalar = {
    id?: boolean
    prenatalVisitId?: boolean
    tetanusToxoidDose?: boolean
    tetanusToxoidLocation?: boolean
    tetanusToxoidDate?: boolean
    ironSupplementation?: boolean
    ironMedication?: boolean
    vitaminSupplementation?: boolean
    vitaminMedication?: boolean
    calciumSupplementation?: boolean
    calciumMedication?: boolean
    healthEducationTopics?: boolean
  }

  export type InterventionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prenatalVisitId" | "tetanusToxoidDose" | "tetanusToxoidLocation" | "tetanusToxoidDate" | "ironSupplementation" | "ironMedication" | "vitaminSupplementation" | "vitaminMedication" | "calciumSupplementation" | "calciumMedication" | "healthEducationTopics", ExtArgs["result"]["intervention"]>
  export type InterventionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prenatalVisit?: boolean | PrenatalVisitDefaultArgs<ExtArgs>
  }

  export type $InterventionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Intervention"
    objects: {
      prenatalVisit: Prisma.$PrenatalVisitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prenatalVisitId: string
      tetanusToxoidDose: string | null
      tetanusToxoidLocation: string | null
      tetanusToxoidDate: Date | null
      ironSupplementation: boolean
      ironMedication: string | null
      vitaminSupplementation: boolean
      vitaminMedication: string | null
      calciumSupplementation: boolean
      calciumMedication: string | null
      healthEducationTopics: Prisma.JsonValue
    }, ExtArgs["result"]["intervention"]>
    composites: {}
  }

  type InterventionGetPayload<S extends boolean | null | undefined | InterventionDefaultArgs> = $Result.GetResult<Prisma.$InterventionPayload, S>

  type InterventionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterventionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterventionCountAggregateInputType | true
    }

  export interface InterventionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Intervention'], meta: { name: 'Intervention' } }
    /**
     * Find zero or one Intervention that matches the filter.
     * @param {InterventionFindUniqueArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionFindUniqueArgs>(args: SelectSubset<T, InterventionFindUniqueArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Intervention that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterventionFindUniqueOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intervention that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionFindFirstArgs>(args?: SelectSubset<T, InterventionFindFirstArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Intervention that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindFirstOrThrowArgs} args - Arguments to find a Intervention
     * @example
     * // Get one Intervention
     * const intervention = await prisma.intervention.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interventions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interventions
     * const interventions = await prisma.intervention.findMany()
     * 
     * // Get first 10 Interventions
     * const interventions = await prisma.intervention.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interventionWithIdOnly = await prisma.intervention.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterventionFindManyArgs>(args?: SelectSubset<T, InterventionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Intervention.
     * @param {InterventionCreateArgs} args - Arguments to create a Intervention.
     * @example
     * // Create one Intervention
     * const Intervention = await prisma.intervention.create({
     *   data: {
     *     // ... data to create a Intervention
     *   }
     * })
     * 
     */
    create<T extends InterventionCreateArgs>(args: SelectSubset<T, InterventionCreateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interventions.
     * @param {InterventionCreateManyArgs} args - Arguments to create many Interventions.
     * @example
     * // Create many Interventions
     * const intervention = await prisma.intervention.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionCreateManyArgs>(args?: SelectSubset<T, InterventionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Intervention.
     * @param {InterventionDeleteArgs} args - Arguments to delete one Intervention.
     * @example
     * // Delete one Intervention
     * const Intervention = await prisma.intervention.delete({
     *   where: {
     *     // ... filter to delete one Intervention
     *   }
     * })
     * 
     */
    delete<T extends InterventionDeleteArgs>(args: SelectSubset<T, InterventionDeleteArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Intervention.
     * @param {InterventionUpdateArgs} args - Arguments to update one Intervention.
     * @example
     * // Update one Intervention
     * const intervention = await prisma.intervention.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionUpdateArgs>(args: SelectSubset<T, InterventionUpdateArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interventions.
     * @param {InterventionDeleteManyArgs} args - Arguments to filter Interventions to delete.
     * @example
     * // Delete a few Interventions
     * const { count } = await prisma.intervention.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionDeleteManyArgs>(args?: SelectSubset<T, InterventionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interventions
     * const intervention = await prisma.intervention.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionUpdateManyArgs>(args: SelectSubset<T, InterventionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Intervention.
     * @param {InterventionUpsertArgs} args - Arguments to update or create a Intervention.
     * @example
     * // Update or create a Intervention
     * const intervention = await prisma.intervention.upsert({
     *   create: {
     *     // ... data to create a Intervention
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intervention we want to update
     *   }
     * })
     */
    upsert<T extends InterventionUpsertArgs>(args: SelectSubset<T, InterventionUpsertArgs<ExtArgs>>): Prisma__InterventionClient<$Result.GetResult<Prisma.$InterventionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interventions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionCountArgs} args - Arguments to filter Interventions to count.
     * @example
     * // Count the number of Interventions
     * const count = await prisma.intervention.count({
     *   where: {
     *     // ... the filter for the Interventions we want to count
     *   }
     * })
    **/
    count<T extends InterventionCountArgs>(
      args?: Subset<T, InterventionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionAggregateArgs>(args: Subset<T, InterventionAggregateArgs>): Prisma.PrismaPromise<GetInterventionAggregateType<T>>

    /**
     * Group by Intervention.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionGroupByArgs['orderBy'] }
        : { orderBy?: InterventionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Intervention model
   */
  readonly fields: InterventionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Intervention.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prenatalVisit<T extends PrenatalVisitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrenatalVisitDefaultArgs<ExtArgs>>): Prisma__PrenatalVisitClient<$Result.GetResult<Prisma.$PrenatalVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Intervention model
   */
  interface InterventionFieldRefs {
    readonly id: FieldRef<"Intervention", 'String'>
    readonly prenatalVisitId: FieldRef<"Intervention", 'String'>
    readonly tetanusToxoidDose: FieldRef<"Intervention", 'String'>
    readonly tetanusToxoidLocation: FieldRef<"Intervention", 'String'>
    readonly tetanusToxoidDate: FieldRef<"Intervention", 'DateTime'>
    readonly ironSupplementation: FieldRef<"Intervention", 'Boolean'>
    readonly ironMedication: FieldRef<"Intervention", 'String'>
    readonly vitaminSupplementation: FieldRef<"Intervention", 'Boolean'>
    readonly vitaminMedication: FieldRef<"Intervention", 'String'>
    readonly calciumSupplementation: FieldRef<"Intervention", 'Boolean'>
    readonly calciumMedication: FieldRef<"Intervention", 'String'>
    readonly healthEducationTopics: FieldRef<"Intervention", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Intervention findUnique
   */
  export type InterventionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findUniqueOrThrow
   */
  export type InterventionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention findFirst
   */
  export type InterventionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findFirstOrThrow
   */
  export type InterventionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Intervention to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interventions.
     */
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention findMany
   */
  export type InterventionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter, which Interventions to fetch.
     */
    where?: InterventionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interventions to fetch.
     */
    orderBy?: InterventionOrderByWithRelationInput | InterventionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interventions.
     */
    cursor?: InterventionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interventions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interventions.
     */
    skip?: number
    distinct?: InterventionScalarFieldEnum | InterventionScalarFieldEnum[]
  }

  /**
   * Intervention create
   */
  export type InterventionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to create a Intervention.
     */
    data: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
  }

  /**
   * Intervention createMany
   */
  export type InterventionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interventions.
     */
    data: InterventionCreateManyInput | InterventionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intervention update
   */
  export type InterventionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The data needed to update a Intervention.
     */
    data: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
    /**
     * Choose, which Intervention to update.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention updateMany
   */
  export type InterventionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interventions.
     */
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyInput>
    /**
     * Filter which Interventions to update
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to update.
     */
    limit?: number
  }

  /**
   * Intervention upsert
   */
  export type InterventionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * The filter to search for the Intervention to update in case it exists.
     */
    where: InterventionWhereUniqueInput
    /**
     * In case the Intervention found by the `where` argument doesn't exist, create a new Intervention with this data.
     */
    create: XOR<InterventionCreateInput, InterventionUncheckedCreateInput>
    /**
     * In case the Intervention was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionUpdateInput, InterventionUncheckedUpdateInput>
  }

  /**
   * Intervention delete
   */
  export type InterventionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
    /**
     * Filter which Intervention to delete.
     */
    where: InterventionWhereUniqueInput
  }

  /**
   * Intervention deleteMany
   */
  export type InterventionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interventions to delete
     */
    where?: InterventionWhereInput
    /**
     * Limit how many Interventions to delete.
     */
    limit?: number
  }

  /**
   * Intervention without action
   */
  export type InterventionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervention
     */
    select?: InterventionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Intervention
     */
    omit?: InterventionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionInclude<ExtArgs> | null
  }


  /**
   * Model BirthInformation
   */

  export type AggregateBirthInformation = {
    _count: BirthInformationCountAggregateOutputType | null
    _avg: BirthInformationAvgAggregateOutputType | null
    _sum: BirthInformationSumAggregateOutputType | null
    _min: BirthInformationMinAggregateOutputType | null
    _max: BirthInformationMaxAggregateOutputType | null
  }

  export type BirthInformationAvgAggregateOutputType = {
    birthWeightKg: number | null
    birthHeightCm: number | null
  }

  export type BirthInformationSumAggregateOutputType = {
    birthWeightKg: number | null
    birthHeightCm: number | null
  }

  export type BirthInformationMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    maternalHealthId: string | null
    placeOfDelivery: string | null
    timeOfDelivery: string | null
    deliveryType: string | null
    birthWeightKg: number | null
    birthHeightCm: number | null
    newbornScreeningDate: Date | null
    newbornScreeningCompleted: boolean | null
    feedingType: string | null
    createdAt: Date | null
    recordedBy: string | null
  }

  export type BirthInformationMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    maternalHealthId: string | null
    placeOfDelivery: string | null
    timeOfDelivery: string | null
    deliveryType: string | null
    birthWeightKg: number | null
    birthHeightCm: number | null
    newbornScreeningDate: Date | null
    newbornScreeningCompleted: boolean | null
    feedingType: string | null
    createdAt: Date | null
    recordedBy: string | null
  }

  export type BirthInformationCountAggregateOutputType = {
    id: number
    userProfileId: number
    maternalHealthId: number
    placeOfDelivery: number
    timeOfDelivery: number
    deliveryType: number
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate: number
    newbornScreeningCompleted: number
    feedingType: number
    createdAt: number
    recordedBy: number
    _all: number
  }


  export type BirthInformationAvgAggregateInputType = {
    birthWeightKg?: true
    birthHeightCm?: true
  }

  export type BirthInformationSumAggregateInputType = {
    birthWeightKg?: true
    birthHeightCm?: true
  }

  export type BirthInformationMinAggregateInputType = {
    id?: true
    userProfileId?: true
    maternalHealthId?: true
    placeOfDelivery?: true
    timeOfDelivery?: true
    deliveryType?: true
    birthWeightKg?: true
    birthHeightCm?: true
    newbornScreeningDate?: true
    newbornScreeningCompleted?: true
    feedingType?: true
    createdAt?: true
    recordedBy?: true
  }

  export type BirthInformationMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    maternalHealthId?: true
    placeOfDelivery?: true
    timeOfDelivery?: true
    deliveryType?: true
    birthWeightKg?: true
    birthHeightCm?: true
    newbornScreeningDate?: true
    newbornScreeningCompleted?: true
    feedingType?: true
    createdAt?: true
    recordedBy?: true
  }

  export type BirthInformationCountAggregateInputType = {
    id?: true
    userProfileId?: true
    maternalHealthId?: true
    placeOfDelivery?: true
    timeOfDelivery?: true
    deliveryType?: true
    birthWeightKg?: true
    birthHeightCm?: true
    newbornScreeningDate?: true
    newbornScreeningCompleted?: true
    feedingType?: true
    createdAt?: true
    recordedBy?: true
    _all?: true
  }

  export type BirthInformationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BirthInformation to aggregate.
     */
    where?: BirthInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BirthInformations to fetch.
     */
    orderBy?: BirthInformationOrderByWithRelationInput | BirthInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BirthInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BirthInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BirthInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BirthInformations
    **/
    _count?: true | BirthInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BirthInformationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BirthInformationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BirthInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BirthInformationMaxAggregateInputType
  }

  export type GetBirthInformationAggregateType<T extends BirthInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateBirthInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBirthInformation[P]>
      : GetScalarType<T[P], AggregateBirthInformation[P]>
  }




  export type BirthInformationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BirthInformationWhereInput
    orderBy?: BirthInformationOrderByWithAggregationInput | BirthInformationOrderByWithAggregationInput[]
    by: BirthInformationScalarFieldEnum[] | BirthInformationScalarFieldEnum
    having?: BirthInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BirthInformationCountAggregateInputType | true
    _avg?: BirthInformationAvgAggregateInputType
    _sum?: BirthInformationSumAggregateInputType
    _min?: BirthInformationMinAggregateInputType
    _max?: BirthInformationMaxAggregateInputType
  }

  export type BirthInformationGroupByOutputType = {
    id: string
    userProfileId: string
    maternalHealthId: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate: Date | null
    newbornScreeningCompleted: boolean
    feedingType: string
    createdAt: Date
    recordedBy: string
    _count: BirthInformationCountAggregateOutputType | null
    _avg: BirthInformationAvgAggregateOutputType | null
    _sum: BirthInformationSumAggregateOutputType | null
    _min: BirthInformationMinAggregateOutputType | null
    _max: BirthInformationMaxAggregateOutputType | null
  }

  type GetBirthInformationGroupByPayload<T extends BirthInformationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BirthInformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BirthInformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BirthInformationGroupByOutputType[P]>
            : GetScalarType<T[P], BirthInformationGroupByOutputType[P]>
        }
      >
    >


  export type BirthInformationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    maternalHealthId?: boolean
    placeOfDelivery?: boolean
    timeOfDelivery?: boolean
    deliveryType?: boolean
    birthWeightKg?: boolean
    birthHeightCm?: boolean
    newbornScreeningDate?: boolean
    newbornScreeningCompleted?: boolean
    feedingType?: boolean
    createdAt?: boolean
    recordedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    maternalHealth?: boolean | MaternalHealthDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["birthInformation"]>



  export type BirthInformationSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    maternalHealthId?: boolean
    placeOfDelivery?: boolean
    timeOfDelivery?: boolean
    deliveryType?: boolean
    birthWeightKg?: boolean
    birthHeightCm?: boolean
    newbornScreeningDate?: boolean
    newbornScreeningCompleted?: boolean
    feedingType?: boolean
    createdAt?: boolean
    recordedBy?: boolean
  }

  export type BirthInformationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "maternalHealthId" | "placeOfDelivery" | "timeOfDelivery" | "deliveryType" | "birthWeightKg" | "birthHeightCm" | "newbornScreeningDate" | "newbornScreeningCompleted" | "feedingType" | "createdAt" | "recordedBy", ExtArgs["result"]["birthInformation"]>
  export type BirthInformationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    maternalHealth?: boolean | MaternalHealthDefaultArgs<ExtArgs>
  }

  export type $BirthInformationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BirthInformation"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
      maternalHealth: Prisma.$MaternalHealthPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      maternalHealthId: string
      placeOfDelivery: string
      timeOfDelivery: string
      deliveryType: string
      birthWeightKg: number
      birthHeightCm: number
      newbornScreeningDate: Date | null
      newbornScreeningCompleted: boolean
      feedingType: string
      createdAt: Date
      recordedBy: string
    }, ExtArgs["result"]["birthInformation"]>
    composites: {}
  }

  type BirthInformationGetPayload<S extends boolean | null | undefined | BirthInformationDefaultArgs> = $Result.GetResult<Prisma.$BirthInformationPayload, S>

  type BirthInformationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BirthInformationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BirthInformationCountAggregateInputType | true
    }

  export interface BirthInformationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BirthInformation'], meta: { name: 'BirthInformation' } }
    /**
     * Find zero or one BirthInformation that matches the filter.
     * @param {BirthInformationFindUniqueArgs} args - Arguments to find a BirthInformation
     * @example
     * // Get one BirthInformation
     * const birthInformation = await prisma.birthInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BirthInformationFindUniqueArgs>(args: SelectSubset<T, BirthInformationFindUniqueArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BirthInformation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BirthInformationFindUniqueOrThrowArgs} args - Arguments to find a BirthInformation
     * @example
     * // Get one BirthInformation
     * const birthInformation = await prisma.birthInformation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BirthInformationFindUniqueOrThrowArgs>(args: SelectSubset<T, BirthInformationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BirthInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BirthInformationFindFirstArgs} args - Arguments to find a BirthInformation
     * @example
     * // Get one BirthInformation
     * const birthInformation = await prisma.birthInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BirthInformationFindFirstArgs>(args?: SelectSubset<T, BirthInformationFindFirstArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BirthInformation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BirthInformationFindFirstOrThrowArgs} args - Arguments to find a BirthInformation
     * @example
     * // Get one BirthInformation
     * const birthInformation = await prisma.birthInformation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BirthInformationFindFirstOrThrowArgs>(args?: SelectSubset<T, BirthInformationFindFirstOrThrowArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BirthInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BirthInformationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BirthInformations
     * const birthInformations = await prisma.birthInformation.findMany()
     * 
     * // Get first 10 BirthInformations
     * const birthInformations = await prisma.birthInformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const birthInformationWithIdOnly = await prisma.birthInformation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BirthInformationFindManyArgs>(args?: SelectSubset<T, BirthInformationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BirthInformation.
     * @param {BirthInformationCreateArgs} args - Arguments to create a BirthInformation.
     * @example
     * // Create one BirthInformation
     * const BirthInformation = await prisma.birthInformation.create({
     *   data: {
     *     // ... data to create a BirthInformation
     *   }
     * })
     * 
     */
    create<T extends BirthInformationCreateArgs>(args: SelectSubset<T, BirthInformationCreateArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BirthInformations.
     * @param {BirthInformationCreateManyArgs} args - Arguments to create many BirthInformations.
     * @example
     * // Create many BirthInformations
     * const birthInformation = await prisma.birthInformation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BirthInformationCreateManyArgs>(args?: SelectSubset<T, BirthInformationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BirthInformation.
     * @param {BirthInformationDeleteArgs} args - Arguments to delete one BirthInformation.
     * @example
     * // Delete one BirthInformation
     * const BirthInformation = await prisma.birthInformation.delete({
     *   where: {
     *     // ... filter to delete one BirthInformation
     *   }
     * })
     * 
     */
    delete<T extends BirthInformationDeleteArgs>(args: SelectSubset<T, BirthInformationDeleteArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BirthInformation.
     * @param {BirthInformationUpdateArgs} args - Arguments to update one BirthInformation.
     * @example
     * // Update one BirthInformation
     * const birthInformation = await prisma.birthInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BirthInformationUpdateArgs>(args: SelectSubset<T, BirthInformationUpdateArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BirthInformations.
     * @param {BirthInformationDeleteManyArgs} args - Arguments to filter BirthInformations to delete.
     * @example
     * // Delete a few BirthInformations
     * const { count } = await prisma.birthInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BirthInformationDeleteManyArgs>(args?: SelectSubset<T, BirthInformationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BirthInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BirthInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BirthInformations
     * const birthInformation = await prisma.birthInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BirthInformationUpdateManyArgs>(args: SelectSubset<T, BirthInformationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BirthInformation.
     * @param {BirthInformationUpsertArgs} args - Arguments to update or create a BirthInformation.
     * @example
     * // Update or create a BirthInformation
     * const birthInformation = await prisma.birthInformation.upsert({
     *   create: {
     *     // ... data to create a BirthInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BirthInformation we want to update
     *   }
     * })
     */
    upsert<T extends BirthInformationUpsertArgs>(args: SelectSubset<T, BirthInformationUpsertArgs<ExtArgs>>): Prisma__BirthInformationClient<$Result.GetResult<Prisma.$BirthInformationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BirthInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BirthInformationCountArgs} args - Arguments to filter BirthInformations to count.
     * @example
     * // Count the number of BirthInformations
     * const count = await prisma.birthInformation.count({
     *   where: {
     *     // ... the filter for the BirthInformations we want to count
     *   }
     * })
    **/
    count<T extends BirthInformationCountArgs>(
      args?: Subset<T, BirthInformationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BirthInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BirthInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BirthInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BirthInformationAggregateArgs>(args: Subset<T, BirthInformationAggregateArgs>): Prisma.PrismaPromise<GetBirthInformationAggregateType<T>>

    /**
     * Group by BirthInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BirthInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BirthInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BirthInformationGroupByArgs['orderBy'] }
        : { orderBy?: BirthInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BirthInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBirthInformationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BirthInformation model
   */
  readonly fields: BirthInformationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BirthInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BirthInformationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maternalHealth<T extends MaternalHealthDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaternalHealthDefaultArgs<ExtArgs>>): Prisma__MaternalHealthClient<$Result.GetResult<Prisma.$MaternalHealthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BirthInformation model
   */
  interface BirthInformationFieldRefs {
    readonly id: FieldRef<"BirthInformation", 'String'>
    readonly userProfileId: FieldRef<"BirthInformation", 'String'>
    readonly maternalHealthId: FieldRef<"BirthInformation", 'String'>
    readonly placeOfDelivery: FieldRef<"BirthInformation", 'String'>
    readonly timeOfDelivery: FieldRef<"BirthInformation", 'String'>
    readonly deliveryType: FieldRef<"BirthInformation", 'String'>
    readonly birthWeightKg: FieldRef<"BirthInformation", 'Float'>
    readonly birthHeightCm: FieldRef<"BirthInformation", 'Float'>
    readonly newbornScreeningDate: FieldRef<"BirthInformation", 'DateTime'>
    readonly newbornScreeningCompleted: FieldRef<"BirthInformation", 'Boolean'>
    readonly feedingType: FieldRef<"BirthInformation", 'String'>
    readonly createdAt: FieldRef<"BirthInformation", 'DateTime'>
    readonly recordedBy: FieldRef<"BirthInformation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BirthInformation findUnique
   */
  export type BirthInformationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * Filter, which BirthInformation to fetch.
     */
    where: BirthInformationWhereUniqueInput
  }

  /**
   * BirthInformation findUniqueOrThrow
   */
  export type BirthInformationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * Filter, which BirthInformation to fetch.
     */
    where: BirthInformationWhereUniqueInput
  }

  /**
   * BirthInformation findFirst
   */
  export type BirthInformationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * Filter, which BirthInformation to fetch.
     */
    where?: BirthInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BirthInformations to fetch.
     */
    orderBy?: BirthInformationOrderByWithRelationInput | BirthInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BirthInformations.
     */
    cursor?: BirthInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BirthInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BirthInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BirthInformations.
     */
    distinct?: BirthInformationScalarFieldEnum | BirthInformationScalarFieldEnum[]
  }

  /**
   * BirthInformation findFirstOrThrow
   */
  export type BirthInformationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * Filter, which BirthInformation to fetch.
     */
    where?: BirthInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BirthInformations to fetch.
     */
    orderBy?: BirthInformationOrderByWithRelationInput | BirthInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BirthInformations.
     */
    cursor?: BirthInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BirthInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BirthInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BirthInformations.
     */
    distinct?: BirthInformationScalarFieldEnum | BirthInformationScalarFieldEnum[]
  }

  /**
   * BirthInformation findMany
   */
  export type BirthInformationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * Filter, which BirthInformations to fetch.
     */
    where?: BirthInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BirthInformations to fetch.
     */
    orderBy?: BirthInformationOrderByWithRelationInput | BirthInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BirthInformations.
     */
    cursor?: BirthInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BirthInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BirthInformations.
     */
    skip?: number
    distinct?: BirthInformationScalarFieldEnum | BirthInformationScalarFieldEnum[]
  }

  /**
   * BirthInformation create
   */
  export type BirthInformationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * The data needed to create a BirthInformation.
     */
    data: XOR<BirthInformationCreateInput, BirthInformationUncheckedCreateInput>
  }

  /**
   * BirthInformation createMany
   */
  export type BirthInformationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BirthInformations.
     */
    data: BirthInformationCreateManyInput | BirthInformationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BirthInformation update
   */
  export type BirthInformationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * The data needed to update a BirthInformation.
     */
    data: XOR<BirthInformationUpdateInput, BirthInformationUncheckedUpdateInput>
    /**
     * Choose, which BirthInformation to update.
     */
    where: BirthInformationWhereUniqueInput
  }

  /**
   * BirthInformation updateMany
   */
  export type BirthInformationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BirthInformations.
     */
    data: XOR<BirthInformationUpdateManyMutationInput, BirthInformationUncheckedUpdateManyInput>
    /**
     * Filter which BirthInformations to update
     */
    where?: BirthInformationWhereInput
    /**
     * Limit how many BirthInformations to update.
     */
    limit?: number
  }

  /**
   * BirthInformation upsert
   */
  export type BirthInformationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * The filter to search for the BirthInformation to update in case it exists.
     */
    where: BirthInformationWhereUniqueInput
    /**
     * In case the BirthInformation found by the `where` argument doesn't exist, create a new BirthInformation with this data.
     */
    create: XOR<BirthInformationCreateInput, BirthInformationUncheckedCreateInput>
    /**
     * In case the BirthInformation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BirthInformationUpdateInput, BirthInformationUncheckedUpdateInput>
  }

  /**
   * BirthInformation delete
   */
  export type BirthInformationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
    /**
     * Filter which BirthInformation to delete.
     */
    where: BirthInformationWhereUniqueInput
  }

  /**
   * BirthInformation deleteMany
   */
  export type BirthInformationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BirthInformations to delete
     */
    where?: BirthInformationWhereInput
    /**
     * Limit how many BirthInformations to delete.
     */
    limit?: number
  }

  /**
   * BirthInformation without action
   */
  export type BirthInformationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BirthInformation
     */
    select?: BirthInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BirthInformation
     */
    omit?: BirthInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BirthInformationInclude<ExtArgs> | null
  }


  /**
   * Model ImmunizationEvent
   */

  export type AggregateImmunizationEvent = {
    _count: ImmunizationEventCountAggregateOutputType | null
    _avg: ImmunizationEventAvgAggregateOutputType | null
    _sum: ImmunizationEventSumAggregateOutputType | null
    _min: ImmunizationEventMinAggregateOutputType | null
    _max: ImmunizationEventMaxAggregateOutputType | null
  }

  export type ImmunizationEventAvgAggregateOutputType = {
    temperatureCelsius: number | null
    weightKg: number | null
    heightCm: number | null
  }

  export type ImmunizationEventSumAggregateOutputType = {
    temperatureCelsius: number | null
    weightKg: number | null
    heightCm: number | null
  }

  export type ImmunizationEventMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    visitDate: Date | null
    temperatureCelsius: number | null
    weightKg: number | null
    heightCm: number | null
    adverseReactions: string | null
    healthWorkerName: string | null
    healthWorkerSignature: string | null
    nextFollowupDate: Date | null
    recordedBy: string | null
  }

  export type ImmunizationEventMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    visitDate: Date | null
    temperatureCelsius: number | null
    weightKg: number | null
    heightCm: number | null
    adverseReactions: string | null
    healthWorkerName: string | null
    healthWorkerSignature: string | null
    nextFollowupDate: Date | null
    recordedBy: string | null
  }

  export type ImmunizationEventCountAggregateOutputType = {
    id: number
    userProfileId: number
    visitDate: number
    temperatureCelsius: number
    weightKg: number
    heightCm: number
    adverseReactions: number
    healthWorkerName: number
    healthWorkerSignature: number
    nextFollowupDate: number
    recordedBy: number
    _all: number
  }


  export type ImmunizationEventAvgAggregateInputType = {
    temperatureCelsius?: true
    weightKg?: true
    heightCm?: true
  }

  export type ImmunizationEventSumAggregateInputType = {
    temperatureCelsius?: true
    weightKg?: true
    heightCm?: true
  }

  export type ImmunizationEventMinAggregateInputType = {
    id?: true
    userProfileId?: true
    visitDate?: true
    temperatureCelsius?: true
    weightKg?: true
    heightCm?: true
    adverseReactions?: true
    healthWorkerName?: true
    healthWorkerSignature?: true
    nextFollowupDate?: true
    recordedBy?: true
  }

  export type ImmunizationEventMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    visitDate?: true
    temperatureCelsius?: true
    weightKg?: true
    heightCm?: true
    adverseReactions?: true
    healthWorkerName?: true
    healthWorkerSignature?: true
    nextFollowupDate?: true
    recordedBy?: true
  }

  export type ImmunizationEventCountAggregateInputType = {
    id?: true
    userProfileId?: true
    visitDate?: true
    temperatureCelsius?: true
    weightKg?: true
    heightCm?: true
    adverseReactions?: true
    healthWorkerName?: true
    healthWorkerSignature?: true
    nextFollowupDate?: true
    recordedBy?: true
    _all?: true
  }

  export type ImmunizationEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmunizationEvent to aggregate.
     */
    where?: ImmunizationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationEvents to fetch.
     */
    orderBy?: ImmunizationEventOrderByWithRelationInput | ImmunizationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImmunizationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImmunizationEvents
    **/
    _count?: true | ImmunizationEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImmunizationEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImmunizationEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImmunizationEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImmunizationEventMaxAggregateInputType
  }

  export type GetImmunizationEventAggregateType<T extends ImmunizationEventAggregateArgs> = {
        [P in keyof T & keyof AggregateImmunizationEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImmunizationEvent[P]>
      : GetScalarType<T[P], AggregateImmunizationEvent[P]>
  }




  export type ImmunizationEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmunizationEventWhereInput
    orderBy?: ImmunizationEventOrderByWithAggregationInput | ImmunizationEventOrderByWithAggregationInput[]
    by: ImmunizationEventScalarFieldEnum[] | ImmunizationEventScalarFieldEnum
    having?: ImmunizationEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImmunizationEventCountAggregateInputType | true
    _avg?: ImmunizationEventAvgAggregateInputType
    _sum?: ImmunizationEventSumAggregateInputType
    _min?: ImmunizationEventMinAggregateInputType
    _max?: ImmunizationEventMaxAggregateInputType
  }

  export type ImmunizationEventGroupByOutputType = {
    id: string
    userProfileId: string
    visitDate: Date
    temperatureCelsius: number | null
    weightKg: number | null
    heightCm: number | null
    adverseReactions: string | null
    healthWorkerName: string
    healthWorkerSignature: string | null
    nextFollowupDate: Date | null
    recordedBy: string
    _count: ImmunizationEventCountAggregateOutputType | null
    _avg: ImmunizationEventAvgAggregateOutputType | null
    _sum: ImmunizationEventSumAggregateOutputType | null
    _min: ImmunizationEventMinAggregateOutputType | null
    _max: ImmunizationEventMaxAggregateOutputType | null
  }

  type GetImmunizationEventGroupByPayload<T extends ImmunizationEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImmunizationEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImmunizationEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImmunizationEventGroupByOutputType[P]>
            : GetScalarType<T[P], ImmunizationEventGroupByOutputType[P]>
        }
      >
    >


  export type ImmunizationEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    visitDate?: boolean
    temperatureCelsius?: boolean
    weightKg?: boolean
    heightCm?: boolean
    adverseReactions?: boolean
    healthWorkerName?: boolean
    healthWorkerSignature?: boolean
    nextFollowupDate?: boolean
    recordedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    vaccinesGiven?: boolean | ImmunizationEvent$vaccinesGivenArgs<ExtArgs>
    _count?: boolean | ImmunizationEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immunizationEvent"]>



  export type ImmunizationEventSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    visitDate?: boolean
    temperatureCelsius?: boolean
    weightKg?: boolean
    heightCm?: boolean
    adverseReactions?: boolean
    healthWorkerName?: boolean
    healthWorkerSignature?: boolean
    nextFollowupDate?: boolean
    recordedBy?: boolean
  }

  export type ImmunizationEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "visitDate" | "temperatureCelsius" | "weightKg" | "heightCm" | "adverseReactions" | "healthWorkerName" | "healthWorkerSignature" | "nextFollowupDate" | "recordedBy", ExtArgs["result"]["immunizationEvent"]>
  export type ImmunizationEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    vaccinesGiven?: boolean | ImmunizationEvent$vaccinesGivenArgs<ExtArgs>
    _count?: boolean | ImmunizationEventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ImmunizationEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImmunizationEvent"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
      vaccinesGiven: Prisma.$VaccineGivenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      visitDate: Date
      temperatureCelsius: number | null
      weightKg: number | null
      heightCm: number | null
      adverseReactions: string | null
      healthWorkerName: string
      healthWorkerSignature: string | null
      nextFollowupDate: Date | null
      recordedBy: string
    }, ExtArgs["result"]["immunizationEvent"]>
    composites: {}
  }

  type ImmunizationEventGetPayload<S extends boolean | null | undefined | ImmunizationEventDefaultArgs> = $Result.GetResult<Prisma.$ImmunizationEventPayload, S>

  type ImmunizationEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImmunizationEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImmunizationEventCountAggregateInputType | true
    }

  export interface ImmunizationEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImmunizationEvent'], meta: { name: 'ImmunizationEvent' } }
    /**
     * Find zero or one ImmunizationEvent that matches the filter.
     * @param {ImmunizationEventFindUniqueArgs} args - Arguments to find a ImmunizationEvent
     * @example
     * // Get one ImmunizationEvent
     * const immunizationEvent = await prisma.immunizationEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImmunizationEventFindUniqueArgs>(args: SelectSubset<T, ImmunizationEventFindUniqueArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImmunizationEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImmunizationEventFindUniqueOrThrowArgs} args - Arguments to find a ImmunizationEvent
     * @example
     * // Get one ImmunizationEvent
     * const immunizationEvent = await prisma.immunizationEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImmunizationEventFindUniqueOrThrowArgs>(args: SelectSubset<T, ImmunizationEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmunizationEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationEventFindFirstArgs} args - Arguments to find a ImmunizationEvent
     * @example
     * // Get one ImmunizationEvent
     * const immunizationEvent = await prisma.immunizationEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImmunizationEventFindFirstArgs>(args?: SelectSubset<T, ImmunizationEventFindFirstArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmunizationEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationEventFindFirstOrThrowArgs} args - Arguments to find a ImmunizationEvent
     * @example
     * // Get one ImmunizationEvent
     * const immunizationEvent = await prisma.immunizationEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImmunizationEventFindFirstOrThrowArgs>(args?: SelectSubset<T, ImmunizationEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImmunizationEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImmunizationEvents
     * const immunizationEvents = await prisma.immunizationEvent.findMany()
     * 
     * // Get first 10 ImmunizationEvents
     * const immunizationEvents = await prisma.immunizationEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const immunizationEventWithIdOnly = await prisma.immunizationEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImmunizationEventFindManyArgs>(args?: SelectSubset<T, ImmunizationEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImmunizationEvent.
     * @param {ImmunizationEventCreateArgs} args - Arguments to create a ImmunizationEvent.
     * @example
     * // Create one ImmunizationEvent
     * const ImmunizationEvent = await prisma.immunizationEvent.create({
     *   data: {
     *     // ... data to create a ImmunizationEvent
     *   }
     * })
     * 
     */
    create<T extends ImmunizationEventCreateArgs>(args: SelectSubset<T, ImmunizationEventCreateArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImmunizationEvents.
     * @param {ImmunizationEventCreateManyArgs} args - Arguments to create many ImmunizationEvents.
     * @example
     * // Create many ImmunizationEvents
     * const immunizationEvent = await prisma.immunizationEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImmunizationEventCreateManyArgs>(args?: SelectSubset<T, ImmunizationEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImmunizationEvent.
     * @param {ImmunizationEventDeleteArgs} args - Arguments to delete one ImmunizationEvent.
     * @example
     * // Delete one ImmunizationEvent
     * const ImmunizationEvent = await prisma.immunizationEvent.delete({
     *   where: {
     *     // ... filter to delete one ImmunizationEvent
     *   }
     * })
     * 
     */
    delete<T extends ImmunizationEventDeleteArgs>(args: SelectSubset<T, ImmunizationEventDeleteArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImmunizationEvent.
     * @param {ImmunizationEventUpdateArgs} args - Arguments to update one ImmunizationEvent.
     * @example
     * // Update one ImmunizationEvent
     * const immunizationEvent = await prisma.immunizationEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImmunizationEventUpdateArgs>(args: SelectSubset<T, ImmunizationEventUpdateArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImmunizationEvents.
     * @param {ImmunizationEventDeleteManyArgs} args - Arguments to filter ImmunizationEvents to delete.
     * @example
     * // Delete a few ImmunizationEvents
     * const { count } = await prisma.immunizationEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImmunizationEventDeleteManyArgs>(args?: SelectSubset<T, ImmunizationEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImmunizationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImmunizationEvents
     * const immunizationEvent = await prisma.immunizationEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImmunizationEventUpdateManyArgs>(args: SelectSubset<T, ImmunizationEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImmunizationEvent.
     * @param {ImmunizationEventUpsertArgs} args - Arguments to update or create a ImmunizationEvent.
     * @example
     * // Update or create a ImmunizationEvent
     * const immunizationEvent = await prisma.immunizationEvent.upsert({
     *   create: {
     *     // ... data to create a ImmunizationEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImmunizationEvent we want to update
     *   }
     * })
     */
    upsert<T extends ImmunizationEventUpsertArgs>(args: SelectSubset<T, ImmunizationEventUpsertArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImmunizationEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationEventCountArgs} args - Arguments to filter ImmunizationEvents to count.
     * @example
     * // Count the number of ImmunizationEvents
     * const count = await prisma.immunizationEvent.count({
     *   where: {
     *     // ... the filter for the ImmunizationEvents we want to count
     *   }
     * })
    **/
    count<T extends ImmunizationEventCountArgs>(
      args?: Subset<T, ImmunizationEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImmunizationEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImmunizationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImmunizationEventAggregateArgs>(args: Subset<T, ImmunizationEventAggregateArgs>): Prisma.PrismaPromise<GetImmunizationEventAggregateType<T>>

    /**
     * Group by ImmunizationEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImmunizationEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImmunizationEventGroupByArgs['orderBy'] }
        : { orderBy?: ImmunizationEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImmunizationEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImmunizationEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImmunizationEvent model
   */
  readonly fields: ImmunizationEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImmunizationEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImmunizationEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vaccinesGiven<T extends ImmunizationEvent$vaccinesGivenArgs<ExtArgs> = {}>(args?: Subset<T, ImmunizationEvent$vaccinesGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImmunizationEvent model
   */
  interface ImmunizationEventFieldRefs {
    readonly id: FieldRef<"ImmunizationEvent", 'String'>
    readonly userProfileId: FieldRef<"ImmunizationEvent", 'String'>
    readonly visitDate: FieldRef<"ImmunizationEvent", 'DateTime'>
    readonly temperatureCelsius: FieldRef<"ImmunizationEvent", 'Float'>
    readonly weightKg: FieldRef<"ImmunizationEvent", 'Float'>
    readonly heightCm: FieldRef<"ImmunizationEvent", 'Float'>
    readonly adverseReactions: FieldRef<"ImmunizationEvent", 'String'>
    readonly healthWorkerName: FieldRef<"ImmunizationEvent", 'String'>
    readonly healthWorkerSignature: FieldRef<"ImmunizationEvent", 'String'>
    readonly nextFollowupDate: FieldRef<"ImmunizationEvent", 'DateTime'>
    readonly recordedBy: FieldRef<"ImmunizationEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImmunizationEvent findUnique
   */
  export type ImmunizationEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationEvent to fetch.
     */
    where: ImmunizationEventWhereUniqueInput
  }

  /**
   * ImmunizationEvent findUniqueOrThrow
   */
  export type ImmunizationEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationEvent to fetch.
     */
    where: ImmunizationEventWhereUniqueInput
  }

  /**
   * ImmunizationEvent findFirst
   */
  export type ImmunizationEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationEvent to fetch.
     */
    where?: ImmunizationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationEvents to fetch.
     */
    orderBy?: ImmunizationEventOrderByWithRelationInput | ImmunizationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmunizationEvents.
     */
    cursor?: ImmunizationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmunizationEvents.
     */
    distinct?: ImmunizationEventScalarFieldEnum | ImmunizationEventScalarFieldEnum[]
  }

  /**
   * ImmunizationEvent findFirstOrThrow
   */
  export type ImmunizationEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationEvent to fetch.
     */
    where?: ImmunizationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationEvents to fetch.
     */
    orderBy?: ImmunizationEventOrderByWithRelationInput | ImmunizationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmunizationEvents.
     */
    cursor?: ImmunizationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmunizationEvents.
     */
    distinct?: ImmunizationEventScalarFieldEnum | ImmunizationEventScalarFieldEnum[]
  }

  /**
   * ImmunizationEvent findMany
   */
  export type ImmunizationEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationEvents to fetch.
     */
    where?: ImmunizationEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationEvents to fetch.
     */
    orderBy?: ImmunizationEventOrderByWithRelationInput | ImmunizationEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImmunizationEvents.
     */
    cursor?: ImmunizationEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationEvents.
     */
    skip?: number
    distinct?: ImmunizationEventScalarFieldEnum | ImmunizationEventScalarFieldEnum[]
  }

  /**
   * ImmunizationEvent create
   */
  export type ImmunizationEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * The data needed to create a ImmunizationEvent.
     */
    data: XOR<ImmunizationEventCreateInput, ImmunizationEventUncheckedCreateInput>
  }

  /**
   * ImmunizationEvent createMany
   */
  export type ImmunizationEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImmunizationEvents.
     */
    data: ImmunizationEventCreateManyInput | ImmunizationEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImmunizationEvent update
   */
  export type ImmunizationEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * The data needed to update a ImmunizationEvent.
     */
    data: XOR<ImmunizationEventUpdateInput, ImmunizationEventUncheckedUpdateInput>
    /**
     * Choose, which ImmunizationEvent to update.
     */
    where: ImmunizationEventWhereUniqueInput
  }

  /**
   * ImmunizationEvent updateMany
   */
  export type ImmunizationEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImmunizationEvents.
     */
    data: XOR<ImmunizationEventUpdateManyMutationInput, ImmunizationEventUncheckedUpdateManyInput>
    /**
     * Filter which ImmunizationEvents to update
     */
    where?: ImmunizationEventWhereInput
    /**
     * Limit how many ImmunizationEvents to update.
     */
    limit?: number
  }

  /**
   * ImmunizationEvent upsert
   */
  export type ImmunizationEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * The filter to search for the ImmunizationEvent to update in case it exists.
     */
    where: ImmunizationEventWhereUniqueInput
    /**
     * In case the ImmunizationEvent found by the `where` argument doesn't exist, create a new ImmunizationEvent with this data.
     */
    create: XOR<ImmunizationEventCreateInput, ImmunizationEventUncheckedCreateInput>
    /**
     * In case the ImmunizationEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImmunizationEventUpdateInput, ImmunizationEventUncheckedUpdateInput>
  }

  /**
   * ImmunizationEvent delete
   */
  export type ImmunizationEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
    /**
     * Filter which ImmunizationEvent to delete.
     */
    where: ImmunizationEventWhereUniqueInput
  }

  /**
   * ImmunizationEvent deleteMany
   */
  export type ImmunizationEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmunizationEvents to delete
     */
    where?: ImmunizationEventWhereInput
    /**
     * Limit how many ImmunizationEvents to delete.
     */
    limit?: number
  }

  /**
   * ImmunizationEvent.vaccinesGiven
   */
  export type ImmunizationEvent$vaccinesGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    where?: VaccineGivenWhereInput
    orderBy?: VaccineGivenOrderByWithRelationInput | VaccineGivenOrderByWithRelationInput[]
    cursor?: VaccineGivenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccineGivenScalarFieldEnum | VaccineGivenScalarFieldEnum[]
  }

  /**
   * ImmunizationEvent without action
   */
  export type ImmunizationEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationEvent
     */
    select?: ImmunizationEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationEvent
     */
    omit?: ImmunizationEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationEventInclude<ExtArgs> | null
  }


  /**
   * Model VaccineGiven
   */

  export type AggregateVaccineGiven = {
    _count: VaccineGivenCountAggregateOutputType | null
    _min: VaccineGivenMinAggregateOutputType | null
    _max: VaccineGivenMaxAggregateOutputType | null
  }

  export type VaccineGivenMinAggregateOutputType = {
    id: string | null
    immunizationEventId: string | null
    vaccineName: string | null
    doseNumber: string | null
    dateGiven: Date | null
    lotNumber: string | null
  }

  export type VaccineGivenMaxAggregateOutputType = {
    id: string | null
    immunizationEventId: string | null
    vaccineName: string | null
    doseNumber: string | null
    dateGiven: Date | null
    lotNumber: string | null
  }

  export type VaccineGivenCountAggregateOutputType = {
    id: number
    immunizationEventId: number
    vaccineName: number
    doseNumber: number
    dateGiven: number
    lotNumber: number
    _all: number
  }


  export type VaccineGivenMinAggregateInputType = {
    id?: true
    immunizationEventId?: true
    vaccineName?: true
    doseNumber?: true
    dateGiven?: true
    lotNumber?: true
  }

  export type VaccineGivenMaxAggregateInputType = {
    id?: true
    immunizationEventId?: true
    vaccineName?: true
    doseNumber?: true
    dateGiven?: true
    lotNumber?: true
  }

  export type VaccineGivenCountAggregateInputType = {
    id?: true
    immunizationEventId?: true
    vaccineName?: true
    doseNumber?: true
    dateGiven?: true
    lotNumber?: true
    _all?: true
  }

  export type VaccineGivenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccineGiven to aggregate.
     */
    where?: VaccineGivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineGivens to fetch.
     */
    orderBy?: VaccineGivenOrderByWithRelationInput | VaccineGivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccineGivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineGivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineGivens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccineGivens
    **/
    _count?: true | VaccineGivenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccineGivenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccineGivenMaxAggregateInputType
  }

  export type GetVaccineGivenAggregateType<T extends VaccineGivenAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccineGiven]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccineGiven[P]>
      : GetScalarType<T[P], AggregateVaccineGiven[P]>
  }




  export type VaccineGivenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccineGivenWhereInput
    orderBy?: VaccineGivenOrderByWithAggregationInput | VaccineGivenOrderByWithAggregationInput[]
    by: VaccineGivenScalarFieldEnum[] | VaccineGivenScalarFieldEnum
    having?: VaccineGivenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccineGivenCountAggregateInputType | true
    _min?: VaccineGivenMinAggregateInputType
    _max?: VaccineGivenMaxAggregateInputType
  }

  export type VaccineGivenGroupByOutputType = {
    id: string
    immunizationEventId: string
    vaccineName: string
    doseNumber: string
    dateGiven: Date
    lotNumber: string | null
    _count: VaccineGivenCountAggregateOutputType | null
    _min: VaccineGivenMinAggregateOutputType | null
    _max: VaccineGivenMaxAggregateOutputType | null
  }

  type GetVaccineGivenGroupByPayload<T extends VaccineGivenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccineGivenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccineGivenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccineGivenGroupByOutputType[P]>
            : GetScalarType<T[P], VaccineGivenGroupByOutputType[P]>
        }
      >
    >


  export type VaccineGivenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    immunizationEventId?: boolean
    vaccineName?: boolean
    doseNumber?: boolean
    dateGiven?: boolean
    lotNumber?: boolean
    immunizationEvent?: boolean | ImmunizationEventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccineGiven"]>



  export type VaccineGivenSelectScalar = {
    id?: boolean
    immunizationEventId?: boolean
    vaccineName?: boolean
    doseNumber?: boolean
    dateGiven?: boolean
    lotNumber?: boolean
  }

  export type VaccineGivenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "immunizationEventId" | "vaccineName" | "doseNumber" | "dateGiven" | "lotNumber", ExtArgs["result"]["vaccineGiven"]>
  export type VaccineGivenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    immunizationEvent?: boolean | ImmunizationEventDefaultArgs<ExtArgs>
  }

  export type $VaccineGivenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VaccineGiven"
    objects: {
      immunizationEvent: Prisma.$ImmunizationEventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      immunizationEventId: string
      vaccineName: string
      doseNumber: string
      dateGiven: Date
      lotNumber: string | null
    }, ExtArgs["result"]["vaccineGiven"]>
    composites: {}
  }

  type VaccineGivenGetPayload<S extends boolean | null | undefined | VaccineGivenDefaultArgs> = $Result.GetResult<Prisma.$VaccineGivenPayload, S>

  type VaccineGivenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccineGivenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccineGivenCountAggregateInputType | true
    }

  export interface VaccineGivenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VaccineGiven'], meta: { name: 'VaccineGiven' } }
    /**
     * Find zero or one VaccineGiven that matches the filter.
     * @param {VaccineGivenFindUniqueArgs} args - Arguments to find a VaccineGiven
     * @example
     * // Get one VaccineGiven
     * const vaccineGiven = await prisma.vaccineGiven.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccineGivenFindUniqueArgs>(args: SelectSubset<T, VaccineGivenFindUniqueArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VaccineGiven that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccineGivenFindUniqueOrThrowArgs} args - Arguments to find a VaccineGiven
     * @example
     * // Get one VaccineGiven
     * const vaccineGiven = await prisma.vaccineGiven.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccineGivenFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccineGivenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccineGiven that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGivenFindFirstArgs} args - Arguments to find a VaccineGiven
     * @example
     * // Get one VaccineGiven
     * const vaccineGiven = await prisma.vaccineGiven.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccineGivenFindFirstArgs>(args?: SelectSubset<T, VaccineGivenFindFirstArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccineGiven that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGivenFindFirstOrThrowArgs} args - Arguments to find a VaccineGiven
     * @example
     * // Get one VaccineGiven
     * const vaccineGiven = await prisma.vaccineGiven.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccineGivenFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccineGivenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VaccineGivens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGivenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccineGivens
     * const vaccineGivens = await prisma.vaccineGiven.findMany()
     * 
     * // Get first 10 VaccineGivens
     * const vaccineGivens = await prisma.vaccineGiven.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccineGivenWithIdOnly = await prisma.vaccineGiven.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccineGivenFindManyArgs>(args?: SelectSubset<T, VaccineGivenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VaccineGiven.
     * @param {VaccineGivenCreateArgs} args - Arguments to create a VaccineGiven.
     * @example
     * // Create one VaccineGiven
     * const VaccineGiven = await prisma.vaccineGiven.create({
     *   data: {
     *     // ... data to create a VaccineGiven
     *   }
     * })
     * 
     */
    create<T extends VaccineGivenCreateArgs>(args: SelectSubset<T, VaccineGivenCreateArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VaccineGivens.
     * @param {VaccineGivenCreateManyArgs} args - Arguments to create many VaccineGivens.
     * @example
     * // Create many VaccineGivens
     * const vaccineGiven = await prisma.vaccineGiven.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccineGivenCreateManyArgs>(args?: SelectSubset<T, VaccineGivenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VaccineGiven.
     * @param {VaccineGivenDeleteArgs} args - Arguments to delete one VaccineGiven.
     * @example
     * // Delete one VaccineGiven
     * const VaccineGiven = await prisma.vaccineGiven.delete({
     *   where: {
     *     // ... filter to delete one VaccineGiven
     *   }
     * })
     * 
     */
    delete<T extends VaccineGivenDeleteArgs>(args: SelectSubset<T, VaccineGivenDeleteArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VaccineGiven.
     * @param {VaccineGivenUpdateArgs} args - Arguments to update one VaccineGiven.
     * @example
     * // Update one VaccineGiven
     * const vaccineGiven = await prisma.vaccineGiven.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccineGivenUpdateArgs>(args: SelectSubset<T, VaccineGivenUpdateArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VaccineGivens.
     * @param {VaccineGivenDeleteManyArgs} args - Arguments to filter VaccineGivens to delete.
     * @example
     * // Delete a few VaccineGivens
     * const { count } = await prisma.vaccineGiven.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccineGivenDeleteManyArgs>(args?: SelectSubset<T, VaccineGivenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccineGivens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGivenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccineGivens
     * const vaccineGiven = await prisma.vaccineGiven.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccineGivenUpdateManyArgs>(args: SelectSubset<T, VaccineGivenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VaccineGiven.
     * @param {VaccineGivenUpsertArgs} args - Arguments to update or create a VaccineGiven.
     * @example
     * // Update or create a VaccineGiven
     * const vaccineGiven = await prisma.vaccineGiven.upsert({
     *   create: {
     *     // ... data to create a VaccineGiven
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccineGiven we want to update
     *   }
     * })
     */
    upsert<T extends VaccineGivenUpsertArgs>(args: SelectSubset<T, VaccineGivenUpsertArgs<ExtArgs>>): Prisma__VaccineGivenClient<$Result.GetResult<Prisma.$VaccineGivenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VaccineGivens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGivenCountArgs} args - Arguments to filter VaccineGivens to count.
     * @example
     * // Count the number of VaccineGivens
     * const count = await prisma.vaccineGiven.count({
     *   where: {
     *     // ... the filter for the VaccineGivens we want to count
     *   }
     * })
    **/
    count<T extends VaccineGivenCountArgs>(
      args?: Subset<T, VaccineGivenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccineGivenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccineGiven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGivenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccineGivenAggregateArgs>(args: Subset<T, VaccineGivenAggregateArgs>): Prisma.PrismaPromise<GetVaccineGivenAggregateType<T>>

    /**
     * Group by VaccineGiven.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccineGivenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccineGivenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccineGivenGroupByArgs['orderBy'] }
        : { orderBy?: VaccineGivenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccineGivenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccineGivenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VaccineGiven model
   */
  readonly fields: VaccineGivenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccineGiven.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccineGivenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    immunizationEvent<T extends ImmunizationEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImmunizationEventDefaultArgs<ExtArgs>>): Prisma__ImmunizationEventClient<$Result.GetResult<Prisma.$ImmunizationEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VaccineGiven model
   */
  interface VaccineGivenFieldRefs {
    readonly id: FieldRef<"VaccineGiven", 'String'>
    readonly immunizationEventId: FieldRef<"VaccineGiven", 'String'>
    readonly vaccineName: FieldRef<"VaccineGiven", 'String'>
    readonly doseNumber: FieldRef<"VaccineGiven", 'String'>
    readonly dateGiven: FieldRef<"VaccineGiven", 'DateTime'>
    readonly lotNumber: FieldRef<"VaccineGiven", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VaccineGiven findUnique
   */
  export type VaccineGivenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * Filter, which VaccineGiven to fetch.
     */
    where: VaccineGivenWhereUniqueInput
  }

  /**
   * VaccineGiven findUniqueOrThrow
   */
  export type VaccineGivenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * Filter, which VaccineGiven to fetch.
     */
    where: VaccineGivenWhereUniqueInput
  }

  /**
   * VaccineGiven findFirst
   */
  export type VaccineGivenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * Filter, which VaccineGiven to fetch.
     */
    where?: VaccineGivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineGivens to fetch.
     */
    orderBy?: VaccineGivenOrderByWithRelationInput | VaccineGivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccineGivens.
     */
    cursor?: VaccineGivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineGivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineGivens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccineGivens.
     */
    distinct?: VaccineGivenScalarFieldEnum | VaccineGivenScalarFieldEnum[]
  }

  /**
   * VaccineGiven findFirstOrThrow
   */
  export type VaccineGivenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * Filter, which VaccineGiven to fetch.
     */
    where?: VaccineGivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineGivens to fetch.
     */
    orderBy?: VaccineGivenOrderByWithRelationInput | VaccineGivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccineGivens.
     */
    cursor?: VaccineGivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineGivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineGivens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccineGivens.
     */
    distinct?: VaccineGivenScalarFieldEnum | VaccineGivenScalarFieldEnum[]
  }

  /**
   * VaccineGiven findMany
   */
  export type VaccineGivenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * Filter, which VaccineGivens to fetch.
     */
    where?: VaccineGivenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccineGivens to fetch.
     */
    orderBy?: VaccineGivenOrderByWithRelationInput | VaccineGivenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccineGivens.
     */
    cursor?: VaccineGivenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccineGivens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccineGivens.
     */
    skip?: number
    distinct?: VaccineGivenScalarFieldEnum | VaccineGivenScalarFieldEnum[]
  }

  /**
   * VaccineGiven create
   */
  export type VaccineGivenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * The data needed to create a VaccineGiven.
     */
    data: XOR<VaccineGivenCreateInput, VaccineGivenUncheckedCreateInput>
  }

  /**
   * VaccineGiven createMany
   */
  export type VaccineGivenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VaccineGivens.
     */
    data: VaccineGivenCreateManyInput | VaccineGivenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VaccineGiven update
   */
  export type VaccineGivenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * The data needed to update a VaccineGiven.
     */
    data: XOR<VaccineGivenUpdateInput, VaccineGivenUncheckedUpdateInput>
    /**
     * Choose, which VaccineGiven to update.
     */
    where: VaccineGivenWhereUniqueInput
  }

  /**
   * VaccineGiven updateMany
   */
  export type VaccineGivenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VaccineGivens.
     */
    data: XOR<VaccineGivenUpdateManyMutationInput, VaccineGivenUncheckedUpdateManyInput>
    /**
     * Filter which VaccineGivens to update
     */
    where?: VaccineGivenWhereInput
    /**
     * Limit how many VaccineGivens to update.
     */
    limit?: number
  }

  /**
   * VaccineGiven upsert
   */
  export type VaccineGivenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * The filter to search for the VaccineGiven to update in case it exists.
     */
    where: VaccineGivenWhereUniqueInput
    /**
     * In case the VaccineGiven found by the `where` argument doesn't exist, create a new VaccineGiven with this data.
     */
    create: XOR<VaccineGivenCreateInput, VaccineGivenUncheckedCreateInput>
    /**
     * In case the VaccineGiven was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccineGivenUpdateInput, VaccineGivenUncheckedUpdateInput>
  }

  /**
   * VaccineGiven delete
   */
  export type VaccineGivenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
    /**
     * Filter which VaccineGiven to delete.
     */
    where: VaccineGivenWhereUniqueInput
  }

  /**
   * VaccineGiven deleteMany
   */
  export type VaccineGivenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccineGivens to delete
     */
    where?: VaccineGivenWhereInput
    /**
     * Limit how many VaccineGivens to delete.
     */
    limit?: number
  }

  /**
   * VaccineGiven without action
   */
  export type VaccineGivenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccineGiven
     */
    select?: VaccineGivenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccineGiven
     */
    omit?: VaccineGivenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccineGivenInclude<ExtArgs> | null
  }


  /**
   * Model VitalSigns
   */

  export type AggregateVitalSigns = {
    _count: VitalSignsCountAggregateOutputType | null
    _avg: VitalSignsAvgAggregateOutputType | null
    _sum: VitalSignsSumAggregateOutputType | null
    _min: VitalSignsMinAggregateOutputType | null
    _max: VitalSignsMaxAggregateOutputType | null
  }

  export type VitalSignsAvgAggregateOutputType = {
    heartRate: number | null
    respiratoryRate: number | null
    temperatureCelsius: number | null
    pulseRate: number | null
  }

  export type VitalSignsSumAggregateOutputType = {
    heartRate: number | null
    respiratoryRate: number | null
    temperatureCelsius: number | null
    pulseRate: number | null
  }

  export type VitalSignsMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    recordDate: Date | null
    bloodPressure: string | null
    heartRate: number | null
    respiratoryRate: number | null
    temperatureCelsius: number | null
    pulseRate: number | null
    recordedBy: string | null
  }

  export type VitalSignsMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    recordDate: Date | null
    bloodPressure: string | null
    heartRate: number | null
    respiratoryRate: number | null
    temperatureCelsius: number | null
    pulseRate: number | null
    recordedBy: string | null
  }

  export type VitalSignsCountAggregateOutputType = {
    id: number
    userProfileId: number
    recordDate: number
    bloodPressure: number
    heartRate: number
    respiratoryRate: number
    temperatureCelsius: number
    pulseRate: number
    recordedBy: number
    _all: number
  }


  export type VitalSignsAvgAggregateInputType = {
    heartRate?: true
    respiratoryRate?: true
    temperatureCelsius?: true
    pulseRate?: true
  }

  export type VitalSignsSumAggregateInputType = {
    heartRate?: true
    respiratoryRate?: true
    temperatureCelsius?: true
    pulseRate?: true
  }

  export type VitalSignsMinAggregateInputType = {
    id?: true
    userProfileId?: true
    recordDate?: true
    bloodPressure?: true
    heartRate?: true
    respiratoryRate?: true
    temperatureCelsius?: true
    pulseRate?: true
    recordedBy?: true
  }

  export type VitalSignsMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    recordDate?: true
    bloodPressure?: true
    heartRate?: true
    respiratoryRate?: true
    temperatureCelsius?: true
    pulseRate?: true
    recordedBy?: true
  }

  export type VitalSignsCountAggregateInputType = {
    id?: true
    userProfileId?: true
    recordDate?: true
    bloodPressure?: true
    heartRate?: true
    respiratoryRate?: true
    temperatureCelsius?: true
    pulseRate?: true
    recordedBy?: true
    _all?: true
  }

  export type VitalSignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to aggregate.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitalSigns
    **/
    _count?: true | VitalSignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitalSignsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitalSignsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitalSignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitalSignsMaxAggregateInputType
  }

  export type GetVitalSignsAggregateType<T extends VitalSignsAggregateArgs> = {
        [P in keyof T & keyof AggregateVitalSigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitalSigns[P]>
      : GetScalarType<T[P], AggregateVitalSigns[P]>
  }




  export type VitalSignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VitalSignsWhereInput
    orderBy?: VitalSignsOrderByWithAggregationInput | VitalSignsOrderByWithAggregationInput[]
    by: VitalSignsScalarFieldEnum[] | VitalSignsScalarFieldEnum
    having?: VitalSignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitalSignsCountAggregateInputType | true
    _avg?: VitalSignsAvgAggregateInputType
    _sum?: VitalSignsSumAggregateInputType
    _min?: VitalSignsMinAggregateInputType
    _max?: VitalSignsMaxAggregateInputType
  }

  export type VitalSignsGroupByOutputType = {
    id: string
    userProfileId: string
    recordDate: Date
    bloodPressure: string | null
    heartRate: number | null
    respiratoryRate: number | null
    temperatureCelsius: number | null
    pulseRate: number | null
    recordedBy: string
    _count: VitalSignsCountAggregateOutputType | null
    _avg: VitalSignsAvgAggregateOutputType | null
    _sum: VitalSignsSumAggregateOutputType | null
    _min: VitalSignsMinAggregateOutputType | null
    _max: VitalSignsMaxAggregateOutputType | null
  }

  type GetVitalSignsGroupByPayload<T extends VitalSignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VitalSignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitalSignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitalSignsGroupByOutputType[P]>
            : GetScalarType<T[P], VitalSignsGroupByOutputType[P]>
        }
      >
    >


  export type VitalSignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    recordDate?: boolean
    bloodPressure?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    temperatureCelsius?: boolean
    pulseRate?: boolean
    recordedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vitalSigns"]>



  export type VitalSignsSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    recordDate?: boolean
    bloodPressure?: boolean
    heartRate?: boolean
    respiratoryRate?: boolean
    temperatureCelsius?: boolean
    pulseRate?: boolean
    recordedBy?: boolean
  }

  export type VitalSignsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "recordDate" | "bloodPressure" | "heartRate" | "respiratoryRate" | "temperatureCelsius" | "pulseRate" | "recordedBy", ExtArgs["result"]["vitalSigns"]>
  export type VitalSignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $VitalSignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VitalSigns"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      recordDate: Date
      bloodPressure: string | null
      heartRate: number | null
      respiratoryRate: number | null
      temperatureCelsius: number | null
      pulseRate: number | null
      recordedBy: string
    }, ExtArgs["result"]["vitalSigns"]>
    composites: {}
  }

  type VitalSignsGetPayload<S extends boolean | null | undefined | VitalSignsDefaultArgs> = $Result.GetResult<Prisma.$VitalSignsPayload, S>

  type VitalSignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VitalSignsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VitalSignsCountAggregateInputType | true
    }

  export interface VitalSignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VitalSigns'], meta: { name: 'VitalSigns' } }
    /**
     * Find zero or one VitalSigns that matches the filter.
     * @param {VitalSignsFindUniqueArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VitalSignsFindUniqueArgs>(args: SelectSubset<T, VitalSignsFindUniqueArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VitalSigns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VitalSignsFindUniqueOrThrowArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VitalSignsFindUniqueOrThrowArgs>(args: SelectSubset<T, VitalSignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindFirstArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VitalSignsFindFirstArgs>(args?: SelectSubset<T, VitalSignsFindFirstArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VitalSigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindFirstOrThrowArgs} args - Arguments to find a VitalSigns
     * @example
     * // Get one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VitalSignsFindFirstOrThrowArgs>(args?: SelectSubset<T, VitalSignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VitalSigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findMany()
     * 
     * // Get first 10 VitalSigns
     * const vitalSigns = await prisma.vitalSigns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitalSignsWithIdOnly = await prisma.vitalSigns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VitalSignsFindManyArgs>(args?: SelectSubset<T, VitalSignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VitalSigns.
     * @param {VitalSignsCreateArgs} args - Arguments to create a VitalSigns.
     * @example
     * // Create one VitalSigns
     * const VitalSigns = await prisma.vitalSigns.create({
     *   data: {
     *     // ... data to create a VitalSigns
     *   }
     * })
     * 
     */
    create<T extends VitalSignsCreateArgs>(args: SelectSubset<T, VitalSignsCreateArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VitalSigns.
     * @param {VitalSignsCreateManyArgs} args - Arguments to create many VitalSigns.
     * @example
     * // Create many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VitalSignsCreateManyArgs>(args?: SelectSubset<T, VitalSignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VitalSigns.
     * @param {VitalSignsDeleteArgs} args - Arguments to delete one VitalSigns.
     * @example
     * // Delete one VitalSigns
     * const VitalSigns = await prisma.vitalSigns.delete({
     *   where: {
     *     // ... filter to delete one VitalSigns
     *   }
     * })
     * 
     */
    delete<T extends VitalSignsDeleteArgs>(args: SelectSubset<T, VitalSignsDeleteArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VitalSigns.
     * @param {VitalSignsUpdateArgs} args - Arguments to update one VitalSigns.
     * @example
     * // Update one VitalSigns
     * const vitalSigns = await prisma.vitalSigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VitalSignsUpdateArgs>(args: SelectSubset<T, VitalSignsUpdateArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VitalSigns.
     * @param {VitalSignsDeleteManyArgs} args - Arguments to filter VitalSigns to delete.
     * @example
     * // Delete a few VitalSigns
     * const { count } = await prisma.vitalSigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VitalSignsDeleteManyArgs>(args?: SelectSubset<T, VitalSignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitalSigns
     * const vitalSigns = await prisma.vitalSigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VitalSignsUpdateManyArgs>(args: SelectSubset<T, VitalSignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VitalSigns.
     * @param {VitalSignsUpsertArgs} args - Arguments to update or create a VitalSigns.
     * @example
     * // Update or create a VitalSigns
     * const vitalSigns = await prisma.vitalSigns.upsert({
     *   create: {
     *     // ... data to create a VitalSigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitalSigns we want to update
     *   }
     * })
     */
    upsert<T extends VitalSignsUpsertArgs>(args: SelectSubset<T, VitalSignsUpsertArgs<ExtArgs>>): Prisma__VitalSignsClient<$Result.GetResult<Prisma.$VitalSignsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsCountArgs} args - Arguments to filter VitalSigns to count.
     * @example
     * // Count the number of VitalSigns
     * const count = await prisma.vitalSigns.count({
     *   where: {
     *     // ... the filter for the VitalSigns we want to count
     *   }
     * })
    **/
    count<T extends VitalSignsCountArgs>(
      args?: Subset<T, VitalSignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitalSignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitalSignsAggregateArgs>(args: Subset<T, VitalSignsAggregateArgs>): Prisma.PrismaPromise<GetVitalSignsAggregateType<T>>

    /**
     * Group by VitalSigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitalSignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitalSignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitalSignsGroupByArgs['orderBy'] }
        : { orderBy?: VitalSignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitalSignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitalSignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VitalSigns model
   */
  readonly fields: VitalSignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitalSigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VitalSignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VitalSigns model
   */
  interface VitalSignsFieldRefs {
    readonly id: FieldRef<"VitalSigns", 'String'>
    readonly userProfileId: FieldRef<"VitalSigns", 'String'>
    readonly recordDate: FieldRef<"VitalSigns", 'DateTime'>
    readonly bloodPressure: FieldRef<"VitalSigns", 'String'>
    readonly heartRate: FieldRef<"VitalSigns", 'Int'>
    readonly respiratoryRate: FieldRef<"VitalSigns", 'Int'>
    readonly temperatureCelsius: FieldRef<"VitalSigns", 'Float'>
    readonly pulseRate: FieldRef<"VitalSigns", 'Int'>
    readonly recordedBy: FieldRef<"VitalSigns", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VitalSigns findUnique
   */
  export type VitalSignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns findUniqueOrThrow
   */
  export type VitalSignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns findFirst
   */
  export type VitalSignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns findFirstOrThrow
   */
  export type VitalSignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitalSigns.
     */
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns findMany
   */
  export type VitalSignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter, which VitalSigns to fetch.
     */
    where?: VitalSignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitalSigns to fetch.
     */
    orderBy?: VitalSignsOrderByWithRelationInput | VitalSignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitalSigns.
     */
    cursor?: VitalSignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitalSigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitalSigns.
     */
    skip?: number
    distinct?: VitalSignsScalarFieldEnum | VitalSignsScalarFieldEnum[]
  }

  /**
   * VitalSigns create
   */
  export type VitalSignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The data needed to create a VitalSigns.
     */
    data: XOR<VitalSignsCreateInput, VitalSignsUncheckedCreateInput>
  }

  /**
   * VitalSigns createMany
   */
  export type VitalSignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VitalSigns.
     */
    data: VitalSignsCreateManyInput | VitalSignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VitalSigns update
   */
  export type VitalSignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The data needed to update a VitalSigns.
     */
    data: XOR<VitalSignsUpdateInput, VitalSignsUncheckedUpdateInput>
    /**
     * Choose, which VitalSigns to update.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns updateMany
   */
  export type VitalSignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VitalSigns.
     */
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyInput>
    /**
     * Filter which VitalSigns to update
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to update.
     */
    limit?: number
  }

  /**
   * VitalSigns upsert
   */
  export type VitalSignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * The filter to search for the VitalSigns to update in case it exists.
     */
    where: VitalSignsWhereUniqueInput
    /**
     * In case the VitalSigns found by the `where` argument doesn't exist, create a new VitalSigns with this data.
     */
    create: XOR<VitalSignsCreateInput, VitalSignsUncheckedCreateInput>
    /**
     * In case the VitalSigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VitalSignsUpdateInput, VitalSignsUncheckedUpdateInput>
  }

  /**
   * VitalSigns delete
   */
  export type VitalSignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
    /**
     * Filter which VitalSigns to delete.
     */
    where: VitalSignsWhereUniqueInput
  }

  /**
   * VitalSigns deleteMany
   */
  export type VitalSignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VitalSigns to delete
     */
    where?: VitalSignsWhereInput
    /**
     * Limit how many VitalSigns to delete.
     */
    limit?: number
  }

  /**
   * VitalSigns without action
   */
  export type VitalSignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VitalSigns
     */
    select?: VitalSignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VitalSigns
     */
    omit?: VitalSignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VitalSignsInclude<ExtArgs> | null
  }


  /**
   * Model AnthropometricMeasurement
   */

  export type AggregateAnthropometricMeasurement = {
    _count: AnthropometricMeasurementCountAggregateOutputType | null
    _avg: AnthropometricMeasurementAvgAggregateOutputType | null
    _sum: AnthropometricMeasurementSumAggregateOutputType | null
    _min: AnthropometricMeasurementMinAggregateOutputType | null
    _max: AnthropometricMeasurementMaxAggregateOutputType | null
  }

  export type AnthropometricMeasurementAvgAggregateOutputType = {
    weightKg: number | null
    heightCm: number | null
    headCircumferenceCm: number | null
    waistCircumferenceCm: number | null
    bmi: number | null
  }

  export type AnthropometricMeasurementSumAggregateOutputType = {
    weightKg: number | null
    heightCm: number | null
    headCircumferenceCm: number | null
    waistCircumferenceCm: number | null
    bmi: number | null
  }

  export type AnthropometricMeasurementMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    measurementDate: Date | null
    weightKg: number | null
    heightCm: number | null
    headCircumferenceCm: number | null
    waistCircumferenceCm: number | null
    bmi: number | null
    recordedBy: string | null
  }

  export type AnthropometricMeasurementMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    measurementDate: Date | null
    weightKg: number | null
    heightCm: number | null
    headCircumferenceCm: number | null
    waistCircumferenceCm: number | null
    bmi: number | null
    recordedBy: string | null
  }

  export type AnthropometricMeasurementCountAggregateOutputType = {
    id: number
    userProfileId: number
    measurementDate: number
    weightKg: number
    heightCm: number
    headCircumferenceCm: number
    waistCircumferenceCm: number
    bmi: number
    recordedBy: number
    _all: number
  }


  export type AnthropometricMeasurementAvgAggregateInputType = {
    weightKg?: true
    heightCm?: true
    headCircumferenceCm?: true
    waistCircumferenceCm?: true
    bmi?: true
  }

  export type AnthropometricMeasurementSumAggregateInputType = {
    weightKg?: true
    heightCm?: true
    headCircumferenceCm?: true
    waistCircumferenceCm?: true
    bmi?: true
  }

  export type AnthropometricMeasurementMinAggregateInputType = {
    id?: true
    userProfileId?: true
    measurementDate?: true
    weightKg?: true
    heightCm?: true
    headCircumferenceCm?: true
    waistCircumferenceCm?: true
    bmi?: true
    recordedBy?: true
  }

  export type AnthropometricMeasurementMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    measurementDate?: true
    weightKg?: true
    heightCm?: true
    headCircumferenceCm?: true
    waistCircumferenceCm?: true
    bmi?: true
    recordedBy?: true
  }

  export type AnthropometricMeasurementCountAggregateInputType = {
    id?: true
    userProfileId?: true
    measurementDate?: true
    weightKg?: true
    heightCm?: true
    headCircumferenceCm?: true
    waistCircumferenceCm?: true
    bmi?: true
    recordedBy?: true
    _all?: true
  }

  export type AnthropometricMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnthropometricMeasurement to aggregate.
     */
    where?: AnthropometricMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnthropometricMeasurements to fetch.
     */
    orderBy?: AnthropometricMeasurementOrderByWithRelationInput | AnthropometricMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnthropometricMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnthropometricMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnthropometricMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnthropometricMeasurements
    **/
    _count?: true | AnthropometricMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnthropometricMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnthropometricMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnthropometricMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnthropometricMeasurementMaxAggregateInputType
  }

  export type GetAnthropometricMeasurementAggregateType<T extends AnthropometricMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnthropometricMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnthropometricMeasurement[P]>
      : GetScalarType<T[P], AggregateAnthropometricMeasurement[P]>
  }




  export type AnthropometricMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnthropometricMeasurementWhereInput
    orderBy?: AnthropometricMeasurementOrderByWithAggregationInput | AnthropometricMeasurementOrderByWithAggregationInput[]
    by: AnthropometricMeasurementScalarFieldEnum[] | AnthropometricMeasurementScalarFieldEnum
    having?: AnthropometricMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnthropometricMeasurementCountAggregateInputType | true
    _avg?: AnthropometricMeasurementAvgAggregateInputType
    _sum?: AnthropometricMeasurementSumAggregateInputType
    _min?: AnthropometricMeasurementMinAggregateInputType
    _max?: AnthropometricMeasurementMaxAggregateInputType
  }

  export type AnthropometricMeasurementGroupByOutputType = {
    id: string
    userProfileId: string
    measurementDate: Date
    weightKg: number | null
    heightCm: number | null
    headCircumferenceCm: number | null
    waistCircumferenceCm: number | null
    bmi: number | null
    recordedBy: string
    _count: AnthropometricMeasurementCountAggregateOutputType | null
    _avg: AnthropometricMeasurementAvgAggregateOutputType | null
    _sum: AnthropometricMeasurementSumAggregateOutputType | null
    _min: AnthropometricMeasurementMinAggregateOutputType | null
    _max: AnthropometricMeasurementMaxAggregateOutputType | null
  }

  type GetAnthropometricMeasurementGroupByPayload<T extends AnthropometricMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnthropometricMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnthropometricMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnthropometricMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], AnthropometricMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type AnthropometricMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    measurementDate?: boolean
    weightKg?: boolean
    heightCm?: boolean
    headCircumferenceCm?: boolean
    waistCircumferenceCm?: boolean
    bmi?: boolean
    recordedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anthropometricMeasurement"]>



  export type AnthropometricMeasurementSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    measurementDate?: boolean
    weightKg?: boolean
    heightCm?: boolean
    headCircumferenceCm?: boolean
    waistCircumferenceCm?: boolean
    bmi?: boolean
    recordedBy?: boolean
  }

  export type AnthropometricMeasurementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "measurementDate" | "weightKg" | "heightCm" | "headCircumferenceCm" | "waistCircumferenceCm" | "bmi" | "recordedBy", ExtArgs["result"]["anthropometricMeasurement"]>
  export type AnthropometricMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $AnthropometricMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnthropometricMeasurement"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      measurementDate: Date
      weightKg: number | null
      heightCm: number | null
      headCircumferenceCm: number | null
      waistCircumferenceCm: number | null
      bmi: number | null
      recordedBy: string
    }, ExtArgs["result"]["anthropometricMeasurement"]>
    composites: {}
  }

  type AnthropometricMeasurementGetPayload<S extends boolean | null | undefined | AnthropometricMeasurementDefaultArgs> = $Result.GetResult<Prisma.$AnthropometricMeasurementPayload, S>

  type AnthropometricMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnthropometricMeasurementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnthropometricMeasurementCountAggregateInputType | true
    }

  export interface AnthropometricMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnthropometricMeasurement'], meta: { name: 'AnthropometricMeasurement' } }
    /**
     * Find zero or one AnthropometricMeasurement that matches the filter.
     * @param {AnthropometricMeasurementFindUniqueArgs} args - Arguments to find a AnthropometricMeasurement
     * @example
     * // Get one AnthropometricMeasurement
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnthropometricMeasurementFindUniqueArgs>(args: SelectSubset<T, AnthropometricMeasurementFindUniqueArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnthropometricMeasurement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnthropometricMeasurementFindUniqueOrThrowArgs} args - Arguments to find a AnthropometricMeasurement
     * @example
     * // Get one AnthropometricMeasurement
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnthropometricMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnthropometricMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnthropometricMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnthropometricMeasurementFindFirstArgs} args - Arguments to find a AnthropometricMeasurement
     * @example
     * // Get one AnthropometricMeasurement
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnthropometricMeasurementFindFirstArgs>(args?: SelectSubset<T, AnthropometricMeasurementFindFirstArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnthropometricMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnthropometricMeasurementFindFirstOrThrowArgs} args - Arguments to find a AnthropometricMeasurement
     * @example
     * // Get one AnthropometricMeasurement
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnthropometricMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnthropometricMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnthropometricMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnthropometricMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnthropometricMeasurements
     * const anthropometricMeasurements = await prisma.anthropometricMeasurement.findMany()
     * 
     * // Get first 10 AnthropometricMeasurements
     * const anthropometricMeasurements = await prisma.anthropometricMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anthropometricMeasurementWithIdOnly = await prisma.anthropometricMeasurement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnthropometricMeasurementFindManyArgs>(args?: SelectSubset<T, AnthropometricMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnthropometricMeasurement.
     * @param {AnthropometricMeasurementCreateArgs} args - Arguments to create a AnthropometricMeasurement.
     * @example
     * // Create one AnthropometricMeasurement
     * const AnthropometricMeasurement = await prisma.anthropometricMeasurement.create({
     *   data: {
     *     // ... data to create a AnthropometricMeasurement
     *   }
     * })
     * 
     */
    create<T extends AnthropometricMeasurementCreateArgs>(args: SelectSubset<T, AnthropometricMeasurementCreateArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnthropometricMeasurements.
     * @param {AnthropometricMeasurementCreateManyArgs} args - Arguments to create many AnthropometricMeasurements.
     * @example
     * // Create many AnthropometricMeasurements
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnthropometricMeasurementCreateManyArgs>(args?: SelectSubset<T, AnthropometricMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AnthropometricMeasurement.
     * @param {AnthropometricMeasurementDeleteArgs} args - Arguments to delete one AnthropometricMeasurement.
     * @example
     * // Delete one AnthropometricMeasurement
     * const AnthropometricMeasurement = await prisma.anthropometricMeasurement.delete({
     *   where: {
     *     // ... filter to delete one AnthropometricMeasurement
     *   }
     * })
     * 
     */
    delete<T extends AnthropometricMeasurementDeleteArgs>(args: SelectSubset<T, AnthropometricMeasurementDeleteArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnthropometricMeasurement.
     * @param {AnthropometricMeasurementUpdateArgs} args - Arguments to update one AnthropometricMeasurement.
     * @example
     * // Update one AnthropometricMeasurement
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnthropometricMeasurementUpdateArgs>(args: SelectSubset<T, AnthropometricMeasurementUpdateArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnthropometricMeasurements.
     * @param {AnthropometricMeasurementDeleteManyArgs} args - Arguments to filter AnthropometricMeasurements to delete.
     * @example
     * // Delete a few AnthropometricMeasurements
     * const { count } = await prisma.anthropometricMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnthropometricMeasurementDeleteManyArgs>(args?: SelectSubset<T, AnthropometricMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnthropometricMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnthropometricMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnthropometricMeasurements
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnthropometricMeasurementUpdateManyArgs>(args: SelectSubset<T, AnthropometricMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnthropometricMeasurement.
     * @param {AnthropometricMeasurementUpsertArgs} args - Arguments to update or create a AnthropometricMeasurement.
     * @example
     * // Update or create a AnthropometricMeasurement
     * const anthropometricMeasurement = await prisma.anthropometricMeasurement.upsert({
     *   create: {
     *     // ... data to create a AnthropometricMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnthropometricMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends AnthropometricMeasurementUpsertArgs>(args: SelectSubset<T, AnthropometricMeasurementUpsertArgs<ExtArgs>>): Prisma__AnthropometricMeasurementClient<$Result.GetResult<Prisma.$AnthropometricMeasurementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnthropometricMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnthropometricMeasurementCountArgs} args - Arguments to filter AnthropometricMeasurements to count.
     * @example
     * // Count the number of AnthropometricMeasurements
     * const count = await prisma.anthropometricMeasurement.count({
     *   where: {
     *     // ... the filter for the AnthropometricMeasurements we want to count
     *   }
     * })
    **/
    count<T extends AnthropometricMeasurementCountArgs>(
      args?: Subset<T, AnthropometricMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnthropometricMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnthropometricMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnthropometricMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnthropometricMeasurementAggregateArgs>(args: Subset<T, AnthropometricMeasurementAggregateArgs>): Prisma.PrismaPromise<GetAnthropometricMeasurementAggregateType<T>>

    /**
     * Group by AnthropometricMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnthropometricMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnthropometricMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnthropometricMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: AnthropometricMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnthropometricMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnthropometricMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnthropometricMeasurement model
   */
  readonly fields: AnthropometricMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnthropometricMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnthropometricMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnthropometricMeasurement model
   */
  interface AnthropometricMeasurementFieldRefs {
    readonly id: FieldRef<"AnthropometricMeasurement", 'String'>
    readonly userProfileId: FieldRef<"AnthropometricMeasurement", 'String'>
    readonly measurementDate: FieldRef<"AnthropometricMeasurement", 'DateTime'>
    readonly weightKg: FieldRef<"AnthropometricMeasurement", 'Float'>
    readonly heightCm: FieldRef<"AnthropometricMeasurement", 'Float'>
    readonly headCircumferenceCm: FieldRef<"AnthropometricMeasurement", 'Float'>
    readonly waistCircumferenceCm: FieldRef<"AnthropometricMeasurement", 'Float'>
    readonly bmi: FieldRef<"AnthropometricMeasurement", 'Float'>
    readonly recordedBy: FieldRef<"AnthropometricMeasurement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnthropometricMeasurement findUnique
   */
  export type AnthropometricMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which AnthropometricMeasurement to fetch.
     */
    where: AnthropometricMeasurementWhereUniqueInput
  }

  /**
   * AnthropometricMeasurement findUniqueOrThrow
   */
  export type AnthropometricMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which AnthropometricMeasurement to fetch.
     */
    where: AnthropometricMeasurementWhereUniqueInput
  }

  /**
   * AnthropometricMeasurement findFirst
   */
  export type AnthropometricMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which AnthropometricMeasurement to fetch.
     */
    where?: AnthropometricMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnthropometricMeasurements to fetch.
     */
    orderBy?: AnthropometricMeasurementOrderByWithRelationInput | AnthropometricMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnthropometricMeasurements.
     */
    cursor?: AnthropometricMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnthropometricMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnthropometricMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnthropometricMeasurements.
     */
    distinct?: AnthropometricMeasurementScalarFieldEnum | AnthropometricMeasurementScalarFieldEnum[]
  }

  /**
   * AnthropometricMeasurement findFirstOrThrow
   */
  export type AnthropometricMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which AnthropometricMeasurement to fetch.
     */
    where?: AnthropometricMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnthropometricMeasurements to fetch.
     */
    orderBy?: AnthropometricMeasurementOrderByWithRelationInput | AnthropometricMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnthropometricMeasurements.
     */
    cursor?: AnthropometricMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnthropometricMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnthropometricMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnthropometricMeasurements.
     */
    distinct?: AnthropometricMeasurementScalarFieldEnum | AnthropometricMeasurementScalarFieldEnum[]
  }

  /**
   * AnthropometricMeasurement findMany
   */
  export type AnthropometricMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which AnthropometricMeasurements to fetch.
     */
    where?: AnthropometricMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnthropometricMeasurements to fetch.
     */
    orderBy?: AnthropometricMeasurementOrderByWithRelationInput | AnthropometricMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnthropometricMeasurements.
     */
    cursor?: AnthropometricMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnthropometricMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnthropometricMeasurements.
     */
    skip?: number
    distinct?: AnthropometricMeasurementScalarFieldEnum | AnthropometricMeasurementScalarFieldEnum[]
  }

  /**
   * AnthropometricMeasurement create
   */
  export type AnthropometricMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a AnthropometricMeasurement.
     */
    data: XOR<AnthropometricMeasurementCreateInput, AnthropometricMeasurementUncheckedCreateInput>
  }

  /**
   * AnthropometricMeasurement createMany
   */
  export type AnthropometricMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnthropometricMeasurements.
     */
    data: AnthropometricMeasurementCreateManyInput | AnthropometricMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnthropometricMeasurement update
   */
  export type AnthropometricMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a AnthropometricMeasurement.
     */
    data: XOR<AnthropometricMeasurementUpdateInput, AnthropometricMeasurementUncheckedUpdateInput>
    /**
     * Choose, which AnthropometricMeasurement to update.
     */
    where: AnthropometricMeasurementWhereUniqueInput
  }

  /**
   * AnthropometricMeasurement updateMany
   */
  export type AnthropometricMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnthropometricMeasurements.
     */
    data: XOR<AnthropometricMeasurementUpdateManyMutationInput, AnthropometricMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which AnthropometricMeasurements to update
     */
    where?: AnthropometricMeasurementWhereInput
    /**
     * Limit how many AnthropometricMeasurements to update.
     */
    limit?: number
  }

  /**
   * AnthropometricMeasurement upsert
   */
  export type AnthropometricMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the AnthropometricMeasurement to update in case it exists.
     */
    where: AnthropometricMeasurementWhereUniqueInput
    /**
     * In case the AnthropometricMeasurement found by the `where` argument doesn't exist, create a new AnthropometricMeasurement with this data.
     */
    create: XOR<AnthropometricMeasurementCreateInput, AnthropometricMeasurementUncheckedCreateInput>
    /**
     * In case the AnthropometricMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnthropometricMeasurementUpdateInput, AnthropometricMeasurementUncheckedUpdateInput>
  }

  /**
   * AnthropometricMeasurement delete
   */
  export type AnthropometricMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
    /**
     * Filter which AnthropometricMeasurement to delete.
     */
    where: AnthropometricMeasurementWhereUniqueInput
  }

  /**
   * AnthropometricMeasurement deleteMany
   */
  export type AnthropometricMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnthropometricMeasurements to delete
     */
    where?: AnthropometricMeasurementWhereInput
    /**
     * Limit how many AnthropometricMeasurements to delete.
     */
    limit?: number
  }

  /**
   * AnthropometricMeasurement without action
   */
  export type AnthropometricMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnthropometricMeasurement
     */
    select?: AnthropometricMeasurementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnthropometricMeasurement
     */
    omit?: AnthropometricMeasurementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnthropometricMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model GrowthTracking
   */

  export type AggregateGrowthTracking = {
    _count: GrowthTrackingCountAggregateOutputType | null
    _min: GrowthTrackingMinAggregateOutputType | null
    _max: GrowthTrackingMaxAggregateOutputType | null
  }

  export type GrowthTrackingMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    trackingDate: Date | null
    weightForAge: string | null
    heightForAge: string | null
    weightForHeight: string | null
    recordedBy: string | null
  }

  export type GrowthTrackingMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    trackingDate: Date | null
    weightForAge: string | null
    heightForAge: string | null
    weightForHeight: string | null
    recordedBy: string | null
  }

  export type GrowthTrackingCountAggregateOutputType = {
    id: number
    userProfileId: number
    trackingDate: number
    weightForAge: number
    heightForAge: number
    weightForHeight: number
    recordedBy: number
    _all: number
  }


  export type GrowthTrackingMinAggregateInputType = {
    id?: true
    userProfileId?: true
    trackingDate?: true
    weightForAge?: true
    heightForAge?: true
    weightForHeight?: true
    recordedBy?: true
  }

  export type GrowthTrackingMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    trackingDate?: true
    weightForAge?: true
    heightForAge?: true
    weightForHeight?: true
    recordedBy?: true
  }

  export type GrowthTrackingCountAggregateInputType = {
    id?: true
    userProfileId?: true
    trackingDate?: true
    weightForAge?: true
    heightForAge?: true
    weightForHeight?: true
    recordedBy?: true
    _all?: true
  }

  export type GrowthTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GrowthTracking to aggregate.
     */
    where?: GrowthTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthTrackings to fetch.
     */
    orderBy?: GrowthTrackingOrderByWithRelationInput | GrowthTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GrowthTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GrowthTrackings
    **/
    _count?: true | GrowthTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GrowthTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GrowthTrackingMaxAggregateInputType
  }

  export type GetGrowthTrackingAggregateType<T extends GrowthTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateGrowthTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrowthTracking[P]>
      : GetScalarType<T[P], AggregateGrowthTracking[P]>
  }




  export type GrowthTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GrowthTrackingWhereInput
    orderBy?: GrowthTrackingOrderByWithAggregationInput | GrowthTrackingOrderByWithAggregationInput[]
    by: GrowthTrackingScalarFieldEnum[] | GrowthTrackingScalarFieldEnum
    having?: GrowthTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GrowthTrackingCountAggregateInputType | true
    _min?: GrowthTrackingMinAggregateInputType
    _max?: GrowthTrackingMaxAggregateInputType
  }

  export type GrowthTrackingGroupByOutputType = {
    id: string
    userProfileId: string
    trackingDate: Date
    weightForAge: string | null
    heightForAge: string | null
    weightForHeight: string | null
    recordedBy: string
    _count: GrowthTrackingCountAggregateOutputType | null
    _min: GrowthTrackingMinAggregateOutputType | null
    _max: GrowthTrackingMaxAggregateOutputType | null
  }

  type GetGrowthTrackingGroupByPayload<T extends GrowthTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GrowthTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GrowthTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GrowthTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], GrowthTrackingGroupByOutputType[P]>
        }
      >
    >


  export type GrowthTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    trackingDate?: boolean
    weightForAge?: boolean
    heightForAge?: boolean
    weightForHeight?: boolean
    recordedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["growthTracking"]>



  export type GrowthTrackingSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    trackingDate?: boolean
    weightForAge?: boolean
    heightForAge?: boolean
    weightForHeight?: boolean
    recordedBy?: boolean
  }

  export type GrowthTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "trackingDate" | "weightForAge" | "heightForAge" | "weightForHeight" | "recordedBy", ExtArgs["result"]["growthTracking"]>
  export type GrowthTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $GrowthTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GrowthTracking"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      trackingDate: Date
      weightForAge: string | null
      heightForAge: string | null
      weightForHeight: string | null
      recordedBy: string
    }, ExtArgs["result"]["growthTracking"]>
    composites: {}
  }

  type GrowthTrackingGetPayload<S extends boolean | null | undefined | GrowthTrackingDefaultArgs> = $Result.GetResult<Prisma.$GrowthTrackingPayload, S>

  type GrowthTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GrowthTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GrowthTrackingCountAggregateInputType | true
    }

  export interface GrowthTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GrowthTracking'], meta: { name: 'GrowthTracking' } }
    /**
     * Find zero or one GrowthTracking that matches the filter.
     * @param {GrowthTrackingFindUniqueArgs} args - Arguments to find a GrowthTracking
     * @example
     * // Get one GrowthTracking
     * const growthTracking = await prisma.growthTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GrowthTrackingFindUniqueArgs>(args: SelectSubset<T, GrowthTrackingFindUniqueArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GrowthTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GrowthTrackingFindUniqueOrThrowArgs} args - Arguments to find a GrowthTracking
     * @example
     * // Get one GrowthTracking
     * const growthTracking = await prisma.growthTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GrowthTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, GrowthTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GrowthTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthTrackingFindFirstArgs} args - Arguments to find a GrowthTracking
     * @example
     * // Get one GrowthTracking
     * const growthTracking = await prisma.growthTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GrowthTrackingFindFirstArgs>(args?: SelectSubset<T, GrowthTrackingFindFirstArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GrowthTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthTrackingFindFirstOrThrowArgs} args - Arguments to find a GrowthTracking
     * @example
     * // Get one GrowthTracking
     * const growthTracking = await prisma.growthTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GrowthTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, GrowthTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GrowthTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GrowthTrackings
     * const growthTrackings = await prisma.growthTracking.findMany()
     * 
     * // Get first 10 GrowthTrackings
     * const growthTrackings = await prisma.growthTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const growthTrackingWithIdOnly = await prisma.growthTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GrowthTrackingFindManyArgs>(args?: SelectSubset<T, GrowthTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GrowthTracking.
     * @param {GrowthTrackingCreateArgs} args - Arguments to create a GrowthTracking.
     * @example
     * // Create one GrowthTracking
     * const GrowthTracking = await prisma.growthTracking.create({
     *   data: {
     *     // ... data to create a GrowthTracking
     *   }
     * })
     * 
     */
    create<T extends GrowthTrackingCreateArgs>(args: SelectSubset<T, GrowthTrackingCreateArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GrowthTrackings.
     * @param {GrowthTrackingCreateManyArgs} args - Arguments to create many GrowthTrackings.
     * @example
     * // Create many GrowthTrackings
     * const growthTracking = await prisma.growthTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GrowthTrackingCreateManyArgs>(args?: SelectSubset<T, GrowthTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GrowthTracking.
     * @param {GrowthTrackingDeleteArgs} args - Arguments to delete one GrowthTracking.
     * @example
     * // Delete one GrowthTracking
     * const GrowthTracking = await prisma.growthTracking.delete({
     *   where: {
     *     // ... filter to delete one GrowthTracking
     *   }
     * })
     * 
     */
    delete<T extends GrowthTrackingDeleteArgs>(args: SelectSubset<T, GrowthTrackingDeleteArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GrowthTracking.
     * @param {GrowthTrackingUpdateArgs} args - Arguments to update one GrowthTracking.
     * @example
     * // Update one GrowthTracking
     * const growthTracking = await prisma.growthTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GrowthTrackingUpdateArgs>(args: SelectSubset<T, GrowthTrackingUpdateArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GrowthTrackings.
     * @param {GrowthTrackingDeleteManyArgs} args - Arguments to filter GrowthTrackings to delete.
     * @example
     * // Delete a few GrowthTrackings
     * const { count } = await prisma.growthTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GrowthTrackingDeleteManyArgs>(args?: SelectSubset<T, GrowthTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GrowthTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GrowthTrackings
     * const growthTracking = await prisma.growthTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GrowthTrackingUpdateManyArgs>(args: SelectSubset<T, GrowthTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GrowthTracking.
     * @param {GrowthTrackingUpsertArgs} args - Arguments to update or create a GrowthTracking.
     * @example
     * // Update or create a GrowthTracking
     * const growthTracking = await prisma.growthTracking.upsert({
     *   create: {
     *     // ... data to create a GrowthTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GrowthTracking we want to update
     *   }
     * })
     */
    upsert<T extends GrowthTrackingUpsertArgs>(args: SelectSubset<T, GrowthTrackingUpsertArgs<ExtArgs>>): Prisma__GrowthTrackingClient<$Result.GetResult<Prisma.$GrowthTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GrowthTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthTrackingCountArgs} args - Arguments to filter GrowthTrackings to count.
     * @example
     * // Count the number of GrowthTrackings
     * const count = await prisma.growthTracking.count({
     *   where: {
     *     // ... the filter for the GrowthTrackings we want to count
     *   }
     * })
    **/
    count<T extends GrowthTrackingCountArgs>(
      args?: Subset<T, GrowthTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GrowthTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GrowthTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GrowthTrackingAggregateArgs>(args: Subset<T, GrowthTrackingAggregateArgs>): Prisma.PrismaPromise<GetGrowthTrackingAggregateType<T>>

    /**
     * Group by GrowthTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GrowthTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GrowthTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GrowthTrackingGroupByArgs['orderBy'] }
        : { orderBy?: GrowthTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GrowthTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGrowthTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GrowthTracking model
   */
  readonly fields: GrowthTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GrowthTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GrowthTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GrowthTracking model
   */
  interface GrowthTrackingFieldRefs {
    readonly id: FieldRef<"GrowthTracking", 'String'>
    readonly userProfileId: FieldRef<"GrowthTracking", 'String'>
    readonly trackingDate: FieldRef<"GrowthTracking", 'DateTime'>
    readonly weightForAge: FieldRef<"GrowthTracking", 'String'>
    readonly heightForAge: FieldRef<"GrowthTracking", 'String'>
    readonly weightForHeight: FieldRef<"GrowthTracking", 'String'>
    readonly recordedBy: FieldRef<"GrowthTracking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GrowthTracking findUnique
   */
  export type GrowthTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * Filter, which GrowthTracking to fetch.
     */
    where: GrowthTrackingWhereUniqueInput
  }

  /**
   * GrowthTracking findUniqueOrThrow
   */
  export type GrowthTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * Filter, which GrowthTracking to fetch.
     */
    where: GrowthTrackingWhereUniqueInput
  }

  /**
   * GrowthTracking findFirst
   */
  export type GrowthTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * Filter, which GrowthTracking to fetch.
     */
    where?: GrowthTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthTrackings to fetch.
     */
    orderBy?: GrowthTrackingOrderByWithRelationInput | GrowthTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GrowthTrackings.
     */
    cursor?: GrowthTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GrowthTrackings.
     */
    distinct?: GrowthTrackingScalarFieldEnum | GrowthTrackingScalarFieldEnum[]
  }

  /**
   * GrowthTracking findFirstOrThrow
   */
  export type GrowthTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * Filter, which GrowthTracking to fetch.
     */
    where?: GrowthTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthTrackings to fetch.
     */
    orderBy?: GrowthTrackingOrderByWithRelationInput | GrowthTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GrowthTrackings.
     */
    cursor?: GrowthTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GrowthTrackings.
     */
    distinct?: GrowthTrackingScalarFieldEnum | GrowthTrackingScalarFieldEnum[]
  }

  /**
   * GrowthTracking findMany
   */
  export type GrowthTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * Filter, which GrowthTrackings to fetch.
     */
    where?: GrowthTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GrowthTrackings to fetch.
     */
    orderBy?: GrowthTrackingOrderByWithRelationInput | GrowthTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GrowthTrackings.
     */
    cursor?: GrowthTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GrowthTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GrowthTrackings.
     */
    skip?: number
    distinct?: GrowthTrackingScalarFieldEnum | GrowthTrackingScalarFieldEnum[]
  }

  /**
   * GrowthTracking create
   */
  export type GrowthTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a GrowthTracking.
     */
    data: XOR<GrowthTrackingCreateInput, GrowthTrackingUncheckedCreateInput>
  }

  /**
   * GrowthTracking createMany
   */
  export type GrowthTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GrowthTrackings.
     */
    data: GrowthTrackingCreateManyInput | GrowthTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GrowthTracking update
   */
  export type GrowthTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a GrowthTracking.
     */
    data: XOR<GrowthTrackingUpdateInput, GrowthTrackingUncheckedUpdateInput>
    /**
     * Choose, which GrowthTracking to update.
     */
    where: GrowthTrackingWhereUniqueInput
  }

  /**
   * GrowthTracking updateMany
   */
  export type GrowthTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GrowthTrackings.
     */
    data: XOR<GrowthTrackingUpdateManyMutationInput, GrowthTrackingUncheckedUpdateManyInput>
    /**
     * Filter which GrowthTrackings to update
     */
    where?: GrowthTrackingWhereInput
    /**
     * Limit how many GrowthTrackings to update.
     */
    limit?: number
  }

  /**
   * GrowthTracking upsert
   */
  export type GrowthTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the GrowthTracking to update in case it exists.
     */
    where: GrowthTrackingWhereUniqueInput
    /**
     * In case the GrowthTracking found by the `where` argument doesn't exist, create a new GrowthTracking with this data.
     */
    create: XOR<GrowthTrackingCreateInput, GrowthTrackingUncheckedCreateInput>
    /**
     * In case the GrowthTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GrowthTrackingUpdateInput, GrowthTrackingUncheckedUpdateInput>
  }

  /**
   * GrowthTracking delete
   */
  export type GrowthTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
    /**
     * Filter which GrowthTracking to delete.
     */
    where: GrowthTrackingWhereUniqueInput
  }

  /**
   * GrowthTracking deleteMany
   */
  export type GrowthTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GrowthTrackings to delete
     */
    where?: GrowthTrackingWhereInput
    /**
     * Limit how many GrowthTrackings to delete.
     */
    limit?: number
  }

  /**
   * GrowthTracking without action
   */
  export type GrowthTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GrowthTracking
     */
    select?: GrowthTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GrowthTracking
     */
    omit?: GrowthTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GrowthTrackingInclude<ExtArgs> | null
  }


  /**
   * Model NCDRiskAssessment
   */

  export type AggregateNCDRiskAssessment = {
    _count: NCDRiskAssessmentCountAggregateOutputType | null
    _min: NCDRiskAssessmentMinAggregateOutputType | null
    _max: NCDRiskAssessmentMaxAggregateOutputType | null
  }

  export type NCDRiskAssessmentMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    assessmentDate: Date | null
    smokingStatus: string | null
    alcoholIntake: string | null
    physicalActivity: string | null
    fruitVegetableIntake: string | null
    familyHistoryDiabetes: boolean | null
    familyHistoryHypertension: boolean | null
    familyHistoryHeartDisease: boolean | null
    familyHistoryStroke: boolean | null
    screeningCompleted: boolean | null
    followUpNeeded: boolean | null
    recordedBy: string | null
  }

  export type NCDRiskAssessmentMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    assessmentDate: Date | null
    smokingStatus: string | null
    alcoholIntake: string | null
    physicalActivity: string | null
    fruitVegetableIntake: string | null
    familyHistoryDiabetes: boolean | null
    familyHistoryHypertension: boolean | null
    familyHistoryHeartDisease: boolean | null
    familyHistoryStroke: boolean | null
    screeningCompleted: boolean | null
    followUpNeeded: boolean | null
    recordedBy: string | null
  }

  export type NCDRiskAssessmentCountAggregateOutputType = {
    id: number
    userProfileId: number
    assessmentDate: number
    smokingStatus: number
    alcoholIntake: number
    physicalActivity: number
    fruitVegetableIntake: number
    familyHistoryDiabetes: number
    familyHistoryHypertension: number
    familyHistoryHeartDisease: number
    familyHistoryStroke: number
    screeningCompleted: number
    followUpNeeded: number
    lifestyleModifications: number
    healthEducationReceived: number
    recordedBy: number
    _all: number
  }


  export type NCDRiskAssessmentMinAggregateInputType = {
    id?: true
    userProfileId?: true
    assessmentDate?: true
    smokingStatus?: true
    alcoholIntake?: true
    physicalActivity?: true
    fruitVegetableIntake?: true
    familyHistoryDiabetes?: true
    familyHistoryHypertension?: true
    familyHistoryHeartDisease?: true
    familyHistoryStroke?: true
    screeningCompleted?: true
    followUpNeeded?: true
    recordedBy?: true
  }

  export type NCDRiskAssessmentMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    assessmentDate?: true
    smokingStatus?: true
    alcoholIntake?: true
    physicalActivity?: true
    fruitVegetableIntake?: true
    familyHistoryDiabetes?: true
    familyHistoryHypertension?: true
    familyHistoryHeartDisease?: true
    familyHistoryStroke?: true
    screeningCompleted?: true
    followUpNeeded?: true
    recordedBy?: true
  }

  export type NCDRiskAssessmentCountAggregateInputType = {
    id?: true
    userProfileId?: true
    assessmentDate?: true
    smokingStatus?: true
    alcoholIntake?: true
    physicalActivity?: true
    fruitVegetableIntake?: true
    familyHistoryDiabetes?: true
    familyHistoryHypertension?: true
    familyHistoryHeartDisease?: true
    familyHistoryStroke?: true
    screeningCompleted?: true
    followUpNeeded?: true
    lifestyleModifications?: true
    healthEducationReceived?: true
    recordedBy?: true
    _all?: true
  }

  export type NCDRiskAssessmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NCDRiskAssessment to aggregate.
     */
    where?: NCDRiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NCDRiskAssessments to fetch.
     */
    orderBy?: NCDRiskAssessmentOrderByWithRelationInput | NCDRiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NCDRiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NCDRiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NCDRiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NCDRiskAssessments
    **/
    _count?: true | NCDRiskAssessmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NCDRiskAssessmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NCDRiskAssessmentMaxAggregateInputType
  }

  export type GetNCDRiskAssessmentAggregateType<T extends NCDRiskAssessmentAggregateArgs> = {
        [P in keyof T & keyof AggregateNCDRiskAssessment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNCDRiskAssessment[P]>
      : GetScalarType<T[P], AggregateNCDRiskAssessment[P]>
  }




  export type NCDRiskAssessmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NCDRiskAssessmentWhereInput
    orderBy?: NCDRiskAssessmentOrderByWithAggregationInput | NCDRiskAssessmentOrderByWithAggregationInput[]
    by: NCDRiskAssessmentScalarFieldEnum[] | NCDRiskAssessmentScalarFieldEnum
    having?: NCDRiskAssessmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NCDRiskAssessmentCountAggregateInputType | true
    _min?: NCDRiskAssessmentMinAggregateInputType
    _max?: NCDRiskAssessmentMaxAggregateInputType
  }

  export type NCDRiskAssessmentGroupByOutputType = {
    id: string
    userProfileId: string
    assessmentDate: Date
    smokingStatus: string | null
    alcoholIntake: string | null
    physicalActivity: string | null
    fruitVegetableIntake: string | null
    familyHistoryDiabetes: boolean
    familyHistoryHypertension: boolean
    familyHistoryHeartDisease: boolean
    familyHistoryStroke: boolean
    screeningCompleted: boolean
    followUpNeeded: boolean
    lifestyleModifications: JsonValue
    healthEducationReceived: JsonValue
    recordedBy: string
    _count: NCDRiskAssessmentCountAggregateOutputType | null
    _min: NCDRiskAssessmentMinAggregateOutputType | null
    _max: NCDRiskAssessmentMaxAggregateOutputType | null
  }

  type GetNCDRiskAssessmentGroupByPayload<T extends NCDRiskAssessmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NCDRiskAssessmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NCDRiskAssessmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NCDRiskAssessmentGroupByOutputType[P]>
            : GetScalarType<T[P], NCDRiskAssessmentGroupByOutputType[P]>
        }
      >
    >


  export type NCDRiskAssessmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    assessmentDate?: boolean
    smokingStatus?: boolean
    alcoholIntake?: boolean
    physicalActivity?: boolean
    fruitVegetableIntake?: boolean
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications?: boolean
    healthEducationReceived?: boolean
    recordedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nCDRiskAssessment"]>



  export type NCDRiskAssessmentSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    assessmentDate?: boolean
    smokingStatus?: boolean
    alcoholIntake?: boolean
    physicalActivity?: boolean
    fruitVegetableIntake?: boolean
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications?: boolean
    healthEducationReceived?: boolean
    recordedBy?: boolean
  }

  export type NCDRiskAssessmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "assessmentDate" | "smokingStatus" | "alcoholIntake" | "physicalActivity" | "fruitVegetableIntake" | "familyHistoryDiabetes" | "familyHistoryHypertension" | "familyHistoryHeartDisease" | "familyHistoryStroke" | "screeningCompleted" | "followUpNeeded" | "lifestyleModifications" | "healthEducationReceived" | "recordedBy", ExtArgs["result"]["nCDRiskAssessment"]>
  export type NCDRiskAssessmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $NCDRiskAssessmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NCDRiskAssessment"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      assessmentDate: Date
      smokingStatus: string | null
      alcoholIntake: string | null
      physicalActivity: string | null
      fruitVegetableIntake: string | null
      familyHistoryDiabetes: boolean
      familyHistoryHypertension: boolean
      familyHistoryHeartDisease: boolean
      familyHistoryStroke: boolean
      screeningCompleted: boolean
      followUpNeeded: boolean
      lifestyleModifications: Prisma.JsonValue
      healthEducationReceived: Prisma.JsonValue
      recordedBy: string
    }, ExtArgs["result"]["nCDRiskAssessment"]>
    composites: {}
  }

  type NCDRiskAssessmentGetPayload<S extends boolean | null | undefined | NCDRiskAssessmentDefaultArgs> = $Result.GetResult<Prisma.$NCDRiskAssessmentPayload, S>

  type NCDRiskAssessmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NCDRiskAssessmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NCDRiskAssessmentCountAggregateInputType | true
    }

  export interface NCDRiskAssessmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NCDRiskAssessment'], meta: { name: 'NCDRiskAssessment' } }
    /**
     * Find zero or one NCDRiskAssessment that matches the filter.
     * @param {NCDRiskAssessmentFindUniqueArgs} args - Arguments to find a NCDRiskAssessment
     * @example
     * // Get one NCDRiskAssessment
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NCDRiskAssessmentFindUniqueArgs>(args: SelectSubset<T, NCDRiskAssessmentFindUniqueArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NCDRiskAssessment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NCDRiskAssessmentFindUniqueOrThrowArgs} args - Arguments to find a NCDRiskAssessment
     * @example
     * // Get one NCDRiskAssessment
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NCDRiskAssessmentFindUniqueOrThrowArgs>(args: SelectSubset<T, NCDRiskAssessmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NCDRiskAssessment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCDRiskAssessmentFindFirstArgs} args - Arguments to find a NCDRiskAssessment
     * @example
     * // Get one NCDRiskAssessment
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NCDRiskAssessmentFindFirstArgs>(args?: SelectSubset<T, NCDRiskAssessmentFindFirstArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NCDRiskAssessment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCDRiskAssessmentFindFirstOrThrowArgs} args - Arguments to find a NCDRiskAssessment
     * @example
     * // Get one NCDRiskAssessment
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NCDRiskAssessmentFindFirstOrThrowArgs>(args?: SelectSubset<T, NCDRiskAssessmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NCDRiskAssessments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCDRiskAssessmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NCDRiskAssessments
     * const nCDRiskAssessments = await prisma.nCDRiskAssessment.findMany()
     * 
     * // Get first 10 NCDRiskAssessments
     * const nCDRiskAssessments = await prisma.nCDRiskAssessment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nCDRiskAssessmentWithIdOnly = await prisma.nCDRiskAssessment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NCDRiskAssessmentFindManyArgs>(args?: SelectSubset<T, NCDRiskAssessmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NCDRiskAssessment.
     * @param {NCDRiskAssessmentCreateArgs} args - Arguments to create a NCDRiskAssessment.
     * @example
     * // Create one NCDRiskAssessment
     * const NCDRiskAssessment = await prisma.nCDRiskAssessment.create({
     *   data: {
     *     // ... data to create a NCDRiskAssessment
     *   }
     * })
     * 
     */
    create<T extends NCDRiskAssessmentCreateArgs>(args: SelectSubset<T, NCDRiskAssessmentCreateArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NCDRiskAssessments.
     * @param {NCDRiskAssessmentCreateManyArgs} args - Arguments to create many NCDRiskAssessments.
     * @example
     * // Create many NCDRiskAssessments
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NCDRiskAssessmentCreateManyArgs>(args?: SelectSubset<T, NCDRiskAssessmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NCDRiskAssessment.
     * @param {NCDRiskAssessmentDeleteArgs} args - Arguments to delete one NCDRiskAssessment.
     * @example
     * // Delete one NCDRiskAssessment
     * const NCDRiskAssessment = await prisma.nCDRiskAssessment.delete({
     *   where: {
     *     // ... filter to delete one NCDRiskAssessment
     *   }
     * })
     * 
     */
    delete<T extends NCDRiskAssessmentDeleteArgs>(args: SelectSubset<T, NCDRiskAssessmentDeleteArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NCDRiskAssessment.
     * @param {NCDRiskAssessmentUpdateArgs} args - Arguments to update one NCDRiskAssessment.
     * @example
     * // Update one NCDRiskAssessment
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NCDRiskAssessmentUpdateArgs>(args: SelectSubset<T, NCDRiskAssessmentUpdateArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NCDRiskAssessments.
     * @param {NCDRiskAssessmentDeleteManyArgs} args - Arguments to filter NCDRiskAssessments to delete.
     * @example
     * // Delete a few NCDRiskAssessments
     * const { count } = await prisma.nCDRiskAssessment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NCDRiskAssessmentDeleteManyArgs>(args?: SelectSubset<T, NCDRiskAssessmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NCDRiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCDRiskAssessmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NCDRiskAssessments
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NCDRiskAssessmentUpdateManyArgs>(args: SelectSubset<T, NCDRiskAssessmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NCDRiskAssessment.
     * @param {NCDRiskAssessmentUpsertArgs} args - Arguments to update or create a NCDRiskAssessment.
     * @example
     * // Update or create a NCDRiskAssessment
     * const nCDRiskAssessment = await prisma.nCDRiskAssessment.upsert({
     *   create: {
     *     // ... data to create a NCDRiskAssessment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NCDRiskAssessment we want to update
     *   }
     * })
     */
    upsert<T extends NCDRiskAssessmentUpsertArgs>(args: SelectSubset<T, NCDRiskAssessmentUpsertArgs<ExtArgs>>): Prisma__NCDRiskAssessmentClient<$Result.GetResult<Prisma.$NCDRiskAssessmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NCDRiskAssessments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCDRiskAssessmentCountArgs} args - Arguments to filter NCDRiskAssessments to count.
     * @example
     * // Count the number of NCDRiskAssessments
     * const count = await prisma.nCDRiskAssessment.count({
     *   where: {
     *     // ... the filter for the NCDRiskAssessments we want to count
     *   }
     * })
    **/
    count<T extends NCDRiskAssessmentCountArgs>(
      args?: Subset<T, NCDRiskAssessmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NCDRiskAssessmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NCDRiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCDRiskAssessmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NCDRiskAssessmentAggregateArgs>(args: Subset<T, NCDRiskAssessmentAggregateArgs>): Prisma.PrismaPromise<GetNCDRiskAssessmentAggregateType<T>>

    /**
     * Group by NCDRiskAssessment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NCDRiskAssessmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NCDRiskAssessmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NCDRiskAssessmentGroupByArgs['orderBy'] }
        : { orderBy?: NCDRiskAssessmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NCDRiskAssessmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNCDRiskAssessmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NCDRiskAssessment model
   */
  readonly fields: NCDRiskAssessmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NCDRiskAssessment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NCDRiskAssessmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NCDRiskAssessment model
   */
  interface NCDRiskAssessmentFieldRefs {
    readonly id: FieldRef<"NCDRiskAssessment", 'String'>
    readonly userProfileId: FieldRef<"NCDRiskAssessment", 'String'>
    readonly assessmentDate: FieldRef<"NCDRiskAssessment", 'DateTime'>
    readonly smokingStatus: FieldRef<"NCDRiskAssessment", 'String'>
    readonly alcoholIntake: FieldRef<"NCDRiskAssessment", 'String'>
    readonly physicalActivity: FieldRef<"NCDRiskAssessment", 'String'>
    readonly fruitVegetableIntake: FieldRef<"NCDRiskAssessment", 'String'>
    readonly familyHistoryDiabetes: FieldRef<"NCDRiskAssessment", 'Boolean'>
    readonly familyHistoryHypertension: FieldRef<"NCDRiskAssessment", 'Boolean'>
    readonly familyHistoryHeartDisease: FieldRef<"NCDRiskAssessment", 'Boolean'>
    readonly familyHistoryStroke: FieldRef<"NCDRiskAssessment", 'Boolean'>
    readonly screeningCompleted: FieldRef<"NCDRiskAssessment", 'Boolean'>
    readonly followUpNeeded: FieldRef<"NCDRiskAssessment", 'Boolean'>
    readonly lifestyleModifications: FieldRef<"NCDRiskAssessment", 'Json'>
    readonly healthEducationReceived: FieldRef<"NCDRiskAssessment", 'Json'>
    readonly recordedBy: FieldRef<"NCDRiskAssessment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NCDRiskAssessment findUnique
   */
  export type NCDRiskAssessmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NCDRiskAssessment to fetch.
     */
    where: NCDRiskAssessmentWhereUniqueInput
  }

  /**
   * NCDRiskAssessment findUniqueOrThrow
   */
  export type NCDRiskAssessmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NCDRiskAssessment to fetch.
     */
    where: NCDRiskAssessmentWhereUniqueInput
  }

  /**
   * NCDRiskAssessment findFirst
   */
  export type NCDRiskAssessmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NCDRiskAssessment to fetch.
     */
    where?: NCDRiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NCDRiskAssessments to fetch.
     */
    orderBy?: NCDRiskAssessmentOrderByWithRelationInput | NCDRiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NCDRiskAssessments.
     */
    cursor?: NCDRiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NCDRiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NCDRiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NCDRiskAssessments.
     */
    distinct?: NCDRiskAssessmentScalarFieldEnum | NCDRiskAssessmentScalarFieldEnum[]
  }

  /**
   * NCDRiskAssessment findFirstOrThrow
   */
  export type NCDRiskAssessmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NCDRiskAssessment to fetch.
     */
    where?: NCDRiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NCDRiskAssessments to fetch.
     */
    orderBy?: NCDRiskAssessmentOrderByWithRelationInput | NCDRiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NCDRiskAssessments.
     */
    cursor?: NCDRiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NCDRiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NCDRiskAssessments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NCDRiskAssessments.
     */
    distinct?: NCDRiskAssessmentScalarFieldEnum | NCDRiskAssessmentScalarFieldEnum[]
  }

  /**
   * NCDRiskAssessment findMany
   */
  export type NCDRiskAssessmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter, which NCDRiskAssessments to fetch.
     */
    where?: NCDRiskAssessmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NCDRiskAssessments to fetch.
     */
    orderBy?: NCDRiskAssessmentOrderByWithRelationInput | NCDRiskAssessmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NCDRiskAssessments.
     */
    cursor?: NCDRiskAssessmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NCDRiskAssessments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NCDRiskAssessments.
     */
    skip?: number
    distinct?: NCDRiskAssessmentScalarFieldEnum | NCDRiskAssessmentScalarFieldEnum[]
  }

  /**
   * NCDRiskAssessment create
   */
  export type NCDRiskAssessmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to create a NCDRiskAssessment.
     */
    data: XOR<NCDRiskAssessmentCreateInput, NCDRiskAssessmentUncheckedCreateInput>
  }

  /**
   * NCDRiskAssessment createMany
   */
  export type NCDRiskAssessmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NCDRiskAssessments.
     */
    data: NCDRiskAssessmentCreateManyInput | NCDRiskAssessmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NCDRiskAssessment update
   */
  export type NCDRiskAssessmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * The data needed to update a NCDRiskAssessment.
     */
    data: XOR<NCDRiskAssessmentUpdateInput, NCDRiskAssessmentUncheckedUpdateInput>
    /**
     * Choose, which NCDRiskAssessment to update.
     */
    where: NCDRiskAssessmentWhereUniqueInput
  }

  /**
   * NCDRiskAssessment updateMany
   */
  export type NCDRiskAssessmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NCDRiskAssessments.
     */
    data: XOR<NCDRiskAssessmentUpdateManyMutationInput, NCDRiskAssessmentUncheckedUpdateManyInput>
    /**
     * Filter which NCDRiskAssessments to update
     */
    where?: NCDRiskAssessmentWhereInput
    /**
     * Limit how many NCDRiskAssessments to update.
     */
    limit?: number
  }

  /**
   * NCDRiskAssessment upsert
   */
  export type NCDRiskAssessmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * The filter to search for the NCDRiskAssessment to update in case it exists.
     */
    where: NCDRiskAssessmentWhereUniqueInput
    /**
     * In case the NCDRiskAssessment found by the `where` argument doesn't exist, create a new NCDRiskAssessment with this data.
     */
    create: XOR<NCDRiskAssessmentCreateInput, NCDRiskAssessmentUncheckedCreateInput>
    /**
     * In case the NCDRiskAssessment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NCDRiskAssessmentUpdateInput, NCDRiskAssessmentUncheckedUpdateInput>
  }

  /**
   * NCDRiskAssessment delete
   */
  export type NCDRiskAssessmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
    /**
     * Filter which NCDRiskAssessment to delete.
     */
    where: NCDRiskAssessmentWhereUniqueInput
  }

  /**
   * NCDRiskAssessment deleteMany
   */
  export type NCDRiskAssessmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NCDRiskAssessments to delete
     */
    where?: NCDRiskAssessmentWhereInput
    /**
     * Limit how many NCDRiskAssessments to delete.
     */
    limit?: number
  }

  /**
   * NCDRiskAssessment without action
   */
  export type NCDRiskAssessmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NCDRiskAssessment
     */
    select?: NCDRiskAssessmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NCDRiskAssessment
     */
    omit?: NCDRiskAssessmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NCDRiskAssessmentInclude<ExtArgs> | null
  }


  /**
   * Model VisitRecord
   */

  export type AggregateVisitRecord = {
    _count: VisitRecordCountAggregateOutputType | null
    _min: VisitRecordMinAggregateOutputType | null
    _max: VisitRecordMaxAggregateOutputType | null
  }

  export type VisitRecordMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    visitDate: Date | null
    visitType: string | null
    visitFrequency: string | null
    referred: boolean | null
    facilityName: string | null
    referralReason: string | null
    recordedBy: string | null
  }

  export type VisitRecordMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    visitDate: Date | null
    visitType: string | null
    visitFrequency: string | null
    referred: boolean | null
    facilityName: string | null
    referralReason: string | null
    recordedBy: string | null
  }

  export type VisitRecordCountAggregateOutputType = {
    id: number
    userProfileId: number
    visitDate: number
    visitType: number
    visitFrequency: number
    referred: number
    facilityName: number
    referralReason: number
    recordedBy: number
    _all: number
  }


  export type VisitRecordMinAggregateInputType = {
    id?: true
    userProfileId?: true
    visitDate?: true
    visitType?: true
    visitFrequency?: true
    referred?: true
    facilityName?: true
    referralReason?: true
    recordedBy?: true
  }

  export type VisitRecordMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    visitDate?: true
    visitType?: true
    visitFrequency?: true
    referred?: true
    facilityName?: true
    referralReason?: true
    recordedBy?: true
  }

  export type VisitRecordCountAggregateInputType = {
    id?: true
    userProfileId?: true
    visitDate?: true
    visitType?: true
    visitFrequency?: true
    referred?: true
    facilityName?: true
    referralReason?: true
    recordedBy?: true
    _all?: true
  }

  export type VisitRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitRecord to aggregate.
     */
    where?: VisitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitRecords to fetch.
     */
    orderBy?: VisitRecordOrderByWithRelationInput | VisitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisitRecords
    **/
    _count?: true | VisitRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisitRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisitRecordMaxAggregateInputType
  }

  export type GetVisitRecordAggregateType<T extends VisitRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateVisitRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisitRecord[P]>
      : GetScalarType<T[P], AggregateVisitRecord[P]>
  }




  export type VisitRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisitRecordWhereInput
    orderBy?: VisitRecordOrderByWithAggregationInput | VisitRecordOrderByWithAggregationInput[]
    by: VisitRecordScalarFieldEnum[] | VisitRecordScalarFieldEnum
    having?: VisitRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisitRecordCountAggregateInputType | true
    _min?: VisitRecordMinAggregateInputType
    _max?: VisitRecordMaxAggregateInputType
  }

  export type VisitRecordGroupByOutputType = {
    id: string
    userProfileId: string
    visitDate: Date
    visitType: string
    visitFrequency: string | null
    referred: boolean
    facilityName: string | null
    referralReason: string | null
    recordedBy: string
    _count: VisitRecordCountAggregateOutputType | null
    _min: VisitRecordMinAggregateOutputType | null
    _max: VisitRecordMaxAggregateOutputType | null
  }

  type GetVisitRecordGroupByPayload<T extends VisitRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisitRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisitRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisitRecordGroupByOutputType[P]>
            : GetScalarType<T[P], VisitRecordGroupByOutputType[P]>
        }
      >
    >


  export type VisitRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    visitDate?: boolean
    visitType?: boolean
    visitFrequency?: boolean
    referred?: boolean
    facilityName?: boolean
    referralReason?: boolean
    recordedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visitRecord"]>



  export type VisitRecordSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    visitDate?: boolean
    visitType?: boolean
    visitFrequency?: boolean
    referred?: boolean
    facilityName?: boolean
    referralReason?: boolean
    recordedBy?: boolean
  }

  export type VisitRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "visitDate" | "visitType" | "visitFrequency" | "referred" | "facilityName" | "referralReason" | "recordedBy", ExtArgs["result"]["visitRecord"]>
  export type VisitRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $VisitRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisitRecord"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      visitDate: Date
      visitType: string
      visitFrequency: string | null
      referred: boolean
      facilityName: string | null
      referralReason: string | null
      recordedBy: string
    }, ExtArgs["result"]["visitRecord"]>
    composites: {}
  }

  type VisitRecordGetPayload<S extends boolean | null | undefined | VisitRecordDefaultArgs> = $Result.GetResult<Prisma.$VisitRecordPayload, S>

  type VisitRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisitRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisitRecordCountAggregateInputType | true
    }

  export interface VisitRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisitRecord'], meta: { name: 'VisitRecord' } }
    /**
     * Find zero or one VisitRecord that matches the filter.
     * @param {VisitRecordFindUniqueArgs} args - Arguments to find a VisitRecord
     * @example
     * // Get one VisitRecord
     * const visitRecord = await prisma.visitRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisitRecordFindUniqueArgs>(args: SelectSubset<T, VisitRecordFindUniqueArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisitRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisitRecordFindUniqueOrThrowArgs} args - Arguments to find a VisitRecord
     * @example
     * // Get one VisitRecord
     * const visitRecord = await prisma.visitRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisitRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, VisitRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitRecordFindFirstArgs} args - Arguments to find a VisitRecord
     * @example
     * // Get one VisitRecord
     * const visitRecord = await prisma.visitRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisitRecordFindFirstArgs>(args?: SelectSubset<T, VisitRecordFindFirstArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisitRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitRecordFindFirstOrThrowArgs} args - Arguments to find a VisitRecord
     * @example
     * // Get one VisitRecord
     * const visitRecord = await prisma.visitRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisitRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, VisitRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisitRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisitRecords
     * const visitRecords = await prisma.visitRecord.findMany()
     * 
     * // Get first 10 VisitRecords
     * const visitRecords = await prisma.visitRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const visitRecordWithIdOnly = await prisma.visitRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VisitRecordFindManyArgs>(args?: SelectSubset<T, VisitRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisitRecord.
     * @param {VisitRecordCreateArgs} args - Arguments to create a VisitRecord.
     * @example
     * // Create one VisitRecord
     * const VisitRecord = await prisma.visitRecord.create({
     *   data: {
     *     // ... data to create a VisitRecord
     *   }
     * })
     * 
     */
    create<T extends VisitRecordCreateArgs>(args: SelectSubset<T, VisitRecordCreateArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisitRecords.
     * @param {VisitRecordCreateManyArgs} args - Arguments to create many VisitRecords.
     * @example
     * // Create many VisitRecords
     * const visitRecord = await prisma.visitRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisitRecordCreateManyArgs>(args?: SelectSubset<T, VisitRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VisitRecord.
     * @param {VisitRecordDeleteArgs} args - Arguments to delete one VisitRecord.
     * @example
     * // Delete one VisitRecord
     * const VisitRecord = await prisma.visitRecord.delete({
     *   where: {
     *     // ... filter to delete one VisitRecord
     *   }
     * })
     * 
     */
    delete<T extends VisitRecordDeleteArgs>(args: SelectSubset<T, VisitRecordDeleteArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisitRecord.
     * @param {VisitRecordUpdateArgs} args - Arguments to update one VisitRecord.
     * @example
     * // Update one VisitRecord
     * const visitRecord = await prisma.visitRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisitRecordUpdateArgs>(args: SelectSubset<T, VisitRecordUpdateArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisitRecords.
     * @param {VisitRecordDeleteManyArgs} args - Arguments to filter VisitRecords to delete.
     * @example
     * // Delete a few VisitRecords
     * const { count } = await prisma.visitRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisitRecordDeleteManyArgs>(args?: SelectSubset<T, VisitRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisitRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisitRecords
     * const visitRecord = await prisma.visitRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisitRecordUpdateManyArgs>(args: SelectSubset<T, VisitRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisitRecord.
     * @param {VisitRecordUpsertArgs} args - Arguments to update or create a VisitRecord.
     * @example
     * // Update or create a VisitRecord
     * const visitRecord = await prisma.visitRecord.upsert({
     *   create: {
     *     // ... data to create a VisitRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisitRecord we want to update
     *   }
     * })
     */
    upsert<T extends VisitRecordUpsertArgs>(args: SelectSubset<T, VisitRecordUpsertArgs<ExtArgs>>): Prisma__VisitRecordClient<$Result.GetResult<Prisma.$VisitRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisitRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitRecordCountArgs} args - Arguments to filter VisitRecords to count.
     * @example
     * // Count the number of VisitRecords
     * const count = await prisma.visitRecord.count({
     *   where: {
     *     // ... the filter for the VisitRecords we want to count
     *   }
     * })
    **/
    count<T extends VisitRecordCountArgs>(
      args?: Subset<T, VisitRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisitRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisitRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisitRecordAggregateArgs>(args: Subset<T, VisitRecordAggregateArgs>): Prisma.PrismaPromise<GetVisitRecordAggregateType<T>>

    /**
     * Group by VisitRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisitRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisitRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisitRecordGroupByArgs['orderBy'] }
        : { orderBy?: VisitRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisitRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisitRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisitRecord model
   */
  readonly fields: VisitRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisitRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisitRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisitRecord model
   */
  interface VisitRecordFieldRefs {
    readonly id: FieldRef<"VisitRecord", 'String'>
    readonly userProfileId: FieldRef<"VisitRecord", 'String'>
    readonly visitDate: FieldRef<"VisitRecord", 'DateTime'>
    readonly visitType: FieldRef<"VisitRecord", 'String'>
    readonly visitFrequency: FieldRef<"VisitRecord", 'String'>
    readonly referred: FieldRef<"VisitRecord", 'Boolean'>
    readonly facilityName: FieldRef<"VisitRecord", 'String'>
    readonly referralReason: FieldRef<"VisitRecord", 'String'>
    readonly recordedBy: FieldRef<"VisitRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VisitRecord findUnique
   */
  export type VisitRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * Filter, which VisitRecord to fetch.
     */
    where: VisitRecordWhereUniqueInput
  }

  /**
   * VisitRecord findUniqueOrThrow
   */
  export type VisitRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * Filter, which VisitRecord to fetch.
     */
    where: VisitRecordWhereUniqueInput
  }

  /**
   * VisitRecord findFirst
   */
  export type VisitRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * Filter, which VisitRecord to fetch.
     */
    where?: VisitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitRecords to fetch.
     */
    orderBy?: VisitRecordOrderByWithRelationInput | VisitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitRecords.
     */
    cursor?: VisitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitRecords.
     */
    distinct?: VisitRecordScalarFieldEnum | VisitRecordScalarFieldEnum[]
  }

  /**
   * VisitRecord findFirstOrThrow
   */
  export type VisitRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * Filter, which VisitRecord to fetch.
     */
    where?: VisitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitRecords to fetch.
     */
    orderBy?: VisitRecordOrderByWithRelationInput | VisitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisitRecords.
     */
    cursor?: VisitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisitRecords.
     */
    distinct?: VisitRecordScalarFieldEnum | VisitRecordScalarFieldEnum[]
  }

  /**
   * VisitRecord findMany
   */
  export type VisitRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * Filter, which VisitRecords to fetch.
     */
    where?: VisitRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisitRecords to fetch.
     */
    orderBy?: VisitRecordOrderByWithRelationInput | VisitRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisitRecords.
     */
    cursor?: VisitRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisitRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisitRecords.
     */
    skip?: number
    distinct?: VisitRecordScalarFieldEnum | VisitRecordScalarFieldEnum[]
  }

  /**
   * VisitRecord create
   */
  export type VisitRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a VisitRecord.
     */
    data: XOR<VisitRecordCreateInput, VisitRecordUncheckedCreateInput>
  }

  /**
   * VisitRecord createMany
   */
  export type VisitRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisitRecords.
     */
    data: VisitRecordCreateManyInput | VisitRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisitRecord update
   */
  export type VisitRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a VisitRecord.
     */
    data: XOR<VisitRecordUpdateInput, VisitRecordUncheckedUpdateInput>
    /**
     * Choose, which VisitRecord to update.
     */
    where: VisitRecordWhereUniqueInput
  }

  /**
   * VisitRecord updateMany
   */
  export type VisitRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisitRecords.
     */
    data: XOR<VisitRecordUpdateManyMutationInput, VisitRecordUncheckedUpdateManyInput>
    /**
     * Filter which VisitRecords to update
     */
    where?: VisitRecordWhereInput
    /**
     * Limit how many VisitRecords to update.
     */
    limit?: number
  }

  /**
   * VisitRecord upsert
   */
  export type VisitRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the VisitRecord to update in case it exists.
     */
    where: VisitRecordWhereUniqueInput
    /**
     * In case the VisitRecord found by the `where` argument doesn't exist, create a new VisitRecord with this data.
     */
    create: XOR<VisitRecordCreateInput, VisitRecordUncheckedCreateInput>
    /**
     * In case the VisitRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisitRecordUpdateInput, VisitRecordUncheckedUpdateInput>
  }

  /**
   * VisitRecord delete
   */
  export type VisitRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
    /**
     * Filter which VisitRecord to delete.
     */
    where: VisitRecordWhereUniqueInput
  }

  /**
   * VisitRecord deleteMany
   */
  export type VisitRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisitRecords to delete
     */
    where?: VisitRecordWhereInput
    /**
     * Limit how many VisitRecords to delete.
     */
    limit?: number
  }

  /**
   * VisitRecord without action
   */
  export type VisitRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisitRecord
     */
    select?: VisitRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisitRecord
     */
    omit?: VisitRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisitRecordInclude<ExtArgs> | null
  }


  /**
   * Model HealthEducation
   */

  export type AggregateHealthEducation = {
    _count: HealthEducationCountAggregateOutputType | null
    _min: HealthEducationMinAggregateOutputType | null
    _max: HealthEducationMaxAggregateOutputType | null
  }

  export type HealthEducationMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    dateProvided: Date | null
    providedBy: string | null
  }

  export type HealthEducationMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    dateProvided: Date | null
    providedBy: string | null
  }

  export type HealthEducationCountAggregateOutputType = {
    id: number
    userProfileId: number
    topicsCovered: number
    dateProvided: number
    providedBy: number
    _all: number
  }


  export type HealthEducationMinAggregateInputType = {
    id?: true
    userProfileId?: true
    dateProvided?: true
    providedBy?: true
  }

  export type HealthEducationMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    dateProvided?: true
    providedBy?: true
  }

  export type HealthEducationCountAggregateInputType = {
    id?: true
    userProfileId?: true
    topicsCovered?: true
    dateProvided?: true
    providedBy?: true
    _all?: true
  }

  export type HealthEducationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthEducation to aggregate.
     */
    where?: HealthEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEducations to fetch.
     */
    orderBy?: HealthEducationOrderByWithRelationInput | HealthEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthEducations
    **/
    _count?: true | HealthEducationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthEducationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthEducationMaxAggregateInputType
  }

  export type GetHealthEducationAggregateType<T extends HealthEducationAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthEducation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthEducation[P]>
      : GetScalarType<T[P], AggregateHealthEducation[P]>
  }




  export type HealthEducationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthEducationWhereInput
    orderBy?: HealthEducationOrderByWithAggregationInput | HealthEducationOrderByWithAggregationInput[]
    by: HealthEducationScalarFieldEnum[] | HealthEducationScalarFieldEnum
    having?: HealthEducationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthEducationCountAggregateInputType | true
    _min?: HealthEducationMinAggregateInputType
    _max?: HealthEducationMaxAggregateInputType
  }

  export type HealthEducationGroupByOutputType = {
    id: string
    userProfileId: string
    topicsCovered: JsonValue
    dateProvided: Date
    providedBy: string
    _count: HealthEducationCountAggregateOutputType | null
    _min: HealthEducationMinAggregateOutputType | null
    _max: HealthEducationMaxAggregateOutputType | null
  }

  type GetHealthEducationGroupByPayload<T extends HealthEducationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthEducationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthEducationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthEducationGroupByOutputType[P]>
            : GetScalarType<T[P], HealthEducationGroupByOutputType[P]>
        }
      >
    >


  export type HealthEducationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    topicsCovered?: boolean
    dateProvided?: boolean
    providedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthEducation"]>



  export type HealthEducationSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    topicsCovered?: boolean
    dateProvided?: boolean
    providedBy?: boolean
  }

  export type HealthEducationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "topicsCovered" | "dateProvided" | "providedBy", ExtArgs["result"]["healthEducation"]>
  export type HealthEducationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $HealthEducationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthEducation"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      topicsCovered: Prisma.JsonValue
      dateProvided: Date
      providedBy: string
    }, ExtArgs["result"]["healthEducation"]>
    composites: {}
  }

  type HealthEducationGetPayload<S extends boolean | null | undefined | HealthEducationDefaultArgs> = $Result.GetResult<Prisma.$HealthEducationPayload, S>

  type HealthEducationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HealthEducationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HealthEducationCountAggregateInputType | true
    }

  export interface HealthEducationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthEducation'], meta: { name: 'HealthEducation' } }
    /**
     * Find zero or one HealthEducation that matches the filter.
     * @param {HealthEducationFindUniqueArgs} args - Arguments to find a HealthEducation
     * @example
     * // Get one HealthEducation
     * const healthEducation = await prisma.healthEducation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthEducationFindUniqueArgs>(args: SelectSubset<T, HealthEducationFindUniqueArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HealthEducation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HealthEducationFindUniqueOrThrowArgs} args - Arguments to find a HealthEducation
     * @example
     * // Get one HealthEducation
     * const healthEducation = await prisma.healthEducation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthEducationFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthEducationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthEducation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEducationFindFirstArgs} args - Arguments to find a HealthEducation
     * @example
     * // Get one HealthEducation
     * const healthEducation = await prisma.healthEducation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthEducationFindFirstArgs>(args?: SelectSubset<T, HealthEducationFindFirstArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthEducation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEducationFindFirstOrThrowArgs} args - Arguments to find a HealthEducation
     * @example
     * // Get one HealthEducation
     * const healthEducation = await prisma.healthEducation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthEducationFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthEducationFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HealthEducations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEducationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthEducations
     * const healthEducations = await prisma.healthEducation.findMany()
     * 
     * // Get first 10 HealthEducations
     * const healthEducations = await prisma.healthEducation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthEducationWithIdOnly = await prisma.healthEducation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthEducationFindManyArgs>(args?: SelectSubset<T, HealthEducationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HealthEducation.
     * @param {HealthEducationCreateArgs} args - Arguments to create a HealthEducation.
     * @example
     * // Create one HealthEducation
     * const HealthEducation = await prisma.healthEducation.create({
     *   data: {
     *     // ... data to create a HealthEducation
     *   }
     * })
     * 
     */
    create<T extends HealthEducationCreateArgs>(args: SelectSubset<T, HealthEducationCreateArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HealthEducations.
     * @param {HealthEducationCreateManyArgs} args - Arguments to create many HealthEducations.
     * @example
     * // Create many HealthEducations
     * const healthEducation = await prisma.healthEducation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthEducationCreateManyArgs>(args?: SelectSubset<T, HealthEducationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HealthEducation.
     * @param {HealthEducationDeleteArgs} args - Arguments to delete one HealthEducation.
     * @example
     * // Delete one HealthEducation
     * const HealthEducation = await prisma.healthEducation.delete({
     *   where: {
     *     // ... filter to delete one HealthEducation
     *   }
     * })
     * 
     */
    delete<T extends HealthEducationDeleteArgs>(args: SelectSubset<T, HealthEducationDeleteArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HealthEducation.
     * @param {HealthEducationUpdateArgs} args - Arguments to update one HealthEducation.
     * @example
     * // Update one HealthEducation
     * const healthEducation = await prisma.healthEducation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthEducationUpdateArgs>(args: SelectSubset<T, HealthEducationUpdateArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HealthEducations.
     * @param {HealthEducationDeleteManyArgs} args - Arguments to filter HealthEducations to delete.
     * @example
     * // Delete a few HealthEducations
     * const { count } = await prisma.healthEducation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthEducationDeleteManyArgs>(args?: SelectSubset<T, HealthEducationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEducationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthEducations
     * const healthEducation = await prisma.healthEducation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthEducationUpdateManyArgs>(args: SelectSubset<T, HealthEducationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthEducation.
     * @param {HealthEducationUpsertArgs} args - Arguments to update or create a HealthEducation.
     * @example
     * // Update or create a HealthEducation
     * const healthEducation = await prisma.healthEducation.upsert({
     *   create: {
     *     // ... data to create a HealthEducation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthEducation we want to update
     *   }
     * })
     */
    upsert<T extends HealthEducationUpsertArgs>(args: SelectSubset<T, HealthEducationUpsertArgs<ExtArgs>>): Prisma__HealthEducationClient<$Result.GetResult<Prisma.$HealthEducationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HealthEducations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEducationCountArgs} args - Arguments to filter HealthEducations to count.
     * @example
     * // Count the number of HealthEducations
     * const count = await prisma.healthEducation.count({
     *   where: {
     *     // ... the filter for the HealthEducations we want to count
     *   }
     * })
    **/
    count<T extends HealthEducationCountArgs>(
      args?: Subset<T, HealthEducationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthEducationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEducationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthEducationAggregateArgs>(args: Subset<T, HealthEducationAggregateArgs>): Prisma.PrismaPromise<GetHealthEducationAggregateType<T>>

    /**
     * Group by HealthEducation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthEducationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthEducationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthEducationGroupByArgs['orderBy'] }
        : { orderBy?: HealthEducationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthEducationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthEducationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthEducation model
   */
  readonly fields: HealthEducationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthEducation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthEducationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthEducation model
   */
  interface HealthEducationFieldRefs {
    readonly id: FieldRef<"HealthEducation", 'String'>
    readonly userProfileId: FieldRef<"HealthEducation", 'String'>
    readonly topicsCovered: FieldRef<"HealthEducation", 'Json'>
    readonly dateProvided: FieldRef<"HealthEducation", 'DateTime'>
    readonly providedBy: FieldRef<"HealthEducation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HealthEducation findUnique
   */
  export type HealthEducationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * Filter, which HealthEducation to fetch.
     */
    where: HealthEducationWhereUniqueInput
  }

  /**
   * HealthEducation findUniqueOrThrow
   */
  export type HealthEducationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * Filter, which HealthEducation to fetch.
     */
    where: HealthEducationWhereUniqueInput
  }

  /**
   * HealthEducation findFirst
   */
  export type HealthEducationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * Filter, which HealthEducation to fetch.
     */
    where?: HealthEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEducations to fetch.
     */
    orderBy?: HealthEducationOrderByWithRelationInput | HealthEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthEducations.
     */
    cursor?: HealthEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthEducations.
     */
    distinct?: HealthEducationScalarFieldEnum | HealthEducationScalarFieldEnum[]
  }

  /**
   * HealthEducation findFirstOrThrow
   */
  export type HealthEducationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * Filter, which HealthEducation to fetch.
     */
    where?: HealthEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEducations to fetch.
     */
    orderBy?: HealthEducationOrderByWithRelationInput | HealthEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthEducations.
     */
    cursor?: HealthEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEducations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthEducations.
     */
    distinct?: HealthEducationScalarFieldEnum | HealthEducationScalarFieldEnum[]
  }

  /**
   * HealthEducation findMany
   */
  export type HealthEducationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * Filter, which HealthEducations to fetch.
     */
    where?: HealthEducationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthEducations to fetch.
     */
    orderBy?: HealthEducationOrderByWithRelationInput | HealthEducationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthEducations.
     */
    cursor?: HealthEducationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthEducations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthEducations.
     */
    skip?: number
    distinct?: HealthEducationScalarFieldEnum | HealthEducationScalarFieldEnum[]
  }

  /**
   * HealthEducation create
   */
  export type HealthEducationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthEducation.
     */
    data: XOR<HealthEducationCreateInput, HealthEducationUncheckedCreateInput>
  }

  /**
   * HealthEducation createMany
   */
  export type HealthEducationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthEducations.
     */
    data: HealthEducationCreateManyInput | HealthEducationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HealthEducation update
   */
  export type HealthEducationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthEducation.
     */
    data: XOR<HealthEducationUpdateInput, HealthEducationUncheckedUpdateInput>
    /**
     * Choose, which HealthEducation to update.
     */
    where: HealthEducationWhereUniqueInput
  }

  /**
   * HealthEducation updateMany
   */
  export type HealthEducationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthEducations.
     */
    data: XOR<HealthEducationUpdateManyMutationInput, HealthEducationUncheckedUpdateManyInput>
    /**
     * Filter which HealthEducations to update
     */
    where?: HealthEducationWhereInput
    /**
     * Limit how many HealthEducations to update.
     */
    limit?: number
  }

  /**
   * HealthEducation upsert
   */
  export type HealthEducationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthEducation to update in case it exists.
     */
    where: HealthEducationWhereUniqueInput
    /**
     * In case the HealthEducation found by the `where` argument doesn't exist, create a new HealthEducation with this data.
     */
    create: XOR<HealthEducationCreateInput, HealthEducationUncheckedCreateInput>
    /**
     * In case the HealthEducation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthEducationUpdateInput, HealthEducationUncheckedUpdateInput>
  }

  /**
   * HealthEducation delete
   */
  export type HealthEducationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
    /**
     * Filter which HealthEducation to delete.
     */
    where: HealthEducationWhereUniqueInput
  }

  /**
   * HealthEducation deleteMany
   */
  export type HealthEducationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthEducations to delete
     */
    where?: HealthEducationWhereInput
    /**
     * Limit how many HealthEducations to delete.
     */
    limit?: number
  }

  /**
   * HealthEducation without action
   */
  export type HealthEducationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthEducation
     */
    select?: HealthEducationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthEducation
     */
    omit?: HealthEducationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthEducationInclude<ExtArgs> | null
  }


  /**
   * Model NutritionalCounseling
   */

  export type AggregateNutritionalCounseling = {
    _count: NutritionalCounselingCountAggregateOutputType | null
    _min: NutritionalCounselingMinAggregateOutputType | null
    _max: NutritionalCounselingMaxAggregateOutputType | null
  }

  export type NutritionalCounselingMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    recommendations: string | null
    dateProvided: Date | null
    providedBy: string | null
  }

  export type NutritionalCounselingMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    recommendations: string | null
    dateProvided: Date | null
    providedBy: string | null
  }

  export type NutritionalCounselingCountAggregateOutputType = {
    id: number
    userProfileId: number
    recommendations: number
    dateProvided: number
    providedBy: number
    _all: number
  }


  export type NutritionalCounselingMinAggregateInputType = {
    id?: true
    userProfileId?: true
    recommendations?: true
    dateProvided?: true
    providedBy?: true
  }

  export type NutritionalCounselingMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    recommendations?: true
    dateProvided?: true
    providedBy?: true
  }

  export type NutritionalCounselingCountAggregateInputType = {
    id?: true
    userProfileId?: true
    recommendations?: true
    dateProvided?: true
    providedBy?: true
    _all?: true
  }

  export type NutritionalCounselingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionalCounseling to aggregate.
     */
    where?: NutritionalCounselingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalCounselings to fetch.
     */
    orderBy?: NutritionalCounselingOrderByWithRelationInput | NutritionalCounselingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NutritionalCounselingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalCounselings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalCounselings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionalCounselings
    **/
    _count?: true | NutritionalCounselingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionalCounselingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionalCounselingMaxAggregateInputType
  }

  export type GetNutritionalCounselingAggregateType<T extends NutritionalCounselingAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionalCounseling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionalCounseling[P]>
      : GetScalarType<T[P], AggregateNutritionalCounseling[P]>
  }




  export type NutritionalCounselingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NutritionalCounselingWhereInput
    orderBy?: NutritionalCounselingOrderByWithAggregationInput | NutritionalCounselingOrderByWithAggregationInput[]
    by: NutritionalCounselingScalarFieldEnum[] | NutritionalCounselingScalarFieldEnum
    having?: NutritionalCounselingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionalCounselingCountAggregateInputType | true
    _min?: NutritionalCounselingMinAggregateInputType
    _max?: NutritionalCounselingMaxAggregateInputType
  }

  export type NutritionalCounselingGroupByOutputType = {
    id: string
    userProfileId: string
    recommendations: string
    dateProvided: Date
    providedBy: string
    _count: NutritionalCounselingCountAggregateOutputType | null
    _min: NutritionalCounselingMinAggregateOutputType | null
    _max: NutritionalCounselingMaxAggregateOutputType | null
  }

  type GetNutritionalCounselingGroupByPayload<T extends NutritionalCounselingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NutritionalCounselingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionalCounselingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionalCounselingGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionalCounselingGroupByOutputType[P]>
        }
      >
    >


  export type NutritionalCounselingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    recommendations?: boolean
    dateProvided?: boolean
    providedBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nutritionalCounseling"]>



  export type NutritionalCounselingSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    recommendations?: boolean
    dateProvided?: boolean
    providedBy?: boolean
  }

  export type NutritionalCounselingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "recommendations" | "dateProvided" | "providedBy", ExtArgs["result"]["nutritionalCounseling"]>
  export type NutritionalCounselingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $NutritionalCounselingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NutritionalCounseling"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      recommendations: string
      dateProvided: Date
      providedBy: string
    }, ExtArgs["result"]["nutritionalCounseling"]>
    composites: {}
  }

  type NutritionalCounselingGetPayload<S extends boolean | null | undefined | NutritionalCounselingDefaultArgs> = $Result.GetResult<Prisma.$NutritionalCounselingPayload, S>

  type NutritionalCounselingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NutritionalCounselingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NutritionalCounselingCountAggregateInputType | true
    }

  export interface NutritionalCounselingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NutritionalCounseling'], meta: { name: 'NutritionalCounseling' } }
    /**
     * Find zero or one NutritionalCounseling that matches the filter.
     * @param {NutritionalCounselingFindUniqueArgs} args - Arguments to find a NutritionalCounseling
     * @example
     * // Get one NutritionalCounseling
     * const nutritionalCounseling = await prisma.nutritionalCounseling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NutritionalCounselingFindUniqueArgs>(args: SelectSubset<T, NutritionalCounselingFindUniqueArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NutritionalCounseling that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NutritionalCounselingFindUniqueOrThrowArgs} args - Arguments to find a NutritionalCounseling
     * @example
     * // Get one NutritionalCounseling
     * const nutritionalCounseling = await prisma.nutritionalCounseling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NutritionalCounselingFindUniqueOrThrowArgs>(args: SelectSubset<T, NutritionalCounselingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalCounseling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCounselingFindFirstArgs} args - Arguments to find a NutritionalCounseling
     * @example
     * // Get one NutritionalCounseling
     * const nutritionalCounseling = await prisma.nutritionalCounseling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NutritionalCounselingFindFirstArgs>(args?: SelectSubset<T, NutritionalCounselingFindFirstArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NutritionalCounseling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCounselingFindFirstOrThrowArgs} args - Arguments to find a NutritionalCounseling
     * @example
     * // Get one NutritionalCounseling
     * const nutritionalCounseling = await prisma.nutritionalCounseling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NutritionalCounselingFindFirstOrThrowArgs>(args?: SelectSubset<T, NutritionalCounselingFindFirstOrThrowArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NutritionalCounselings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCounselingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionalCounselings
     * const nutritionalCounselings = await prisma.nutritionalCounseling.findMany()
     * 
     * // Get first 10 NutritionalCounselings
     * const nutritionalCounselings = await prisma.nutritionalCounseling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionalCounselingWithIdOnly = await prisma.nutritionalCounseling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NutritionalCounselingFindManyArgs>(args?: SelectSubset<T, NutritionalCounselingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NutritionalCounseling.
     * @param {NutritionalCounselingCreateArgs} args - Arguments to create a NutritionalCounseling.
     * @example
     * // Create one NutritionalCounseling
     * const NutritionalCounseling = await prisma.nutritionalCounseling.create({
     *   data: {
     *     // ... data to create a NutritionalCounseling
     *   }
     * })
     * 
     */
    create<T extends NutritionalCounselingCreateArgs>(args: SelectSubset<T, NutritionalCounselingCreateArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NutritionalCounselings.
     * @param {NutritionalCounselingCreateManyArgs} args - Arguments to create many NutritionalCounselings.
     * @example
     * // Create many NutritionalCounselings
     * const nutritionalCounseling = await prisma.nutritionalCounseling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NutritionalCounselingCreateManyArgs>(args?: SelectSubset<T, NutritionalCounselingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NutritionalCounseling.
     * @param {NutritionalCounselingDeleteArgs} args - Arguments to delete one NutritionalCounseling.
     * @example
     * // Delete one NutritionalCounseling
     * const NutritionalCounseling = await prisma.nutritionalCounseling.delete({
     *   where: {
     *     // ... filter to delete one NutritionalCounseling
     *   }
     * })
     * 
     */
    delete<T extends NutritionalCounselingDeleteArgs>(args: SelectSubset<T, NutritionalCounselingDeleteArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NutritionalCounseling.
     * @param {NutritionalCounselingUpdateArgs} args - Arguments to update one NutritionalCounseling.
     * @example
     * // Update one NutritionalCounseling
     * const nutritionalCounseling = await prisma.nutritionalCounseling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NutritionalCounselingUpdateArgs>(args: SelectSubset<T, NutritionalCounselingUpdateArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NutritionalCounselings.
     * @param {NutritionalCounselingDeleteManyArgs} args - Arguments to filter NutritionalCounselings to delete.
     * @example
     * // Delete a few NutritionalCounselings
     * const { count } = await prisma.nutritionalCounseling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NutritionalCounselingDeleteManyArgs>(args?: SelectSubset<T, NutritionalCounselingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionalCounselings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCounselingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionalCounselings
     * const nutritionalCounseling = await prisma.nutritionalCounseling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NutritionalCounselingUpdateManyArgs>(args: SelectSubset<T, NutritionalCounselingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NutritionalCounseling.
     * @param {NutritionalCounselingUpsertArgs} args - Arguments to update or create a NutritionalCounseling.
     * @example
     * // Update or create a NutritionalCounseling
     * const nutritionalCounseling = await prisma.nutritionalCounseling.upsert({
     *   create: {
     *     // ... data to create a NutritionalCounseling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionalCounseling we want to update
     *   }
     * })
     */
    upsert<T extends NutritionalCounselingUpsertArgs>(args: SelectSubset<T, NutritionalCounselingUpsertArgs<ExtArgs>>): Prisma__NutritionalCounselingClient<$Result.GetResult<Prisma.$NutritionalCounselingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NutritionalCounselings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCounselingCountArgs} args - Arguments to filter NutritionalCounselings to count.
     * @example
     * // Count the number of NutritionalCounselings
     * const count = await prisma.nutritionalCounseling.count({
     *   where: {
     *     // ... the filter for the NutritionalCounselings we want to count
     *   }
     * })
    **/
    count<T extends NutritionalCounselingCountArgs>(
      args?: Subset<T, NutritionalCounselingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionalCounselingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionalCounseling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCounselingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionalCounselingAggregateArgs>(args: Subset<T, NutritionalCounselingAggregateArgs>): Prisma.PrismaPromise<GetNutritionalCounselingAggregateType<T>>

    /**
     * Group by NutritionalCounseling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionalCounselingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionalCounselingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionalCounselingGroupByArgs['orderBy'] }
        : { orderBy?: NutritionalCounselingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionalCounselingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionalCounselingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NutritionalCounseling model
   */
  readonly fields: NutritionalCounselingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionalCounseling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NutritionalCounselingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NutritionalCounseling model
   */
  interface NutritionalCounselingFieldRefs {
    readonly id: FieldRef<"NutritionalCounseling", 'String'>
    readonly userProfileId: FieldRef<"NutritionalCounseling", 'String'>
    readonly recommendations: FieldRef<"NutritionalCounseling", 'String'>
    readonly dateProvided: FieldRef<"NutritionalCounseling", 'DateTime'>
    readonly providedBy: FieldRef<"NutritionalCounseling", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NutritionalCounseling findUnique
   */
  export type NutritionalCounselingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalCounseling to fetch.
     */
    where: NutritionalCounselingWhereUniqueInput
  }

  /**
   * NutritionalCounseling findUniqueOrThrow
   */
  export type NutritionalCounselingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalCounseling to fetch.
     */
    where: NutritionalCounselingWhereUniqueInput
  }

  /**
   * NutritionalCounseling findFirst
   */
  export type NutritionalCounselingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalCounseling to fetch.
     */
    where?: NutritionalCounselingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalCounselings to fetch.
     */
    orderBy?: NutritionalCounselingOrderByWithRelationInput | NutritionalCounselingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionalCounselings.
     */
    cursor?: NutritionalCounselingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalCounselings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalCounselings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionalCounselings.
     */
    distinct?: NutritionalCounselingScalarFieldEnum | NutritionalCounselingScalarFieldEnum[]
  }

  /**
   * NutritionalCounseling findFirstOrThrow
   */
  export type NutritionalCounselingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalCounseling to fetch.
     */
    where?: NutritionalCounselingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalCounselings to fetch.
     */
    orderBy?: NutritionalCounselingOrderByWithRelationInput | NutritionalCounselingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionalCounselings.
     */
    cursor?: NutritionalCounselingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalCounselings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalCounselings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionalCounselings.
     */
    distinct?: NutritionalCounselingScalarFieldEnum | NutritionalCounselingScalarFieldEnum[]
  }

  /**
   * NutritionalCounseling findMany
   */
  export type NutritionalCounselingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * Filter, which NutritionalCounselings to fetch.
     */
    where?: NutritionalCounselingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionalCounselings to fetch.
     */
    orderBy?: NutritionalCounselingOrderByWithRelationInput | NutritionalCounselingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionalCounselings.
     */
    cursor?: NutritionalCounselingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionalCounselings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionalCounselings.
     */
    skip?: number
    distinct?: NutritionalCounselingScalarFieldEnum | NutritionalCounselingScalarFieldEnum[]
  }

  /**
   * NutritionalCounseling create
   */
  export type NutritionalCounselingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * The data needed to create a NutritionalCounseling.
     */
    data: XOR<NutritionalCounselingCreateInput, NutritionalCounselingUncheckedCreateInput>
  }

  /**
   * NutritionalCounseling createMany
   */
  export type NutritionalCounselingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NutritionalCounselings.
     */
    data: NutritionalCounselingCreateManyInput | NutritionalCounselingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NutritionalCounseling update
   */
  export type NutritionalCounselingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * The data needed to update a NutritionalCounseling.
     */
    data: XOR<NutritionalCounselingUpdateInput, NutritionalCounselingUncheckedUpdateInput>
    /**
     * Choose, which NutritionalCounseling to update.
     */
    where: NutritionalCounselingWhereUniqueInput
  }

  /**
   * NutritionalCounseling updateMany
   */
  export type NutritionalCounselingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NutritionalCounselings.
     */
    data: XOR<NutritionalCounselingUpdateManyMutationInput, NutritionalCounselingUncheckedUpdateManyInput>
    /**
     * Filter which NutritionalCounselings to update
     */
    where?: NutritionalCounselingWhereInput
    /**
     * Limit how many NutritionalCounselings to update.
     */
    limit?: number
  }

  /**
   * NutritionalCounseling upsert
   */
  export type NutritionalCounselingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * The filter to search for the NutritionalCounseling to update in case it exists.
     */
    where: NutritionalCounselingWhereUniqueInput
    /**
     * In case the NutritionalCounseling found by the `where` argument doesn't exist, create a new NutritionalCounseling with this data.
     */
    create: XOR<NutritionalCounselingCreateInput, NutritionalCounselingUncheckedCreateInput>
    /**
     * In case the NutritionalCounseling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NutritionalCounselingUpdateInput, NutritionalCounselingUncheckedUpdateInput>
  }

  /**
   * NutritionalCounseling delete
   */
  export type NutritionalCounselingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
    /**
     * Filter which NutritionalCounseling to delete.
     */
    where: NutritionalCounselingWhereUniqueInput
  }

  /**
   * NutritionalCounseling deleteMany
   */
  export type NutritionalCounselingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NutritionalCounselings to delete
     */
    where?: NutritionalCounselingWhereInput
    /**
     * Limit how many NutritionalCounselings to delete.
     */
    limit?: number
  }

  /**
   * NutritionalCounseling without action
   */
  export type NutritionalCounselingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NutritionalCounseling
     */
    select?: NutritionalCounselingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NutritionalCounseling
     */
    omit?: NutritionalCounselingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NutritionalCounselingInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    facilityName: string | null
    reason: string | null
    dateReferred: Date | null
    status: string | null
    referredBy: string | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    facilityName: string | null
    reason: string | null
    dateReferred: Date | null
    status: string | null
    referredBy: string | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    userProfileId: number
    facilityName: number
    reason: number
    dateReferred: number
    status: number
    referredBy: number
    _all: number
  }


  export type ReferralMinAggregateInputType = {
    id?: true
    userProfileId?: true
    facilityName?: true
    reason?: true
    dateReferred?: true
    status?: true
    referredBy?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    facilityName?: true
    reason?: true
    dateReferred?: true
    status?: true
    referredBy?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    userProfileId?: true
    facilityName?: true
    reason?: true
    dateReferred?: true
    status?: true
    referredBy?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    userProfileId: string
    facilityName: string
    reason: string
    dateReferred: Date
    status: string
    referredBy: string
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    facilityName?: boolean
    reason?: boolean
    dateReferred?: boolean
    status?: boolean
    referredBy?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>



  export type ReferralSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    facilityName?: boolean
    reason?: boolean
    dateReferred?: boolean
    status?: boolean
    referredBy?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "facilityName" | "reason" | "dateReferred" | "status" | "referredBy", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      facilityName: string
      reason: string
      dateReferred: Date
      status: string
      referredBy: string
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly userProfileId: FieldRef<"Referral", 'String'>
    readonly facilityName: FieldRef<"Referral", 'String'>
    readonly reason: FieldRef<"Referral", 'String'>
    readonly dateReferred: FieldRef<"Referral", 'DateTime'>
    readonly status: FieldRef<"Referral", 'String'>
    readonly referredBy: FieldRef<"Referral", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    nextVisitDate: Date | null
    visitType: string | null
    appointmentStatus: string | null
    scheduledBy: string | null
    createdAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    nextVisitDate: Date | null
    visitType: string | null
    appointmentStatus: string | null
    scheduledBy: string | null
    createdAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    userProfileId: number
    nextVisitDate: number
    visitType: number
    appointmentStatus: number
    scheduledBy: number
    createdAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    userProfileId?: true
    nextVisitDate?: true
    visitType?: true
    appointmentStatus?: true
    scheduledBy?: true
    createdAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    nextVisitDate?: true
    visitType?: true
    appointmentStatus?: true
    scheduledBy?: true
    createdAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    userProfileId?: true
    nextVisitDate?: true
    visitType?: true
    appointmentStatus?: true
    scheduledBy?: true
    createdAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    userProfileId: string
    nextVisitDate: Date
    visitType: string
    appointmentStatus: string
    scheduledBy: string
    createdAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    nextVisitDate?: boolean
    visitType?: boolean
    appointmentStatus?: boolean
    scheduledBy?: boolean
    createdAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>



  export type AppointmentSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    nextVisitDate?: boolean
    visitType?: boolean
    appointmentStatus?: boolean
    scheduledBy?: boolean
    createdAt?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "nextVisitDate" | "visitType" | "appointmentStatus" | "scheduledBy" | "createdAt", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      nextVisitDate: Date
      visitType: string
      appointmentStatus: string
      scheduledBy: string
      createdAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly userProfileId: FieldRef<"Appointment", 'String'>
    readonly nextVisitDate: FieldRef<"Appointment", 'DateTime'>
    readonly visitType: FieldRef<"Appointment", 'String'>
    readonly appointmentStatus: FieldRef<"Appointment", 'String'>
    readonly scheduledBy: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model ImmunizationReminder
   */

  export type AggregateImmunizationReminder = {
    _count: ImmunizationReminderCountAggregateOutputType | null
    _min: ImmunizationReminderMinAggregateOutputType | null
    _max: ImmunizationReminderMaxAggregateOutputType | null
  }

  export type ImmunizationReminderMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    vaccineName: string | null
    dueDate: Date | null
    reminderSent: boolean | null
    sentAt: Date | null
  }

  export type ImmunizationReminderMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    vaccineName: string | null
    dueDate: Date | null
    reminderSent: boolean | null
    sentAt: Date | null
  }

  export type ImmunizationReminderCountAggregateOutputType = {
    id: number
    userProfileId: number
    vaccineName: number
    dueDate: number
    reminderSent: number
    sentAt: number
    _all: number
  }


  export type ImmunizationReminderMinAggregateInputType = {
    id?: true
    userProfileId?: true
    vaccineName?: true
    dueDate?: true
    reminderSent?: true
    sentAt?: true
  }

  export type ImmunizationReminderMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    vaccineName?: true
    dueDate?: true
    reminderSent?: true
    sentAt?: true
  }

  export type ImmunizationReminderCountAggregateInputType = {
    id?: true
    userProfileId?: true
    vaccineName?: true
    dueDate?: true
    reminderSent?: true
    sentAt?: true
    _all?: true
  }

  export type ImmunizationReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmunizationReminder to aggregate.
     */
    where?: ImmunizationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationReminders to fetch.
     */
    orderBy?: ImmunizationReminderOrderByWithRelationInput | ImmunizationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImmunizationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImmunizationReminders
    **/
    _count?: true | ImmunizationReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImmunizationReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImmunizationReminderMaxAggregateInputType
  }

  export type GetImmunizationReminderAggregateType<T extends ImmunizationReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateImmunizationReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImmunizationReminder[P]>
      : GetScalarType<T[P], AggregateImmunizationReminder[P]>
  }




  export type ImmunizationReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImmunizationReminderWhereInput
    orderBy?: ImmunizationReminderOrderByWithAggregationInput | ImmunizationReminderOrderByWithAggregationInput[]
    by: ImmunizationReminderScalarFieldEnum[] | ImmunizationReminderScalarFieldEnum
    having?: ImmunizationReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImmunizationReminderCountAggregateInputType | true
    _min?: ImmunizationReminderMinAggregateInputType
    _max?: ImmunizationReminderMaxAggregateInputType
  }

  export type ImmunizationReminderGroupByOutputType = {
    id: string
    userProfileId: string
    vaccineName: string
    dueDate: Date
    reminderSent: boolean
    sentAt: Date | null
    _count: ImmunizationReminderCountAggregateOutputType | null
    _min: ImmunizationReminderMinAggregateOutputType | null
    _max: ImmunizationReminderMaxAggregateOutputType | null
  }

  type GetImmunizationReminderGroupByPayload<T extends ImmunizationReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImmunizationReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImmunizationReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImmunizationReminderGroupByOutputType[P]>
            : GetScalarType<T[P], ImmunizationReminderGroupByOutputType[P]>
        }
      >
    >


  export type ImmunizationReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    vaccineName?: boolean
    dueDate?: boolean
    reminderSent?: boolean
    sentAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["immunizationReminder"]>



  export type ImmunizationReminderSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    vaccineName?: boolean
    dueDate?: boolean
    reminderSent?: boolean
    sentAt?: boolean
  }

  export type ImmunizationReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "vaccineName" | "dueDate" | "reminderSent" | "sentAt", ExtArgs["result"]["immunizationReminder"]>
  export type ImmunizationReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $ImmunizationReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImmunizationReminder"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      vaccineName: string
      dueDate: Date
      reminderSent: boolean
      sentAt: Date | null
    }, ExtArgs["result"]["immunizationReminder"]>
    composites: {}
  }

  type ImmunizationReminderGetPayload<S extends boolean | null | undefined | ImmunizationReminderDefaultArgs> = $Result.GetResult<Prisma.$ImmunizationReminderPayload, S>

  type ImmunizationReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImmunizationReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImmunizationReminderCountAggregateInputType | true
    }

  export interface ImmunizationReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImmunizationReminder'], meta: { name: 'ImmunizationReminder' } }
    /**
     * Find zero or one ImmunizationReminder that matches the filter.
     * @param {ImmunizationReminderFindUniqueArgs} args - Arguments to find a ImmunizationReminder
     * @example
     * // Get one ImmunizationReminder
     * const immunizationReminder = await prisma.immunizationReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImmunizationReminderFindUniqueArgs>(args: SelectSubset<T, ImmunizationReminderFindUniqueArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImmunizationReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImmunizationReminderFindUniqueOrThrowArgs} args - Arguments to find a ImmunizationReminder
     * @example
     * // Get one ImmunizationReminder
     * const immunizationReminder = await prisma.immunizationReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImmunizationReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, ImmunizationReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmunizationReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationReminderFindFirstArgs} args - Arguments to find a ImmunizationReminder
     * @example
     * // Get one ImmunizationReminder
     * const immunizationReminder = await prisma.immunizationReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImmunizationReminderFindFirstArgs>(args?: SelectSubset<T, ImmunizationReminderFindFirstArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImmunizationReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationReminderFindFirstOrThrowArgs} args - Arguments to find a ImmunizationReminder
     * @example
     * // Get one ImmunizationReminder
     * const immunizationReminder = await prisma.immunizationReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImmunizationReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, ImmunizationReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImmunizationReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImmunizationReminders
     * const immunizationReminders = await prisma.immunizationReminder.findMany()
     * 
     * // Get first 10 ImmunizationReminders
     * const immunizationReminders = await prisma.immunizationReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const immunizationReminderWithIdOnly = await prisma.immunizationReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImmunizationReminderFindManyArgs>(args?: SelectSubset<T, ImmunizationReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImmunizationReminder.
     * @param {ImmunizationReminderCreateArgs} args - Arguments to create a ImmunizationReminder.
     * @example
     * // Create one ImmunizationReminder
     * const ImmunizationReminder = await prisma.immunizationReminder.create({
     *   data: {
     *     // ... data to create a ImmunizationReminder
     *   }
     * })
     * 
     */
    create<T extends ImmunizationReminderCreateArgs>(args: SelectSubset<T, ImmunizationReminderCreateArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImmunizationReminders.
     * @param {ImmunizationReminderCreateManyArgs} args - Arguments to create many ImmunizationReminders.
     * @example
     * // Create many ImmunizationReminders
     * const immunizationReminder = await prisma.immunizationReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImmunizationReminderCreateManyArgs>(args?: SelectSubset<T, ImmunizationReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ImmunizationReminder.
     * @param {ImmunizationReminderDeleteArgs} args - Arguments to delete one ImmunizationReminder.
     * @example
     * // Delete one ImmunizationReminder
     * const ImmunizationReminder = await prisma.immunizationReminder.delete({
     *   where: {
     *     // ... filter to delete one ImmunizationReminder
     *   }
     * })
     * 
     */
    delete<T extends ImmunizationReminderDeleteArgs>(args: SelectSubset<T, ImmunizationReminderDeleteArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImmunizationReminder.
     * @param {ImmunizationReminderUpdateArgs} args - Arguments to update one ImmunizationReminder.
     * @example
     * // Update one ImmunizationReminder
     * const immunizationReminder = await prisma.immunizationReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImmunizationReminderUpdateArgs>(args: SelectSubset<T, ImmunizationReminderUpdateArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImmunizationReminders.
     * @param {ImmunizationReminderDeleteManyArgs} args - Arguments to filter ImmunizationReminders to delete.
     * @example
     * // Delete a few ImmunizationReminders
     * const { count } = await prisma.immunizationReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImmunizationReminderDeleteManyArgs>(args?: SelectSubset<T, ImmunizationReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImmunizationReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImmunizationReminders
     * const immunizationReminder = await prisma.immunizationReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImmunizationReminderUpdateManyArgs>(args: SelectSubset<T, ImmunizationReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImmunizationReminder.
     * @param {ImmunizationReminderUpsertArgs} args - Arguments to update or create a ImmunizationReminder.
     * @example
     * // Update or create a ImmunizationReminder
     * const immunizationReminder = await prisma.immunizationReminder.upsert({
     *   create: {
     *     // ... data to create a ImmunizationReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImmunizationReminder we want to update
     *   }
     * })
     */
    upsert<T extends ImmunizationReminderUpsertArgs>(args: SelectSubset<T, ImmunizationReminderUpsertArgs<ExtArgs>>): Prisma__ImmunizationReminderClient<$Result.GetResult<Prisma.$ImmunizationReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImmunizationReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationReminderCountArgs} args - Arguments to filter ImmunizationReminders to count.
     * @example
     * // Count the number of ImmunizationReminders
     * const count = await prisma.immunizationReminder.count({
     *   where: {
     *     // ... the filter for the ImmunizationReminders we want to count
     *   }
     * })
    **/
    count<T extends ImmunizationReminderCountArgs>(
      args?: Subset<T, ImmunizationReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImmunizationReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImmunizationReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImmunizationReminderAggregateArgs>(args: Subset<T, ImmunizationReminderAggregateArgs>): Prisma.PrismaPromise<GetImmunizationReminderAggregateType<T>>

    /**
     * Group by ImmunizationReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImmunizationReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImmunizationReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImmunizationReminderGroupByArgs['orderBy'] }
        : { orderBy?: ImmunizationReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImmunizationReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImmunizationReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImmunizationReminder model
   */
  readonly fields: ImmunizationReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImmunizationReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImmunizationReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImmunizationReminder model
   */
  interface ImmunizationReminderFieldRefs {
    readonly id: FieldRef<"ImmunizationReminder", 'String'>
    readonly userProfileId: FieldRef<"ImmunizationReminder", 'String'>
    readonly vaccineName: FieldRef<"ImmunizationReminder", 'String'>
    readonly dueDate: FieldRef<"ImmunizationReminder", 'DateTime'>
    readonly reminderSent: FieldRef<"ImmunizationReminder", 'Boolean'>
    readonly sentAt: FieldRef<"ImmunizationReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImmunizationReminder findUnique
   */
  export type ImmunizationReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationReminder to fetch.
     */
    where: ImmunizationReminderWhereUniqueInput
  }

  /**
   * ImmunizationReminder findUniqueOrThrow
   */
  export type ImmunizationReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationReminder to fetch.
     */
    where: ImmunizationReminderWhereUniqueInput
  }

  /**
   * ImmunizationReminder findFirst
   */
  export type ImmunizationReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationReminder to fetch.
     */
    where?: ImmunizationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationReminders to fetch.
     */
    orderBy?: ImmunizationReminderOrderByWithRelationInput | ImmunizationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmunizationReminders.
     */
    cursor?: ImmunizationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmunizationReminders.
     */
    distinct?: ImmunizationReminderScalarFieldEnum | ImmunizationReminderScalarFieldEnum[]
  }

  /**
   * ImmunizationReminder findFirstOrThrow
   */
  export type ImmunizationReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationReminder to fetch.
     */
    where?: ImmunizationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationReminders to fetch.
     */
    orderBy?: ImmunizationReminderOrderByWithRelationInput | ImmunizationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImmunizationReminders.
     */
    cursor?: ImmunizationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImmunizationReminders.
     */
    distinct?: ImmunizationReminderScalarFieldEnum | ImmunizationReminderScalarFieldEnum[]
  }

  /**
   * ImmunizationReminder findMany
   */
  export type ImmunizationReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * Filter, which ImmunizationReminders to fetch.
     */
    where?: ImmunizationReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImmunizationReminders to fetch.
     */
    orderBy?: ImmunizationReminderOrderByWithRelationInput | ImmunizationReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImmunizationReminders.
     */
    cursor?: ImmunizationReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImmunizationReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImmunizationReminders.
     */
    skip?: number
    distinct?: ImmunizationReminderScalarFieldEnum | ImmunizationReminderScalarFieldEnum[]
  }

  /**
   * ImmunizationReminder create
   */
  export type ImmunizationReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a ImmunizationReminder.
     */
    data: XOR<ImmunizationReminderCreateInput, ImmunizationReminderUncheckedCreateInput>
  }

  /**
   * ImmunizationReminder createMany
   */
  export type ImmunizationReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImmunizationReminders.
     */
    data: ImmunizationReminderCreateManyInput | ImmunizationReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImmunizationReminder update
   */
  export type ImmunizationReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a ImmunizationReminder.
     */
    data: XOR<ImmunizationReminderUpdateInput, ImmunizationReminderUncheckedUpdateInput>
    /**
     * Choose, which ImmunizationReminder to update.
     */
    where: ImmunizationReminderWhereUniqueInput
  }

  /**
   * ImmunizationReminder updateMany
   */
  export type ImmunizationReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImmunizationReminders.
     */
    data: XOR<ImmunizationReminderUpdateManyMutationInput, ImmunizationReminderUncheckedUpdateManyInput>
    /**
     * Filter which ImmunizationReminders to update
     */
    where?: ImmunizationReminderWhereInput
    /**
     * Limit how many ImmunizationReminders to update.
     */
    limit?: number
  }

  /**
   * ImmunizationReminder upsert
   */
  export type ImmunizationReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the ImmunizationReminder to update in case it exists.
     */
    where: ImmunizationReminderWhereUniqueInput
    /**
     * In case the ImmunizationReminder found by the `where` argument doesn't exist, create a new ImmunizationReminder with this data.
     */
    create: XOR<ImmunizationReminderCreateInput, ImmunizationReminderUncheckedCreateInput>
    /**
     * In case the ImmunizationReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImmunizationReminderUpdateInput, ImmunizationReminderUncheckedUpdateInput>
  }

  /**
   * ImmunizationReminder delete
   */
  export type ImmunizationReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
    /**
     * Filter which ImmunizationReminder to delete.
     */
    where: ImmunizationReminderWhereUniqueInput
  }

  /**
   * ImmunizationReminder deleteMany
   */
  export type ImmunizationReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImmunizationReminders to delete
     */
    where?: ImmunizationReminderWhereInput
    /**
     * Limit how many ImmunizationReminders to delete.
     */
    limit?: number
  }

  /**
   * ImmunizationReminder without action
   */
  export type ImmunizationReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImmunizationReminder
     */
    select?: ImmunizationReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImmunizationReminder
     */
    omit?: ImmunizationReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImmunizationReminderInclude<ExtArgs> | null
  }


  /**
   * Model TestReminder
   */

  export type AggregateTestReminder = {
    _count: TestReminderCountAggregateOutputType | null
    _min: TestReminderMinAggregateOutputType | null
    _max: TestReminderMaxAggregateOutputType | null
  }

  export type TestReminderMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    testName: string | null
    dueDate: Date | null
    reminderSent: boolean | null
    sentAt: Date | null
  }

  export type TestReminderMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    testName: string | null
    dueDate: Date | null
    reminderSent: boolean | null
    sentAt: Date | null
  }

  export type TestReminderCountAggregateOutputType = {
    id: number
    userProfileId: number
    testName: number
    dueDate: number
    reminderSent: number
    sentAt: number
    _all: number
  }


  export type TestReminderMinAggregateInputType = {
    id?: true
    userProfileId?: true
    testName?: true
    dueDate?: true
    reminderSent?: true
    sentAt?: true
  }

  export type TestReminderMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    testName?: true
    dueDate?: true
    reminderSent?: true
    sentAt?: true
  }

  export type TestReminderCountAggregateInputType = {
    id?: true
    userProfileId?: true
    testName?: true
    dueDate?: true
    reminderSent?: true
    sentAt?: true
    _all?: true
  }

  export type TestReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestReminder to aggregate.
     */
    where?: TestReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestReminders to fetch.
     */
    orderBy?: TestReminderOrderByWithRelationInput | TestReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestReminders
    **/
    _count?: true | TestReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestReminderMaxAggregateInputType
  }

  export type GetTestReminderAggregateType<T extends TestReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateTestReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestReminder[P]>
      : GetScalarType<T[P], AggregateTestReminder[P]>
  }




  export type TestReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestReminderWhereInput
    orderBy?: TestReminderOrderByWithAggregationInput | TestReminderOrderByWithAggregationInput[]
    by: TestReminderScalarFieldEnum[] | TestReminderScalarFieldEnum
    having?: TestReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestReminderCountAggregateInputType | true
    _min?: TestReminderMinAggregateInputType
    _max?: TestReminderMaxAggregateInputType
  }

  export type TestReminderGroupByOutputType = {
    id: string
    userProfileId: string
    testName: string
    dueDate: Date
    reminderSent: boolean
    sentAt: Date | null
    _count: TestReminderCountAggregateOutputType | null
    _min: TestReminderMinAggregateOutputType | null
    _max: TestReminderMaxAggregateOutputType | null
  }

  type GetTestReminderGroupByPayload<T extends TestReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestReminderGroupByOutputType[P]>
            : GetScalarType<T[P], TestReminderGroupByOutputType[P]>
        }
      >
    >


  export type TestReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    testName?: boolean
    dueDate?: boolean
    reminderSent?: boolean
    sentAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testReminder"]>



  export type TestReminderSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    testName?: boolean
    dueDate?: boolean
    reminderSent?: boolean
    sentAt?: boolean
  }

  export type TestReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "testName" | "dueDate" | "reminderSent" | "sentAt", ExtArgs["result"]["testReminder"]>
  export type TestReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $TestReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestReminder"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      testName: string
      dueDate: Date
      reminderSent: boolean
      sentAt: Date | null
    }, ExtArgs["result"]["testReminder"]>
    composites: {}
  }

  type TestReminderGetPayload<S extends boolean | null | undefined | TestReminderDefaultArgs> = $Result.GetResult<Prisma.$TestReminderPayload, S>

  type TestReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestReminderCountAggregateInputType | true
    }

  export interface TestReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestReminder'], meta: { name: 'TestReminder' } }
    /**
     * Find zero or one TestReminder that matches the filter.
     * @param {TestReminderFindUniqueArgs} args - Arguments to find a TestReminder
     * @example
     * // Get one TestReminder
     * const testReminder = await prisma.testReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestReminderFindUniqueArgs>(args: SelectSubset<T, TestReminderFindUniqueArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestReminderFindUniqueOrThrowArgs} args - Arguments to find a TestReminder
     * @example
     * // Get one TestReminder
     * const testReminder = await prisma.testReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, TestReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestReminderFindFirstArgs} args - Arguments to find a TestReminder
     * @example
     * // Get one TestReminder
     * const testReminder = await prisma.testReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestReminderFindFirstArgs>(args?: SelectSubset<T, TestReminderFindFirstArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestReminderFindFirstOrThrowArgs} args - Arguments to find a TestReminder
     * @example
     * // Get one TestReminder
     * const testReminder = await prisma.testReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, TestReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestReminders
     * const testReminders = await prisma.testReminder.findMany()
     * 
     * // Get first 10 TestReminders
     * const testReminders = await prisma.testReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testReminderWithIdOnly = await prisma.testReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestReminderFindManyArgs>(args?: SelectSubset<T, TestReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestReminder.
     * @param {TestReminderCreateArgs} args - Arguments to create a TestReminder.
     * @example
     * // Create one TestReminder
     * const TestReminder = await prisma.testReminder.create({
     *   data: {
     *     // ... data to create a TestReminder
     *   }
     * })
     * 
     */
    create<T extends TestReminderCreateArgs>(args: SelectSubset<T, TestReminderCreateArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestReminders.
     * @param {TestReminderCreateManyArgs} args - Arguments to create many TestReminders.
     * @example
     * // Create many TestReminders
     * const testReminder = await prisma.testReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestReminderCreateManyArgs>(args?: SelectSubset<T, TestReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TestReminder.
     * @param {TestReminderDeleteArgs} args - Arguments to delete one TestReminder.
     * @example
     * // Delete one TestReminder
     * const TestReminder = await prisma.testReminder.delete({
     *   where: {
     *     // ... filter to delete one TestReminder
     *   }
     * })
     * 
     */
    delete<T extends TestReminderDeleteArgs>(args: SelectSubset<T, TestReminderDeleteArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestReminder.
     * @param {TestReminderUpdateArgs} args - Arguments to update one TestReminder.
     * @example
     * // Update one TestReminder
     * const testReminder = await prisma.testReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestReminderUpdateArgs>(args: SelectSubset<T, TestReminderUpdateArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestReminders.
     * @param {TestReminderDeleteManyArgs} args - Arguments to filter TestReminders to delete.
     * @example
     * // Delete a few TestReminders
     * const { count } = await prisma.testReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestReminderDeleteManyArgs>(args?: SelectSubset<T, TestReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestReminders
     * const testReminder = await prisma.testReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestReminderUpdateManyArgs>(args: SelectSubset<T, TestReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TestReminder.
     * @param {TestReminderUpsertArgs} args - Arguments to update or create a TestReminder.
     * @example
     * // Update or create a TestReminder
     * const testReminder = await prisma.testReminder.upsert({
     *   create: {
     *     // ... data to create a TestReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestReminder we want to update
     *   }
     * })
     */
    upsert<T extends TestReminderUpsertArgs>(args: SelectSubset<T, TestReminderUpsertArgs<ExtArgs>>): Prisma__TestReminderClient<$Result.GetResult<Prisma.$TestReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestReminderCountArgs} args - Arguments to filter TestReminders to count.
     * @example
     * // Count the number of TestReminders
     * const count = await prisma.testReminder.count({
     *   where: {
     *     // ... the filter for the TestReminders we want to count
     *   }
     * })
    **/
    count<T extends TestReminderCountArgs>(
      args?: Subset<T, TestReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestReminderAggregateArgs>(args: Subset<T, TestReminderAggregateArgs>): Prisma.PrismaPromise<GetTestReminderAggregateType<T>>

    /**
     * Group by TestReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestReminderGroupByArgs['orderBy'] }
        : { orderBy?: TestReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestReminder model
   */
  readonly fields: TestReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestReminder model
   */
  interface TestReminderFieldRefs {
    readonly id: FieldRef<"TestReminder", 'String'>
    readonly userProfileId: FieldRef<"TestReminder", 'String'>
    readonly testName: FieldRef<"TestReminder", 'String'>
    readonly dueDate: FieldRef<"TestReminder", 'DateTime'>
    readonly reminderSent: FieldRef<"TestReminder", 'Boolean'>
    readonly sentAt: FieldRef<"TestReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestReminder findUnique
   */
  export type TestReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * Filter, which TestReminder to fetch.
     */
    where: TestReminderWhereUniqueInput
  }

  /**
   * TestReminder findUniqueOrThrow
   */
  export type TestReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * Filter, which TestReminder to fetch.
     */
    where: TestReminderWhereUniqueInput
  }

  /**
   * TestReminder findFirst
   */
  export type TestReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * Filter, which TestReminder to fetch.
     */
    where?: TestReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestReminders to fetch.
     */
    orderBy?: TestReminderOrderByWithRelationInput | TestReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestReminders.
     */
    cursor?: TestReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestReminders.
     */
    distinct?: TestReminderScalarFieldEnum | TestReminderScalarFieldEnum[]
  }

  /**
   * TestReminder findFirstOrThrow
   */
  export type TestReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * Filter, which TestReminder to fetch.
     */
    where?: TestReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestReminders to fetch.
     */
    orderBy?: TestReminderOrderByWithRelationInput | TestReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestReminders.
     */
    cursor?: TestReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestReminders.
     */
    distinct?: TestReminderScalarFieldEnum | TestReminderScalarFieldEnum[]
  }

  /**
   * TestReminder findMany
   */
  export type TestReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * Filter, which TestReminders to fetch.
     */
    where?: TestReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestReminders to fetch.
     */
    orderBy?: TestReminderOrderByWithRelationInput | TestReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestReminders.
     */
    cursor?: TestReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestReminders.
     */
    skip?: number
    distinct?: TestReminderScalarFieldEnum | TestReminderScalarFieldEnum[]
  }

  /**
   * TestReminder create
   */
  export type TestReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a TestReminder.
     */
    data: XOR<TestReminderCreateInput, TestReminderUncheckedCreateInput>
  }

  /**
   * TestReminder createMany
   */
  export type TestReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestReminders.
     */
    data: TestReminderCreateManyInput | TestReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestReminder update
   */
  export type TestReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a TestReminder.
     */
    data: XOR<TestReminderUpdateInput, TestReminderUncheckedUpdateInput>
    /**
     * Choose, which TestReminder to update.
     */
    where: TestReminderWhereUniqueInput
  }

  /**
   * TestReminder updateMany
   */
  export type TestReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestReminders.
     */
    data: XOR<TestReminderUpdateManyMutationInput, TestReminderUncheckedUpdateManyInput>
    /**
     * Filter which TestReminders to update
     */
    where?: TestReminderWhereInput
    /**
     * Limit how many TestReminders to update.
     */
    limit?: number
  }

  /**
   * TestReminder upsert
   */
  export type TestReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the TestReminder to update in case it exists.
     */
    where: TestReminderWhereUniqueInput
    /**
     * In case the TestReminder found by the `where` argument doesn't exist, create a new TestReminder with this data.
     */
    create: XOR<TestReminderCreateInput, TestReminderUncheckedCreateInput>
    /**
     * In case the TestReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestReminderUpdateInput, TestReminderUncheckedUpdateInput>
  }

  /**
   * TestReminder delete
   */
  export type TestReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
    /**
     * Filter which TestReminder to delete.
     */
    where: TestReminderWhereUniqueInput
  }

  /**
   * TestReminder deleteMany
   */
  export type TestReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestReminders to delete
     */
    where?: TestReminderWhereInput
    /**
     * Limit how many TestReminders to delete.
     */
    limit?: number
  }

  /**
   * TestReminder without action
   */
  export type TestReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestReminder
     */
    select?: TestReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestReminder
     */
    omit?: TestReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestReminderInclude<ExtArgs> | null
  }


  /**
   * Model VirtualCheckup
   */

  export type AggregateVirtualCheckup = {
    _count: VirtualCheckupCountAggregateOutputType | null
    _avg: VirtualCheckupAvgAggregateOutputType | null
    _sum: VirtualCheckupSumAggregateOutputType | null
    _min: VirtualCheckupMinAggregateOutputType | null
    _max: VirtualCheckupMaxAggregateOutputType | null
  }

  export type VirtualCheckupAvgAggregateOutputType = {
    durationMinutes: number | null
  }

  export type VirtualCheckupSumAggregateOutputType = {
    durationMinutes: number | null
  }

  export type VirtualCheckupMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    healthWorkerId: string | null
    scheduledDate: Date | null
    scheduledTime: string | null
    meetingUrl: string | null
    status: string | null
    consultationType: string | null
    chiefComplaint: string | null
    notes: string | null
    durationMinutes: number | null
    createdAt: Date | null
  }

  export type VirtualCheckupMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    healthWorkerId: string | null
    scheduledDate: Date | null
    scheduledTime: string | null
    meetingUrl: string | null
    status: string | null
    consultationType: string | null
    chiefComplaint: string | null
    notes: string | null
    durationMinutes: number | null
    createdAt: Date | null
  }

  export type VirtualCheckupCountAggregateOutputType = {
    id: number
    userProfileId: number
    healthWorkerId: number
    scheduledDate: number
    scheduledTime: number
    meetingUrl: number
    status: number
    consultationType: number
    chiefComplaint: number
    notes: number
    durationMinutes: number
    createdAt: number
    _all: number
  }


  export type VirtualCheckupAvgAggregateInputType = {
    durationMinutes?: true
  }

  export type VirtualCheckupSumAggregateInputType = {
    durationMinutes?: true
  }

  export type VirtualCheckupMinAggregateInputType = {
    id?: true
    userProfileId?: true
    healthWorkerId?: true
    scheduledDate?: true
    scheduledTime?: true
    meetingUrl?: true
    status?: true
    consultationType?: true
    chiefComplaint?: true
    notes?: true
    durationMinutes?: true
    createdAt?: true
  }

  export type VirtualCheckupMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    healthWorkerId?: true
    scheduledDate?: true
    scheduledTime?: true
    meetingUrl?: true
    status?: true
    consultationType?: true
    chiefComplaint?: true
    notes?: true
    durationMinutes?: true
    createdAt?: true
  }

  export type VirtualCheckupCountAggregateInputType = {
    id?: true
    userProfileId?: true
    healthWorkerId?: true
    scheduledDate?: true
    scheduledTime?: true
    meetingUrl?: true
    status?: true
    consultationType?: true
    chiefComplaint?: true
    notes?: true
    durationMinutes?: true
    createdAt?: true
    _all?: true
  }

  export type VirtualCheckupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualCheckup to aggregate.
     */
    where?: VirtualCheckupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckups to fetch.
     */
    orderBy?: VirtualCheckupOrderByWithRelationInput | VirtualCheckupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VirtualCheckupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VirtualCheckups
    **/
    _count?: true | VirtualCheckupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VirtualCheckupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VirtualCheckupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VirtualCheckupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VirtualCheckupMaxAggregateInputType
  }

  export type GetVirtualCheckupAggregateType<T extends VirtualCheckupAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtualCheckup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtualCheckup[P]>
      : GetScalarType<T[P], AggregateVirtualCheckup[P]>
  }




  export type VirtualCheckupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualCheckupWhereInput
    orderBy?: VirtualCheckupOrderByWithAggregationInput | VirtualCheckupOrderByWithAggregationInput[]
    by: VirtualCheckupScalarFieldEnum[] | VirtualCheckupScalarFieldEnum
    having?: VirtualCheckupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VirtualCheckupCountAggregateInputType | true
    _avg?: VirtualCheckupAvgAggregateInputType
    _sum?: VirtualCheckupSumAggregateInputType
    _min?: VirtualCheckupMinAggregateInputType
    _max?: VirtualCheckupMaxAggregateInputType
  }

  export type VirtualCheckupGroupByOutputType = {
    id: string
    userProfileId: string
    healthWorkerId: string
    scheduledDate: Date
    scheduledTime: string
    meetingUrl: string | null
    status: string
    consultationType: string | null
    chiefComplaint: string | null
    notes: string | null
    durationMinutes: number | null
    createdAt: Date
    _count: VirtualCheckupCountAggregateOutputType | null
    _avg: VirtualCheckupAvgAggregateOutputType | null
    _sum: VirtualCheckupSumAggregateOutputType | null
    _min: VirtualCheckupMinAggregateOutputType | null
    _max: VirtualCheckupMaxAggregateOutputType | null
  }

  type GetVirtualCheckupGroupByPayload<T extends VirtualCheckupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VirtualCheckupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VirtualCheckupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VirtualCheckupGroupByOutputType[P]>
            : GetScalarType<T[P], VirtualCheckupGroupByOutputType[P]>
        }
      >
    >


  export type VirtualCheckupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    healthWorkerId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    meetingUrl?: boolean
    status?: boolean
    consultationType?: boolean
    chiefComplaint?: boolean
    notes?: boolean
    durationMinutes?: boolean
    createdAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    healthWorker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
    virtualCheckupNotes?: boolean | VirtualCheckup$virtualCheckupNotesArgs<ExtArgs>
    _count?: boolean | VirtualCheckupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualCheckup"]>



  export type VirtualCheckupSelectScalar = {
    id?: boolean
    userProfileId?: boolean
    healthWorkerId?: boolean
    scheduledDate?: boolean
    scheduledTime?: boolean
    meetingUrl?: boolean
    status?: boolean
    consultationType?: boolean
    chiefComplaint?: boolean
    notes?: boolean
    durationMinutes?: boolean
    createdAt?: boolean
  }

  export type VirtualCheckupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "healthWorkerId" | "scheduledDate" | "scheduledTime" | "meetingUrl" | "status" | "consultationType" | "chiefComplaint" | "notes" | "durationMinutes" | "createdAt", ExtArgs["result"]["virtualCheckup"]>
  export type VirtualCheckupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    healthWorker?: boolean | HealthWorkerDefaultArgs<ExtArgs>
    virtualCheckupNotes?: boolean | VirtualCheckup$virtualCheckupNotesArgs<ExtArgs>
    _count?: boolean | VirtualCheckupCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VirtualCheckupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VirtualCheckup"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
      healthWorker: Prisma.$HealthWorkerPayload<ExtArgs>
      virtualCheckupNotes: Prisma.$VirtualCheckupNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      healthWorkerId: string
      scheduledDate: Date
      scheduledTime: string
      meetingUrl: string | null
      status: string
      consultationType: string | null
      chiefComplaint: string | null
      notes: string | null
      durationMinutes: number | null
      createdAt: Date
    }, ExtArgs["result"]["virtualCheckup"]>
    composites: {}
  }

  type VirtualCheckupGetPayload<S extends boolean | null | undefined | VirtualCheckupDefaultArgs> = $Result.GetResult<Prisma.$VirtualCheckupPayload, S>

  type VirtualCheckupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VirtualCheckupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VirtualCheckupCountAggregateInputType | true
    }

  export interface VirtualCheckupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VirtualCheckup'], meta: { name: 'VirtualCheckup' } }
    /**
     * Find zero or one VirtualCheckup that matches the filter.
     * @param {VirtualCheckupFindUniqueArgs} args - Arguments to find a VirtualCheckup
     * @example
     * // Get one VirtualCheckup
     * const virtualCheckup = await prisma.virtualCheckup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VirtualCheckupFindUniqueArgs>(args: SelectSubset<T, VirtualCheckupFindUniqueArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VirtualCheckup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VirtualCheckupFindUniqueOrThrowArgs} args - Arguments to find a VirtualCheckup
     * @example
     * // Get one VirtualCheckup
     * const virtualCheckup = await prisma.virtualCheckup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VirtualCheckupFindUniqueOrThrowArgs>(args: SelectSubset<T, VirtualCheckupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VirtualCheckup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupFindFirstArgs} args - Arguments to find a VirtualCheckup
     * @example
     * // Get one VirtualCheckup
     * const virtualCheckup = await prisma.virtualCheckup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VirtualCheckupFindFirstArgs>(args?: SelectSubset<T, VirtualCheckupFindFirstArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VirtualCheckup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupFindFirstOrThrowArgs} args - Arguments to find a VirtualCheckup
     * @example
     * // Get one VirtualCheckup
     * const virtualCheckup = await prisma.virtualCheckup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VirtualCheckupFindFirstOrThrowArgs>(args?: SelectSubset<T, VirtualCheckupFindFirstOrThrowArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VirtualCheckups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VirtualCheckups
     * const virtualCheckups = await prisma.virtualCheckup.findMany()
     * 
     * // Get first 10 VirtualCheckups
     * const virtualCheckups = await prisma.virtualCheckup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtualCheckupWithIdOnly = await prisma.virtualCheckup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VirtualCheckupFindManyArgs>(args?: SelectSubset<T, VirtualCheckupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VirtualCheckup.
     * @param {VirtualCheckupCreateArgs} args - Arguments to create a VirtualCheckup.
     * @example
     * // Create one VirtualCheckup
     * const VirtualCheckup = await prisma.virtualCheckup.create({
     *   data: {
     *     // ... data to create a VirtualCheckup
     *   }
     * })
     * 
     */
    create<T extends VirtualCheckupCreateArgs>(args: SelectSubset<T, VirtualCheckupCreateArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VirtualCheckups.
     * @param {VirtualCheckupCreateManyArgs} args - Arguments to create many VirtualCheckups.
     * @example
     * // Create many VirtualCheckups
     * const virtualCheckup = await prisma.virtualCheckup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VirtualCheckupCreateManyArgs>(args?: SelectSubset<T, VirtualCheckupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VirtualCheckup.
     * @param {VirtualCheckupDeleteArgs} args - Arguments to delete one VirtualCheckup.
     * @example
     * // Delete one VirtualCheckup
     * const VirtualCheckup = await prisma.virtualCheckup.delete({
     *   where: {
     *     // ... filter to delete one VirtualCheckup
     *   }
     * })
     * 
     */
    delete<T extends VirtualCheckupDeleteArgs>(args: SelectSubset<T, VirtualCheckupDeleteArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VirtualCheckup.
     * @param {VirtualCheckupUpdateArgs} args - Arguments to update one VirtualCheckup.
     * @example
     * // Update one VirtualCheckup
     * const virtualCheckup = await prisma.virtualCheckup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VirtualCheckupUpdateArgs>(args: SelectSubset<T, VirtualCheckupUpdateArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VirtualCheckups.
     * @param {VirtualCheckupDeleteManyArgs} args - Arguments to filter VirtualCheckups to delete.
     * @example
     * // Delete a few VirtualCheckups
     * const { count } = await prisma.virtualCheckup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VirtualCheckupDeleteManyArgs>(args?: SelectSubset<T, VirtualCheckupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VirtualCheckups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VirtualCheckups
     * const virtualCheckup = await prisma.virtualCheckup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VirtualCheckupUpdateManyArgs>(args: SelectSubset<T, VirtualCheckupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VirtualCheckup.
     * @param {VirtualCheckupUpsertArgs} args - Arguments to update or create a VirtualCheckup.
     * @example
     * // Update or create a VirtualCheckup
     * const virtualCheckup = await prisma.virtualCheckup.upsert({
     *   create: {
     *     // ... data to create a VirtualCheckup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VirtualCheckup we want to update
     *   }
     * })
     */
    upsert<T extends VirtualCheckupUpsertArgs>(args: SelectSubset<T, VirtualCheckupUpsertArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VirtualCheckups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupCountArgs} args - Arguments to filter VirtualCheckups to count.
     * @example
     * // Count the number of VirtualCheckups
     * const count = await prisma.virtualCheckup.count({
     *   where: {
     *     // ... the filter for the VirtualCheckups we want to count
     *   }
     * })
    **/
    count<T extends VirtualCheckupCountArgs>(
      args?: Subset<T, VirtualCheckupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VirtualCheckupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VirtualCheckup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VirtualCheckupAggregateArgs>(args: Subset<T, VirtualCheckupAggregateArgs>): Prisma.PrismaPromise<GetVirtualCheckupAggregateType<T>>

    /**
     * Group by VirtualCheckup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VirtualCheckupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VirtualCheckupGroupByArgs['orderBy'] }
        : { orderBy?: VirtualCheckupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VirtualCheckupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtualCheckupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VirtualCheckup model
   */
  readonly fields: VirtualCheckupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VirtualCheckup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VirtualCheckupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    healthWorker<T extends HealthWorkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HealthWorkerDefaultArgs<ExtArgs>>): Prisma__HealthWorkerClient<$Result.GetResult<Prisma.$HealthWorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    virtualCheckupNotes<T extends VirtualCheckup$virtualCheckupNotesArgs<ExtArgs> = {}>(args?: Subset<T, VirtualCheckup$virtualCheckupNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VirtualCheckup model
   */
  interface VirtualCheckupFieldRefs {
    readonly id: FieldRef<"VirtualCheckup", 'String'>
    readonly userProfileId: FieldRef<"VirtualCheckup", 'String'>
    readonly healthWorkerId: FieldRef<"VirtualCheckup", 'String'>
    readonly scheduledDate: FieldRef<"VirtualCheckup", 'DateTime'>
    readonly scheduledTime: FieldRef<"VirtualCheckup", 'String'>
    readonly meetingUrl: FieldRef<"VirtualCheckup", 'String'>
    readonly status: FieldRef<"VirtualCheckup", 'String'>
    readonly consultationType: FieldRef<"VirtualCheckup", 'String'>
    readonly chiefComplaint: FieldRef<"VirtualCheckup", 'String'>
    readonly notes: FieldRef<"VirtualCheckup", 'String'>
    readonly durationMinutes: FieldRef<"VirtualCheckup", 'Int'>
    readonly createdAt: FieldRef<"VirtualCheckup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VirtualCheckup findUnique
   */
  export type VirtualCheckupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckup to fetch.
     */
    where: VirtualCheckupWhereUniqueInput
  }

  /**
   * VirtualCheckup findUniqueOrThrow
   */
  export type VirtualCheckupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckup to fetch.
     */
    where: VirtualCheckupWhereUniqueInput
  }

  /**
   * VirtualCheckup findFirst
   */
  export type VirtualCheckupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckup to fetch.
     */
    where?: VirtualCheckupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckups to fetch.
     */
    orderBy?: VirtualCheckupOrderByWithRelationInput | VirtualCheckupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualCheckups.
     */
    cursor?: VirtualCheckupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualCheckups.
     */
    distinct?: VirtualCheckupScalarFieldEnum | VirtualCheckupScalarFieldEnum[]
  }

  /**
   * VirtualCheckup findFirstOrThrow
   */
  export type VirtualCheckupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckup to fetch.
     */
    where?: VirtualCheckupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckups to fetch.
     */
    orderBy?: VirtualCheckupOrderByWithRelationInput | VirtualCheckupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualCheckups.
     */
    cursor?: VirtualCheckupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualCheckups.
     */
    distinct?: VirtualCheckupScalarFieldEnum | VirtualCheckupScalarFieldEnum[]
  }

  /**
   * VirtualCheckup findMany
   */
  export type VirtualCheckupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckups to fetch.
     */
    where?: VirtualCheckupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckups to fetch.
     */
    orderBy?: VirtualCheckupOrderByWithRelationInput | VirtualCheckupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VirtualCheckups.
     */
    cursor?: VirtualCheckupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckups.
     */
    skip?: number
    distinct?: VirtualCheckupScalarFieldEnum | VirtualCheckupScalarFieldEnum[]
  }

  /**
   * VirtualCheckup create
   */
  export type VirtualCheckupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * The data needed to create a VirtualCheckup.
     */
    data: XOR<VirtualCheckupCreateInput, VirtualCheckupUncheckedCreateInput>
  }

  /**
   * VirtualCheckup createMany
   */
  export type VirtualCheckupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VirtualCheckups.
     */
    data: VirtualCheckupCreateManyInput | VirtualCheckupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VirtualCheckup update
   */
  export type VirtualCheckupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * The data needed to update a VirtualCheckup.
     */
    data: XOR<VirtualCheckupUpdateInput, VirtualCheckupUncheckedUpdateInput>
    /**
     * Choose, which VirtualCheckup to update.
     */
    where: VirtualCheckupWhereUniqueInput
  }

  /**
   * VirtualCheckup updateMany
   */
  export type VirtualCheckupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VirtualCheckups.
     */
    data: XOR<VirtualCheckupUpdateManyMutationInput, VirtualCheckupUncheckedUpdateManyInput>
    /**
     * Filter which VirtualCheckups to update
     */
    where?: VirtualCheckupWhereInput
    /**
     * Limit how many VirtualCheckups to update.
     */
    limit?: number
  }

  /**
   * VirtualCheckup upsert
   */
  export type VirtualCheckupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * The filter to search for the VirtualCheckup to update in case it exists.
     */
    where: VirtualCheckupWhereUniqueInput
    /**
     * In case the VirtualCheckup found by the `where` argument doesn't exist, create a new VirtualCheckup with this data.
     */
    create: XOR<VirtualCheckupCreateInput, VirtualCheckupUncheckedCreateInput>
    /**
     * In case the VirtualCheckup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VirtualCheckupUpdateInput, VirtualCheckupUncheckedUpdateInput>
  }

  /**
   * VirtualCheckup delete
   */
  export type VirtualCheckupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
    /**
     * Filter which VirtualCheckup to delete.
     */
    where: VirtualCheckupWhereUniqueInput
  }

  /**
   * VirtualCheckup deleteMany
   */
  export type VirtualCheckupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualCheckups to delete
     */
    where?: VirtualCheckupWhereInput
    /**
     * Limit how many VirtualCheckups to delete.
     */
    limit?: number
  }

  /**
   * VirtualCheckup.virtualCheckupNotes
   */
  export type VirtualCheckup$virtualCheckupNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    where?: VirtualCheckupNoteWhereInput
    orderBy?: VirtualCheckupNoteOrderByWithRelationInput | VirtualCheckupNoteOrderByWithRelationInput[]
    cursor?: VirtualCheckupNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualCheckupNoteScalarFieldEnum | VirtualCheckupNoteScalarFieldEnum[]
  }

  /**
   * VirtualCheckup without action
   */
  export type VirtualCheckupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckup
     */
    select?: VirtualCheckupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckup
     */
    omit?: VirtualCheckupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupInclude<ExtArgs> | null
  }


  /**
   * Model VirtualCheckupNote
   */

  export type AggregateVirtualCheckupNote = {
    _count: VirtualCheckupNoteCountAggregateOutputType | null
    _min: VirtualCheckupNoteMinAggregateOutputType | null
    _max: VirtualCheckupNoteMaxAggregateOutputType | null
  }

  export type VirtualCheckupNoteMinAggregateOutputType = {
    id: string | null
    virtualCheckupId: string | null
    note: string | null
    createdBy: string | null
  }

  export type VirtualCheckupNoteMaxAggregateOutputType = {
    id: string | null
    virtualCheckupId: string | null
    note: string | null
    createdBy: string | null
  }

  export type VirtualCheckupNoteCountAggregateOutputType = {
    id: number
    virtualCheckupId: number
    note: number
    createdBy: number
    _all: number
  }


  export type VirtualCheckupNoteMinAggregateInputType = {
    id?: true
    virtualCheckupId?: true
    note?: true
    createdBy?: true
  }

  export type VirtualCheckupNoteMaxAggregateInputType = {
    id?: true
    virtualCheckupId?: true
    note?: true
    createdBy?: true
  }

  export type VirtualCheckupNoteCountAggregateInputType = {
    id?: true
    virtualCheckupId?: true
    note?: true
    createdBy?: true
    _all?: true
  }

  export type VirtualCheckupNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualCheckupNote to aggregate.
     */
    where?: VirtualCheckupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckupNotes to fetch.
     */
    orderBy?: VirtualCheckupNoteOrderByWithRelationInput | VirtualCheckupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VirtualCheckupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckupNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VirtualCheckupNotes
    **/
    _count?: true | VirtualCheckupNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VirtualCheckupNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VirtualCheckupNoteMaxAggregateInputType
  }

  export type GetVirtualCheckupNoteAggregateType<T extends VirtualCheckupNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtualCheckupNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtualCheckupNote[P]>
      : GetScalarType<T[P], AggregateVirtualCheckupNote[P]>
  }




  export type VirtualCheckupNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualCheckupNoteWhereInput
    orderBy?: VirtualCheckupNoteOrderByWithAggregationInput | VirtualCheckupNoteOrderByWithAggregationInput[]
    by: VirtualCheckupNoteScalarFieldEnum[] | VirtualCheckupNoteScalarFieldEnum
    having?: VirtualCheckupNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VirtualCheckupNoteCountAggregateInputType | true
    _min?: VirtualCheckupNoteMinAggregateInputType
    _max?: VirtualCheckupNoteMaxAggregateInputType
  }

  export type VirtualCheckupNoteGroupByOutputType = {
    id: string
    virtualCheckupId: string
    note: string
    createdBy: string
    _count: VirtualCheckupNoteCountAggregateOutputType | null
    _min: VirtualCheckupNoteMinAggregateOutputType | null
    _max: VirtualCheckupNoteMaxAggregateOutputType | null
  }

  type GetVirtualCheckupNoteGroupByPayload<T extends VirtualCheckupNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VirtualCheckupNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VirtualCheckupNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VirtualCheckupNoteGroupByOutputType[P]>
            : GetScalarType<T[P], VirtualCheckupNoteGroupByOutputType[P]>
        }
      >
    >


  export type VirtualCheckupNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    virtualCheckupId?: boolean
    note?: boolean
    createdBy?: boolean
    virtualCheckup?: boolean | VirtualCheckupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualCheckupNote"]>



  export type VirtualCheckupNoteSelectScalar = {
    id?: boolean
    virtualCheckupId?: boolean
    note?: boolean
    createdBy?: boolean
  }

  export type VirtualCheckupNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "virtualCheckupId" | "note" | "createdBy", ExtArgs["result"]["virtualCheckupNote"]>
  export type VirtualCheckupNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualCheckup?: boolean | VirtualCheckupDefaultArgs<ExtArgs>
  }

  export type $VirtualCheckupNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VirtualCheckupNote"
    objects: {
      virtualCheckup: Prisma.$VirtualCheckupPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      virtualCheckupId: string
      note: string
      createdBy: string
    }, ExtArgs["result"]["virtualCheckupNote"]>
    composites: {}
  }

  type VirtualCheckupNoteGetPayload<S extends boolean | null | undefined | VirtualCheckupNoteDefaultArgs> = $Result.GetResult<Prisma.$VirtualCheckupNotePayload, S>

  type VirtualCheckupNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VirtualCheckupNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VirtualCheckupNoteCountAggregateInputType | true
    }

  export interface VirtualCheckupNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VirtualCheckupNote'], meta: { name: 'VirtualCheckupNote' } }
    /**
     * Find zero or one VirtualCheckupNote that matches the filter.
     * @param {VirtualCheckupNoteFindUniqueArgs} args - Arguments to find a VirtualCheckupNote
     * @example
     * // Get one VirtualCheckupNote
     * const virtualCheckupNote = await prisma.virtualCheckupNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VirtualCheckupNoteFindUniqueArgs>(args: SelectSubset<T, VirtualCheckupNoteFindUniqueArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VirtualCheckupNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VirtualCheckupNoteFindUniqueOrThrowArgs} args - Arguments to find a VirtualCheckupNote
     * @example
     * // Get one VirtualCheckupNote
     * const virtualCheckupNote = await prisma.virtualCheckupNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VirtualCheckupNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VirtualCheckupNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VirtualCheckupNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupNoteFindFirstArgs} args - Arguments to find a VirtualCheckupNote
     * @example
     * // Get one VirtualCheckupNote
     * const virtualCheckupNote = await prisma.virtualCheckupNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VirtualCheckupNoteFindFirstArgs>(args?: SelectSubset<T, VirtualCheckupNoteFindFirstArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VirtualCheckupNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupNoteFindFirstOrThrowArgs} args - Arguments to find a VirtualCheckupNote
     * @example
     * // Get one VirtualCheckupNote
     * const virtualCheckupNote = await prisma.virtualCheckupNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VirtualCheckupNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VirtualCheckupNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VirtualCheckupNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VirtualCheckupNotes
     * const virtualCheckupNotes = await prisma.virtualCheckupNote.findMany()
     * 
     * // Get first 10 VirtualCheckupNotes
     * const virtualCheckupNotes = await prisma.virtualCheckupNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtualCheckupNoteWithIdOnly = await prisma.virtualCheckupNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VirtualCheckupNoteFindManyArgs>(args?: SelectSubset<T, VirtualCheckupNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VirtualCheckupNote.
     * @param {VirtualCheckupNoteCreateArgs} args - Arguments to create a VirtualCheckupNote.
     * @example
     * // Create one VirtualCheckupNote
     * const VirtualCheckupNote = await prisma.virtualCheckupNote.create({
     *   data: {
     *     // ... data to create a VirtualCheckupNote
     *   }
     * })
     * 
     */
    create<T extends VirtualCheckupNoteCreateArgs>(args: SelectSubset<T, VirtualCheckupNoteCreateArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VirtualCheckupNotes.
     * @param {VirtualCheckupNoteCreateManyArgs} args - Arguments to create many VirtualCheckupNotes.
     * @example
     * // Create many VirtualCheckupNotes
     * const virtualCheckupNote = await prisma.virtualCheckupNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VirtualCheckupNoteCreateManyArgs>(args?: SelectSubset<T, VirtualCheckupNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VirtualCheckupNote.
     * @param {VirtualCheckupNoteDeleteArgs} args - Arguments to delete one VirtualCheckupNote.
     * @example
     * // Delete one VirtualCheckupNote
     * const VirtualCheckupNote = await prisma.virtualCheckupNote.delete({
     *   where: {
     *     // ... filter to delete one VirtualCheckupNote
     *   }
     * })
     * 
     */
    delete<T extends VirtualCheckupNoteDeleteArgs>(args: SelectSubset<T, VirtualCheckupNoteDeleteArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VirtualCheckupNote.
     * @param {VirtualCheckupNoteUpdateArgs} args - Arguments to update one VirtualCheckupNote.
     * @example
     * // Update one VirtualCheckupNote
     * const virtualCheckupNote = await prisma.virtualCheckupNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VirtualCheckupNoteUpdateArgs>(args: SelectSubset<T, VirtualCheckupNoteUpdateArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VirtualCheckupNotes.
     * @param {VirtualCheckupNoteDeleteManyArgs} args - Arguments to filter VirtualCheckupNotes to delete.
     * @example
     * // Delete a few VirtualCheckupNotes
     * const { count } = await prisma.virtualCheckupNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VirtualCheckupNoteDeleteManyArgs>(args?: SelectSubset<T, VirtualCheckupNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VirtualCheckupNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VirtualCheckupNotes
     * const virtualCheckupNote = await prisma.virtualCheckupNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VirtualCheckupNoteUpdateManyArgs>(args: SelectSubset<T, VirtualCheckupNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VirtualCheckupNote.
     * @param {VirtualCheckupNoteUpsertArgs} args - Arguments to update or create a VirtualCheckupNote.
     * @example
     * // Update or create a VirtualCheckupNote
     * const virtualCheckupNote = await prisma.virtualCheckupNote.upsert({
     *   create: {
     *     // ... data to create a VirtualCheckupNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VirtualCheckupNote we want to update
     *   }
     * })
     */
    upsert<T extends VirtualCheckupNoteUpsertArgs>(args: SelectSubset<T, VirtualCheckupNoteUpsertArgs<ExtArgs>>): Prisma__VirtualCheckupNoteClient<$Result.GetResult<Prisma.$VirtualCheckupNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VirtualCheckupNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupNoteCountArgs} args - Arguments to filter VirtualCheckupNotes to count.
     * @example
     * // Count the number of VirtualCheckupNotes
     * const count = await prisma.virtualCheckupNote.count({
     *   where: {
     *     // ... the filter for the VirtualCheckupNotes we want to count
     *   }
     * })
    **/
    count<T extends VirtualCheckupNoteCountArgs>(
      args?: Subset<T, VirtualCheckupNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VirtualCheckupNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VirtualCheckupNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VirtualCheckupNoteAggregateArgs>(args: Subset<T, VirtualCheckupNoteAggregateArgs>): Prisma.PrismaPromise<GetVirtualCheckupNoteAggregateType<T>>

    /**
     * Group by VirtualCheckupNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualCheckupNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VirtualCheckupNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VirtualCheckupNoteGroupByArgs['orderBy'] }
        : { orderBy?: VirtualCheckupNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VirtualCheckupNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtualCheckupNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VirtualCheckupNote model
   */
  readonly fields: VirtualCheckupNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VirtualCheckupNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VirtualCheckupNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    virtualCheckup<T extends VirtualCheckupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VirtualCheckupDefaultArgs<ExtArgs>>): Prisma__VirtualCheckupClient<$Result.GetResult<Prisma.$VirtualCheckupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VirtualCheckupNote model
   */
  interface VirtualCheckupNoteFieldRefs {
    readonly id: FieldRef<"VirtualCheckupNote", 'String'>
    readonly virtualCheckupId: FieldRef<"VirtualCheckupNote", 'String'>
    readonly note: FieldRef<"VirtualCheckupNote", 'String'>
    readonly createdBy: FieldRef<"VirtualCheckupNote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VirtualCheckupNote findUnique
   */
  export type VirtualCheckupNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckupNote to fetch.
     */
    where: VirtualCheckupNoteWhereUniqueInput
  }

  /**
   * VirtualCheckupNote findUniqueOrThrow
   */
  export type VirtualCheckupNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckupNote to fetch.
     */
    where: VirtualCheckupNoteWhereUniqueInput
  }

  /**
   * VirtualCheckupNote findFirst
   */
  export type VirtualCheckupNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckupNote to fetch.
     */
    where?: VirtualCheckupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckupNotes to fetch.
     */
    orderBy?: VirtualCheckupNoteOrderByWithRelationInput | VirtualCheckupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualCheckupNotes.
     */
    cursor?: VirtualCheckupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckupNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualCheckupNotes.
     */
    distinct?: VirtualCheckupNoteScalarFieldEnum | VirtualCheckupNoteScalarFieldEnum[]
  }

  /**
   * VirtualCheckupNote findFirstOrThrow
   */
  export type VirtualCheckupNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckupNote to fetch.
     */
    where?: VirtualCheckupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckupNotes to fetch.
     */
    orderBy?: VirtualCheckupNoteOrderByWithRelationInput | VirtualCheckupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualCheckupNotes.
     */
    cursor?: VirtualCheckupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckupNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualCheckupNotes.
     */
    distinct?: VirtualCheckupNoteScalarFieldEnum | VirtualCheckupNoteScalarFieldEnum[]
  }

  /**
   * VirtualCheckupNote findMany
   */
  export type VirtualCheckupNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * Filter, which VirtualCheckupNotes to fetch.
     */
    where?: VirtualCheckupNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualCheckupNotes to fetch.
     */
    orderBy?: VirtualCheckupNoteOrderByWithRelationInput | VirtualCheckupNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VirtualCheckupNotes.
     */
    cursor?: VirtualCheckupNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualCheckupNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualCheckupNotes.
     */
    skip?: number
    distinct?: VirtualCheckupNoteScalarFieldEnum | VirtualCheckupNoteScalarFieldEnum[]
  }

  /**
   * VirtualCheckupNote create
   */
  export type VirtualCheckupNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a VirtualCheckupNote.
     */
    data: XOR<VirtualCheckupNoteCreateInput, VirtualCheckupNoteUncheckedCreateInput>
  }

  /**
   * VirtualCheckupNote createMany
   */
  export type VirtualCheckupNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VirtualCheckupNotes.
     */
    data: VirtualCheckupNoteCreateManyInput | VirtualCheckupNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VirtualCheckupNote update
   */
  export type VirtualCheckupNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a VirtualCheckupNote.
     */
    data: XOR<VirtualCheckupNoteUpdateInput, VirtualCheckupNoteUncheckedUpdateInput>
    /**
     * Choose, which VirtualCheckupNote to update.
     */
    where: VirtualCheckupNoteWhereUniqueInput
  }

  /**
   * VirtualCheckupNote updateMany
   */
  export type VirtualCheckupNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VirtualCheckupNotes.
     */
    data: XOR<VirtualCheckupNoteUpdateManyMutationInput, VirtualCheckupNoteUncheckedUpdateManyInput>
    /**
     * Filter which VirtualCheckupNotes to update
     */
    where?: VirtualCheckupNoteWhereInput
    /**
     * Limit how many VirtualCheckupNotes to update.
     */
    limit?: number
  }

  /**
   * VirtualCheckupNote upsert
   */
  export type VirtualCheckupNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the VirtualCheckupNote to update in case it exists.
     */
    where: VirtualCheckupNoteWhereUniqueInput
    /**
     * In case the VirtualCheckupNote found by the `where` argument doesn't exist, create a new VirtualCheckupNote with this data.
     */
    create: XOR<VirtualCheckupNoteCreateInput, VirtualCheckupNoteUncheckedCreateInput>
    /**
     * In case the VirtualCheckupNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VirtualCheckupNoteUpdateInput, VirtualCheckupNoteUncheckedUpdateInput>
  }

  /**
   * VirtualCheckupNote delete
   */
  export type VirtualCheckupNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
    /**
     * Filter which VirtualCheckupNote to delete.
     */
    where: VirtualCheckupNoteWhereUniqueInput
  }

  /**
   * VirtualCheckupNote deleteMany
   */
  export type VirtualCheckupNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualCheckupNotes to delete
     */
    where?: VirtualCheckupNoteWhereInput
    /**
     * Limit how many VirtualCheckupNotes to delete.
     */
    limit?: number
  }

  /**
   * VirtualCheckupNote without action
   */
  export type VirtualCheckupNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualCheckupNote
     */
    select?: VirtualCheckupNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VirtualCheckupNote
     */
    omit?: VirtualCheckupNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualCheckupNoteInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    maxParticipants: number | null
  }

  export type EventSumAggregateOutputType = {
    maxParticipants: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    eventType: string | null
    eventDate: Date | null
    startTime: string | null
    endTime: string | null
    venue: string | null
    targetAudience: string | null
    maxParticipants: number | null
    status: string | null
    bannerImageUrl: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    eventType: string | null
    eventDate: Date | null
    startTime: string | null
    endTime: string | null
    venue: string | null
    targetAudience: string | null
    maxParticipants: number | null
    status: string | null
    bannerImageUrl: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    eventType: number
    eventDate: number
    startTime: number
    endTime: number
    venue: number
    targetAudience: number
    maxParticipants: number
    status: number
    bannerImageUrl: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    maxParticipants?: true
  }

  export type EventSumAggregateInputType = {
    maxParticipants?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventType?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    venue?: true
    targetAudience?: true
    maxParticipants?: true
    status?: true
    bannerImageUrl?: true
    createdBy?: true
    createdAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventType?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    venue?: true
    targetAudience?: true
    maxParticipants?: true
    status?: true
    bannerImageUrl?: true
    createdBy?: true
    createdAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    eventType?: true
    eventDate?: true
    startTime?: true
    endTime?: true
    venue?: true
    targetAudience?: true
    maxParticipants?: true
    status?: true
    bannerImageUrl?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string
    eventType: string
    eventDate: Date
    startTime: string
    endTime: string
    venue: string
    targetAudience: string | null
    maxParticipants: number | null
    status: string
    bannerImageUrl: string | null
    createdBy: string
    createdAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    eventType?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    targetAudience?: boolean
    maxParticipants?: boolean
    status?: boolean
    bannerImageUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | AccountDefaultArgs<ExtArgs>
    eventRegistrations?: boolean | Event$eventRegistrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>



  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    eventType?: boolean
    eventDate?: boolean
    startTime?: boolean
    endTime?: boolean
    venue?: boolean
    targetAudience?: boolean
    maxParticipants?: boolean
    status?: boolean
    bannerImageUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "eventType" | "eventDate" | "startTime" | "endTime" | "venue" | "targetAudience" | "maxParticipants" | "status" | "bannerImageUrl" | "createdBy" | "createdAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AccountDefaultArgs<ExtArgs>
    eventRegistrations?: boolean | Event$eventRegistrationsArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      creator: Prisma.$AccountPayload<ExtArgs>
      eventRegistrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      eventType: string
      eventDate: Date
      startTime: string
      endTime: string
      venue: string
      targetAudience: string | null
      maxParticipants: number | null
      status: string
      bannerImageUrl: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    eventRegistrations<T extends Event$eventRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Event$eventRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly eventType: FieldRef<"Event", 'String'>
    readonly eventDate: FieldRef<"Event", 'DateTime'>
    readonly startTime: FieldRef<"Event", 'String'>
    readonly endTime: FieldRef<"Event", 'String'>
    readonly venue: FieldRef<"Event", 'String'>
    readonly targetAudience: FieldRef<"Event", 'String'>
    readonly maxParticipants: FieldRef<"Event", 'Int'>
    readonly status: FieldRef<"Event", 'String'>
    readonly bannerImageUrl: FieldRef<"Event", 'String'>
    readonly createdBy: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.eventRegistrations
   */
  export type Event$eventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventRegistration
   */

  export type AggregateEventRegistration = {
    _count: EventRegistrationCountAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  export type EventRegistrationMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userProfileId: string | null
    registrationDate: Date | null
    status: string | null
    notes: string | null
  }

  export type EventRegistrationMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userProfileId: string | null
    registrationDate: Date | null
    status: string | null
    notes: string | null
  }

  export type EventRegistrationCountAggregateOutputType = {
    id: number
    eventId: number
    userProfileId: number
    registrationDate: number
    status: number
    notes: number
    _all: number
  }


  export type EventRegistrationMinAggregateInputType = {
    id?: true
    eventId?: true
    userProfileId?: true
    registrationDate?: true
    status?: true
    notes?: true
  }

  export type EventRegistrationMaxAggregateInputType = {
    id?: true
    eventId?: true
    userProfileId?: true
    registrationDate?: true
    status?: true
    notes?: true
  }

  export type EventRegistrationCountAggregateInputType = {
    id?: true
    eventId?: true
    userProfileId?: true
    registrationDate?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type EventRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistration to aggregate.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventRegistrations
    **/
    _count?: true | EventRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type GetEventRegistrationAggregateType<T extends EventRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRegistration[P]>
      : GetScalarType<T[P], AggregateEventRegistration[P]>
  }




  export type EventRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithAggregationInput | EventRegistrationOrderByWithAggregationInput[]
    by: EventRegistrationScalarFieldEnum[] | EventRegistrationScalarFieldEnum
    having?: EventRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventRegistrationCountAggregateInputType | true
    _min?: EventRegistrationMinAggregateInputType
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type EventRegistrationGroupByOutputType = {
    id: string
    eventId: string
    userProfileId: string
    registrationDate: Date
    status: string
    notes: string | null
    _count: EventRegistrationCountAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  type GetEventRegistrationGroupByPayload<T extends EventRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type EventRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userProfileId?: boolean
    registrationDate?: boolean
    status?: boolean
    notes?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>



  export type EventRegistrationSelectScalar = {
    id?: boolean
    eventId?: boolean
    userProfileId?: boolean
    registrationDate?: boolean
    status?: boolean
    notes?: boolean
  }

  export type EventRegistrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userProfileId" | "registrationDate" | "status" | "notes", ExtArgs["result"]["eventRegistration"]>
  export type EventRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $EventRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventRegistration"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userProfileId: string
      registrationDate: Date
      status: string
      notes: string | null
    }, ExtArgs["result"]["eventRegistration"]>
    composites: {}
  }

  type EventRegistrationGetPayload<S extends boolean | null | undefined | EventRegistrationDefaultArgs> = $Result.GetResult<Prisma.$EventRegistrationPayload, S>

  type EventRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventRegistrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventRegistrationCountAggregateInputType | true
    }

  export interface EventRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRegistration'], meta: { name: 'EventRegistration' } }
    /**
     * Find zero or one EventRegistration that matches the filter.
     * @param {EventRegistrationFindUniqueArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventRegistrationFindUniqueArgs>(args: SelectSubset<T, EventRegistrationFindUniqueArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventRegistration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventRegistrationFindUniqueOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, EventRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventRegistrationFindFirstArgs>(args?: SelectSubset<T, EventRegistrationFindFirstArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, EventRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany()
     * 
     * // Get first 10 EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventRegistrationFindManyArgs>(args?: SelectSubset<T, EventRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventRegistration.
     * @param {EventRegistrationCreateArgs} args - Arguments to create a EventRegistration.
     * @example
     * // Create one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.create({
     *   data: {
     *     // ... data to create a EventRegistration
     *   }
     * })
     * 
     */
    create<T extends EventRegistrationCreateArgs>(args: SelectSubset<T, EventRegistrationCreateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventRegistrations.
     * @param {EventRegistrationCreateManyArgs} args - Arguments to create many EventRegistrations.
     * @example
     * // Create many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventRegistrationCreateManyArgs>(args?: SelectSubset<T, EventRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventRegistration.
     * @param {EventRegistrationDeleteArgs} args - Arguments to delete one EventRegistration.
     * @example
     * // Delete one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.delete({
     *   where: {
     *     // ... filter to delete one EventRegistration
     *   }
     * })
     * 
     */
    delete<T extends EventRegistrationDeleteArgs>(args: SelectSubset<T, EventRegistrationDeleteArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventRegistration.
     * @param {EventRegistrationUpdateArgs} args - Arguments to update one EventRegistration.
     * @example
     * // Update one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventRegistrationUpdateArgs>(args: SelectSubset<T, EventRegistrationUpdateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventRegistrations.
     * @param {EventRegistrationDeleteManyArgs} args - Arguments to filter EventRegistrations to delete.
     * @example
     * // Delete a few EventRegistrations
     * const { count } = await prisma.eventRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventRegistrationDeleteManyArgs>(args?: SelectSubset<T, EventRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventRegistrationUpdateManyArgs>(args: SelectSubset<T, EventRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventRegistration.
     * @param {EventRegistrationUpsertArgs} args - Arguments to update or create a EventRegistration.
     * @example
     * // Update or create a EventRegistration
     * const eventRegistration = await prisma.eventRegistration.upsert({
     *   create: {
     *     // ... data to create a EventRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRegistration we want to update
     *   }
     * })
     */
    upsert<T extends EventRegistrationUpsertArgs>(args: SelectSubset<T, EventRegistrationUpsertArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationCountArgs} args - Arguments to filter EventRegistrations to count.
     * @example
     * // Count the number of EventRegistrations
     * const count = await prisma.eventRegistration.count({
     *   where: {
     *     // ... the filter for the EventRegistrations we want to count
     *   }
     * })
    **/
    count<T extends EventRegistrationCountArgs>(
      args?: Subset<T, EventRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventRegistrationAggregateArgs>(args: Subset<T, EventRegistrationAggregateArgs>): Prisma.PrismaPromise<GetEventRegistrationAggregateType<T>>

    /**
     * Group by EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: EventRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventRegistration model
   */
  readonly fields: EventRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventRegistration model
   */
  interface EventRegistrationFieldRefs {
    readonly id: FieldRef<"EventRegistration", 'String'>
    readonly eventId: FieldRef<"EventRegistration", 'String'>
    readonly userProfileId: FieldRef<"EventRegistration", 'String'>
    readonly registrationDate: FieldRef<"EventRegistration", 'DateTime'>
    readonly status: FieldRef<"EventRegistration", 'String'>
    readonly notes: FieldRef<"EventRegistration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EventRegistration findUnique
   */
  export type EventRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findUniqueOrThrow
   */
  export type EventRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findFirst
   */
  export type EventRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findFirstOrThrow
   */
  export type EventRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findMany
   */
  export type EventRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistrations to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration create
   */
  export type EventRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventRegistration.
     */
    data: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
  }

  /**
   * EventRegistration createMany
   */
  export type EventRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventRegistrations.
     */
    data: EventRegistrationCreateManyInput | EventRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventRegistration update
   */
  export type EventRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventRegistration.
     */
    data: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
    /**
     * Choose, which EventRegistration to update.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration updateMany
   */
  export type EventRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventRegistrations.
     */
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which EventRegistrations to update
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to update.
     */
    limit?: number
  }

  /**
   * EventRegistration upsert
   */
  export type EventRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventRegistration to update in case it exists.
     */
    where: EventRegistrationWhereUniqueInput
    /**
     * In case the EventRegistration found by the `where` argument doesn't exist, create a new EventRegistration with this data.
     */
    create: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
    /**
     * In case the EventRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
  }

  /**
   * EventRegistration delete
   */
  export type EventRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter which EventRegistration to delete.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration deleteMany
   */
  export type EventRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistrations to delete
     */
    where?: EventRegistrationWhereInput
    /**
     * Limit how many EventRegistrations to delete.
     */
    limit?: number
  }

  /**
   * EventRegistration without action
   */
  export type EventRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventRegistration
     */
    omit?: EventRegistrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model MedicalProgram
   */

  export type AggregateMedicalProgram = {
    _count: MedicalProgramCountAggregateOutputType | null
    _avg: MedicalProgramAvgAggregateOutputType | null
    _sum: MedicalProgramSumAggregateOutputType | null
    _min: MedicalProgramMinAggregateOutputType | null
    _max: MedicalProgramMaxAggregateOutputType | null
  }

  export type MedicalProgramAvgAggregateOutputType = {
    targetParticipants: number | null
  }

  export type MedicalProgramSumAggregateOutputType = {
    targetParticipants: number | null
  }

  export type MedicalProgramMinAggregateOutputType = {
    id: string | null
    programName: string | null
    description: string | null
    programType: string | null
    startDate: Date | null
    endDate: Date | null
    venue: string | null
    targetDemographic: string | null
    targetParticipants: number | null
    status: string | null
    bannerImageUrl: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type MedicalProgramMaxAggregateOutputType = {
    id: string | null
    programName: string | null
    description: string | null
    programType: string | null
    startDate: Date | null
    endDate: Date | null
    venue: string | null
    targetDemographic: string | null
    targetParticipants: number | null
    status: string | null
    bannerImageUrl: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type MedicalProgramCountAggregateOutputType = {
    id: number
    programName: number
    description: number
    programType: number
    startDate: number
    endDate: number
    venue: number
    targetDemographic: number
    targetParticipants: number
    status: number
    bannerImageUrl: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type MedicalProgramAvgAggregateInputType = {
    targetParticipants?: true
  }

  export type MedicalProgramSumAggregateInputType = {
    targetParticipants?: true
  }

  export type MedicalProgramMinAggregateInputType = {
    id?: true
    programName?: true
    description?: true
    programType?: true
    startDate?: true
    endDate?: true
    venue?: true
    targetDemographic?: true
    targetParticipants?: true
    status?: true
    bannerImageUrl?: true
    createdBy?: true
    createdAt?: true
  }

  export type MedicalProgramMaxAggregateInputType = {
    id?: true
    programName?: true
    description?: true
    programType?: true
    startDate?: true
    endDate?: true
    venue?: true
    targetDemographic?: true
    targetParticipants?: true
    status?: true
    bannerImageUrl?: true
    createdBy?: true
    createdAt?: true
  }

  export type MedicalProgramCountAggregateInputType = {
    id?: true
    programName?: true
    description?: true
    programType?: true
    startDate?: true
    endDate?: true
    venue?: true
    targetDemographic?: true
    targetParticipants?: true
    status?: true
    bannerImageUrl?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type MedicalProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalProgram to aggregate.
     */
    where?: MedicalProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalPrograms to fetch.
     */
    orderBy?: MedicalProgramOrderByWithRelationInput | MedicalProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalPrograms
    **/
    _count?: true | MedicalProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalProgramMaxAggregateInputType
  }

  export type GetMedicalProgramAggregateType<T extends MedicalProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalProgram[P]>
      : GetScalarType<T[P], AggregateMedicalProgram[P]>
  }




  export type MedicalProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalProgramWhereInput
    orderBy?: MedicalProgramOrderByWithAggregationInput | MedicalProgramOrderByWithAggregationInput[]
    by: MedicalProgramScalarFieldEnum[] | MedicalProgramScalarFieldEnum
    having?: MedicalProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalProgramCountAggregateInputType | true
    _avg?: MedicalProgramAvgAggregateInputType
    _sum?: MedicalProgramSumAggregateInputType
    _min?: MedicalProgramMinAggregateInputType
    _max?: MedicalProgramMaxAggregateInputType
  }

  export type MedicalProgramGroupByOutputType = {
    id: string
    programName: string
    description: string
    programType: string
    startDate: Date
    endDate: Date
    venue: string
    targetDemographic: string | null
    targetParticipants: number | null
    status: string
    bannerImageUrl: string | null
    createdBy: string
    createdAt: Date
    _count: MedicalProgramCountAggregateOutputType | null
    _avg: MedicalProgramAvgAggregateOutputType | null
    _sum: MedicalProgramSumAggregateOutputType | null
    _min: MedicalProgramMinAggregateOutputType | null
    _max: MedicalProgramMaxAggregateOutputType | null
  }

  type GetMedicalProgramGroupByPayload<T extends MedicalProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalProgramGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalProgramGroupByOutputType[P]>
        }
      >
    >


  export type MedicalProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programName?: boolean
    description?: boolean
    programType?: boolean
    startDate?: boolean
    endDate?: boolean
    venue?: boolean
    targetDemographic?: boolean
    targetParticipants?: boolean
    status?: boolean
    bannerImageUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | AccountDefaultArgs<ExtArgs>
    programParticipations?: boolean | MedicalProgram$programParticipationsArgs<ExtArgs>
    _count?: boolean | MedicalProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalProgram"]>



  export type MedicalProgramSelectScalar = {
    id?: boolean
    programName?: boolean
    description?: boolean
    programType?: boolean
    startDate?: boolean
    endDate?: boolean
    venue?: boolean
    targetDemographic?: boolean
    targetParticipants?: boolean
    status?: boolean
    bannerImageUrl?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type MedicalProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "programName" | "description" | "programType" | "startDate" | "endDate" | "venue" | "targetDemographic" | "targetParticipants" | "status" | "bannerImageUrl" | "createdBy" | "createdAt", ExtArgs["result"]["medicalProgram"]>
  export type MedicalProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AccountDefaultArgs<ExtArgs>
    programParticipations?: boolean | MedicalProgram$programParticipationsArgs<ExtArgs>
    _count?: boolean | MedicalProgramCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MedicalProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalProgram"
    objects: {
      creator: Prisma.$AccountPayload<ExtArgs>
      programParticipations: Prisma.$ProgramParticipationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      programName: string
      description: string
      programType: string
      startDate: Date
      endDate: Date
      venue: string
      targetDemographic: string | null
      targetParticipants: number | null
      status: string
      bannerImageUrl: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["medicalProgram"]>
    composites: {}
  }

  type MedicalProgramGetPayload<S extends boolean | null | undefined | MedicalProgramDefaultArgs> = $Result.GetResult<Prisma.$MedicalProgramPayload, S>

  type MedicalProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalProgramCountAggregateInputType | true
    }

  export interface MedicalProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalProgram'], meta: { name: 'MedicalProgram' } }
    /**
     * Find zero or one MedicalProgram that matches the filter.
     * @param {MedicalProgramFindUniqueArgs} args - Arguments to find a MedicalProgram
     * @example
     * // Get one MedicalProgram
     * const medicalProgram = await prisma.medicalProgram.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalProgramFindUniqueArgs>(args: SelectSubset<T, MedicalProgramFindUniqueArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalProgram that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalProgramFindUniqueOrThrowArgs} args - Arguments to find a MedicalProgram
     * @example
     * // Get one MedicalProgram
     * const medicalProgram = await prisma.medicalProgram.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalProgram that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalProgramFindFirstArgs} args - Arguments to find a MedicalProgram
     * @example
     * // Get one MedicalProgram
     * const medicalProgram = await prisma.medicalProgram.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalProgramFindFirstArgs>(args?: SelectSubset<T, MedicalProgramFindFirstArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalProgram that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalProgramFindFirstOrThrowArgs} args - Arguments to find a MedicalProgram
     * @example
     * // Get one MedicalProgram
     * const medicalProgram = await prisma.medicalProgram.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalPrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalPrograms
     * const medicalPrograms = await prisma.medicalProgram.findMany()
     * 
     * // Get first 10 MedicalPrograms
     * const medicalPrograms = await prisma.medicalProgram.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalProgramWithIdOnly = await prisma.medicalProgram.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalProgramFindManyArgs>(args?: SelectSubset<T, MedicalProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalProgram.
     * @param {MedicalProgramCreateArgs} args - Arguments to create a MedicalProgram.
     * @example
     * // Create one MedicalProgram
     * const MedicalProgram = await prisma.medicalProgram.create({
     *   data: {
     *     // ... data to create a MedicalProgram
     *   }
     * })
     * 
     */
    create<T extends MedicalProgramCreateArgs>(args: SelectSubset<T, MedicalProgramCreateArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalPrograms.
     * @param {MedicalProgramCreateManyArgs} args - Arguments to create many MedicalPrograms.
     * @example
     * // Create many MedicalPrograms
     * const medicalProgram = await prisma.medicalProgram.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalProgramCreateManyArgs>(args?: SelectSubset<T, MedicalProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalProgram.
     * @param {MedicalProgramDeleteArgs} args - Arguments to delete one MedicalProgram.
     * @example
     * // Delete one MedicalProgram
     * const MedicalProgram = await prisma.medicalProgram.delete({
     *   where: {
     *     // ... filter to delete one MedicalProgram
     *   }
     * })
     * 
     */
    delete<T extends MedicalProgramDeleteArgs>(args: SelectSubset<T, MedicalProgramDeleteArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalProgram.
     * @param {MedicalProgramUpdateArgs} args - Arguments to update one MedicalProgram.
     * @example
     * // Update one MedicalProgram
     * const medicalProgram = await prisma.medicalProgram.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalProgramUpdateArgs>(args: SelectSubset<T, MedicalProgramUpdateArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalPrograms.
     * @param {MedicalProgramDeleteManyArgs} args - Arguments to filter MedicalPrograms to delete.
     * @example
     * // Delete a few MedicalPrograms
     * const { count } = await prisma.medicalProgram.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalProgramDeleteManyArgs>(args?: SelectSubset<T, MedicalProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalPrograms
     * const medicalProgram = await prisma.medicalProgram.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalProgramUpdateManyArgs>(args: SelectSubset<T, MedicalProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalProgram.
     * @param {MedicalProgramUpsertArgs} args - Arguments to update or create a MedicalProgram.
     * @example
     * // Update or create a MedicalProgram
     * const medicalProgram = await prisma.medicalProgram.upsert({
     *   create: {
     *     // ... data to create a MedicalProgram
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalProgram we want to update
     *   }
     * })
     */
    upsert<T extends MedicalProgramUpsertArgs>(args: SelectSubset<T, MedicalProgramUpsertArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalPrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalProgramCountArgs} args - Arguments to filter MedicalPrograms to count.
     * @example
     * // Count the number of MedicalPrograms
     * const count = await prisma.medicalProgram.count({
     *   where: {
     *     // ... the filter for the MedicalPrograms we want to count
     *   }
     * })
    **/
    count<T extends MedicalProgramCountArgs>(
      args?: Subset<T, MedicalProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalProgramAggregateArgs>(args: Subset<T, MedicalProgramAggregateArgs>): Prisma.PrismaPromise<GetMedicalProgramAggregateType<T>>

    /**
     * Group by MedicalProgram.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalProgramGroupByArgs['orderBy'] }
        : { orderBy?: MedicalProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalProgram model
   */
  readonly fields: MedicalProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalProgram.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    programParticipations<T extends MedicalProgram$programParticipationsArgs<ExtArgs> = {}>(args?: Subset<T, MedicalProgram$programParticipationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalProgram model
   */
  interface MedicalProgramFieldRefs {
    readonly id: FieldRef<"MedicalProgram", 'String'>
    readonly programName: FieldRef<"MedicalProgram", 'String'>
    readonly description: FieldRef<"MedicalProgram", 'String'>
    readonly programType: FieldRef<"MedicalProgram", 'String'>
    readonly startDate: FieldRef<"MedicalProgram", 'DateTime'>
    readonly endDate: FieldRef<"MedicalProgram", 'DateTime'>
    readonly venue: FieldRef<"MedicalProgram", 'String'>
    readonly targetDemographic: FieldRef<"MedicalProgram", 'String'>
    readonly targetParticipants: FieldRef<"MedicalProgram", 'Int'>
    readonly status: FieldRef<"MedicalProgram", 'String'>
    readonly bannerImageUrl: FieldRef<"MedicalProgram", 'String'>
    readonly createdBy: FieldRef<"MedicalProgram", 'String'>
    readonly createdAt: FieldRef<"MedicalProgram", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalProgram findUnique
   */
  export type MedicalProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * Filter, which MedicalProgram to fetch.
     */
    where: MedicalProgramWhereUniqueInput
  }

  /**
   * MedicalProgram findUniqueOrThrow
   */
  export type MedicalProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * Filter, which MedicalProgram to fetch.
     */
    where: MedicalProgramWhereUniqueInput
  }

  /**
   * MedicalProgram findFirst
   */
  export type MedicalProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * Filter, which MedicalProgram to fetch.
     */
    where?: MedicalProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalPrograms to fetch.
     */
    orderBy?: MedicalProgramOrderByWithRelationInput | MedicalProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalPrograms.
     */
    cursor?: MedicalProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalPrograms.
     */
    distinct?: MedicalProgramScalarFieldEnum | MedicalProgramScalarFieldEnum[]
  }

  /**
   * MedicalProgram findFirstOrThrow
   */
  export type MedicalProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * Filter, which MedicalProgram to fetch.
     */
    where?: MedicalProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalPrograms to fetch.
     */
    orderBy?: MedicalProgramOrderByWithRelationInput | MedicalProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalPrograms.
     */
    cursor?: MedicalProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalPrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalPrograms.
     */
    distinct?: MedicalProgramScalarFieldEnum | MedicalProgramScalarFieldEnum[]
  }

  /**
   * MedicalProgram findMany
   */
  export type MedicalProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * Filter, which MedicalPrograms to fetch.
     */
    where?: MedicalProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalPrograms to fetch.
     */
    orderBy?: MedicalProgramOrderByWithRelationInput | MedicalProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalPrograms.
     */
    cursor?: MedicalProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalPrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalPrograms.
     */
    skip?: number
    distinct?: MedicalProgramScalarFieldEnum | MedicalProgramScalarFieldEnum[]
  }

  /**
   * MedicalProgram create
   */
  export type MedicalProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalProgram.
     */
    data: XOR<MedicalProgramCreateInput, MedicalProgramUncheckedCreateInput>
  }

  /**
   * MedicalProgram createMany
   */
  export type MedicalProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalPrograms.
     */
    data: MedicalProgramCreateManyInput | MedicalProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalProgram update
   */
  export type MedicalProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalProgram.
     */
    data: XOR<MedicalProgramUpdateInput, MedicalProgramUncheckedUpdateInput>
    /**
     * Choose, which MedicalProgram to update.
     */
    where: MedicalProgramWhereUniqueInput
  }

  /**
   * MedicalProgram updateMany
   */
  export type MedicalProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalPrograms.
     */
    data: XOR<MedicalProgramUpdateManyMutationInput, MedicalProgramUncheckedUpdateManyInput>
    /**
     * Filter which MedicalPrograms to update
     */
    where?: MedicalProgramWhereInput
    /**
     * Limit how many MedicalPrograms to update.
     */
    limit?: number
  }

  /**
   * MedicalProgram upsert
   */
  export type MedicalProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalProgram to update in case it exists.
     */
    where: MedicalProgramWhereUniqueInput
    /**
     * In case the MedicalProgram found by the `where` argument doesn't exist, create a new MedicalProgram with this data.
     */
    create: XOR<MedicalProgramCreateInput, MedicalProgramUncheckedCreateInput>
    /**
     * In case the MedicalProgram was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalProgramUpdateInput, MedicalProgramUncheckedUpdateInput>
  }

  /**
   * MedicalProgram delete
   */
  export type MedicalProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
    /**
     * Filter which MedicalProgram to delete.
     */
    where: MedicalProgramWhereUniqueInput
  }

  /**
   * MedicalProgram deleteMany
   */
  export type MedicalProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalPrograms to delete
     */
    where?: MedicalProgramWhereInput
    /**
     * Limit how many MedicalPrograms to delete.
     */
    limit?: number
  }

  /**
   * MedicalProgram.programParticipations
   */
  export type MedicalProgram$programParticipationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    where?: ProgramParticipationWhereInput
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    cursor?: ProgramParticipationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }

  /**
   * MedicalProgram without action
   */
  export type MedicalProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalProgram
     */
    select?: MedicalProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalProgram
     */
    omit?: MedicalProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalProgramInclude<ExtArgs> | null
  }


  /**
   * Model ProgramParticipation
   */

  export type AggregateProgramParticipation = {
    _count: ProgramParticipationCountAggregateOutputType | null
    _min: ProgramParticipationMinAggregateOutputType | null
    _max: ProgramParticipationMaxAggregateOutputType | null
  }

  export type ProgramParticipationMinAggregateOutputType = {
    id: string | null
    medicalProgramId: string | null
    userProfileId: string | null
    participationDate: Date | null
    status: string | null
    servicesReceived: string | null
    notes: string | null
    recordedBy: string | null
  }

  export type ProgramParticipationMaxAggregateOutputType = {
    id: string | null
    medicalProgramId: string | null
    userProfileId: string | null
    participationDate: Date | null
    status: string | null
    servicesReceived: string | null
    notes: string | null
    recordedBy: string | null
  }

  export type ProgramParticipationCountAggregateOutputType = {
    id: number
    medicalProgramId: number
    userProfileId: number
    participationDate: number
    status: number
    servicesReceived: number
    notes: number
    recordedBy: number
    _all: number
  }


  export type ProgramParticipationMinAggregateInputType = {
    id?: true
    medicalProgramId?: true
    userProfileId?: true
    participationDate?: true
    status?: true
    servicesReceived?: true
    notes?: true
    recordedBy?: true
  }

  export type ProgramParticipationMaxAggregateInputType = {
    id?: true
    medicalProgramId?: true
    userProfileId?: true
    participationDate?: true
    status?: true
    servicesReceived?: true
    notes?: true
    recordedBy?: true
  }

  export type ProgramParticipationCountAggregateInputType = {
    id?: true
    medicalProgramId?: true
    userProfileId?: true
    participationDate?: true
    status?: true
    servicesReceived?: true
    notes?: true
    recordedBy?: true
    _all?: true
  }

  export type ProgramParticipationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramParticipation to aggregate.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramParticipations
    **/
    _count?: true | ProgramParticipationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramParticipationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramParticipationMaxAggregateInputType
  }

  export type GetProgramParticipationAggregateType<T extends ProgramParticipationAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramParticipation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramParticipation[P]>
      : GetScalarType<T[P], AggregateProgramParticipation[P]>
  }




  export type ProgramParticipationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramParticipationWhereInput
    orderBy?: ProgramParticipationOrderByWithAggregationInput | ProgramParticipationOrderByWithAggregationInput[]
    by: ProgramParticipationScalarFieldEnum[] | ProgramParticipationScalarFieldEnum
    having?: ProgramParticipationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramParticipationCountAggregateInputType | true
    _min?: ProgramParticipationMinAggregateInputType
    _max?: ProgramParticipationMaxAggregateInputType
  }

  export type ProgramParticipationGroupByOutputType = {
    id: string
    medicalProgramId: string
    userProfileId: string
    participationDate: Date
    status: string
    servicesReceived: string | null
    notes: string | null
    recordedBy: string
    _count: ProgramParticipationCountAggregateOutputType | null
    _min: ProgramParticipationMinAggregateOutputType | null
    _max: ProgramParticipationMaxAggregateOutputType | null
  }

  type GetProgramParticipationGroupByPayload<T extends ProgramParticipationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramParticipationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramParticipationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramParticipationGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramParticipationGroupByOutputType[P]>
        }
      >
    >


  export type ProgramParticipationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalProgramId?: boolean
    userProfileId?: boolean
    participationDate?: boolean
    status?: boolean
    servicesReceived?: boolean
    notes?: boolean
    recordedBy?: boolean
    medicalProgram?: boolean | MedicalProgramDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programParticipation"]>



  export type ProgramParticipationSelectScalar = {
    id?: boolean
    medicalProgramId?: boolean
    userProfileId?: boolean
    participationDate?: boolean
    status?: boolean
    servicesReceived?: boolean
    notes?: boolean
    recordedBy?: boolean
  }

  export type ProgramParticipationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalProgramId" | "userProfileId" | "participationDate" | "status" | "servicesReceived" | "notes" | "recordedBy", ExtArgs["result"]["programParticipation"]>
  export type ProgramParticipationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalProgram?: boolean | MedicalProgramDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $ProgramParticipationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramParticipation"
    objects: {
      medicalProgram: Prisma.$MedicalProgramPayload<ExtArgs>
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicalProgramId: string
      userProfileId: string
      participationDate: Date
      status: string
      servicesReceived: string | null
      notes: string | null
      recordedBy: string
    }, ExtArgs["result"]["programParticipation"]>
    composites: {}
  }

  type ProgramParticipationGetPayload<S extends boolean | null | undefined | ProgramParticipationDefaultArgs> = $Result.GetResult<Prisma.$ProgramParticipationPayload, S>

  type ProgramParticipationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramParticipationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramParticipationCountAggregateInputType | true
    }

  export interface ProgramParticipationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramParticipation'], meta: { name: 'ProgramParticipation' } }
    /**
     * Find zero or one ProgramParticipation that matches the filter.
     * @param {ProgramParticipationFindUniqueArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramParticipationFindUniqueArgs>(args: SelectSubset<T, ProgramParticipationFindUniqueArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramParticipation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramParticipationFindUniqueOrThrowArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramParticipationFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramParticipationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramParticipation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationFindFirstArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramParticipationFindFirstArgs>(args?: SelectSubset<T, ProgramParticipationFindFirstArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramParticipation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationFindFirstOrThrowArgs} args - Arguments to find a ProgramParticipation
     * @example
     * // Get one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramParticipationFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramParticipationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramParticipations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramParticipations
     * const programParticipations = await prisma.programParticipation.findMany()
     * 
     * // Get first 10 ProgramParticipations
     * const programParticipations = await prisma.programParticipation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programParticipationWithIdOnly = await prisma.programParticipation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramParticipationFindManyArgs>(args?: SelectSubset<T, ProgramParticipationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramParticipation.
     * @param {ProgramParticipationCreateArgs} args - Arguments to create a ProgramParticipation.
     * @example
     * // Create one ProgramParticipation
     * const ProgramParticipation = await prisma.programParticipation.create({
     *   data: {
     *     // ... data to create a ProgramParticipation
     *   }
     * })
     * 
     */
    create<T extends ProgramParticipationCreateArgs>(args: SelectSubset<T, ProgramParticipationCreateArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramParticipations.
     * @param {ProgramParticipationCreateManyArgs} args - Arguments to create many ProgramParticipations.
     * @example
     * // Create many ProgramParticipations
     * const programParticipation = await prisma.programParticipation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramParticipationCreateManyArgs>(args?: SelectSubset<T, ProgramParticipationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProgramParticipation.
     * @param {ProgramParticipationDeleteArgs} args - Arguments to delete one ProgramParticipation.
     * @example
     * // Delete one ProgramParticipation
     * const ProgramParticipation = await prisma.programParticipation.delete({
     *   where: {
     *     // ... filter to delete one ProgramParticipation
     *   }
     * })
     * 
     */
    delete<T extends ProgramParticipationDeleteArgs>(args: SelectSubset<T, ProgramParticipationDeleteArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramParticipation.
     * @param {ProgramParticipationUpdateArgs} args - Arguments to update one ProgramParticipation.
     * @example
     * // Update one ProgramParticipation
     * const programParticipation = await prisma.programParticipation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramParticipationUpdateArgs>(args: SelectSubset<T, ProgramParticipationUpdateArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramParticipations.
     * @param {ProgramParticipationDeleteManyArgs} args - Arguments to filter ProgramParticipations to delete.
     * @example
     * // Delete a few ProgramParticipations
     * const { count } = await prisma.programParticipation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramParticipationDeleteManyArgs>(args?: SelectSubset<T, ProgramParticipationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramParticipations
     * const programParticipation = await prisma.programParticipation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramParticipationUpdateManyArgs>(args: SelectSubset<T, ProgramParticipationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramParticipation.
     * @param {ProgramParticipationUpsertArgs} args - Arguments to update or create a ProgramParticipation.
     * @example
     * // Update or create a ProgramParticipation
     * const programParticipation = await prisma.programParticipation.upsert({
     *   create: {
     *     // ... data to create a ProgramParticipation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramParticipation we want to update
     *   }
     * })
     */
    upsert<T extends ProgramParticipationUpsertArgs>(args: SelectSubset<T, ProgramParticipationUpsertArgs<ExtArgs>>): Prisma__ProgramParticipationClient<$Result.GetResult<Prisma.$ProgramParticipationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramParticipations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationCountArgs} args - Arguments to filter ProgramParticipations to count.
     * @example
     * // Count the number of ProgramParticipations
     * const count = await prisma.programParticipation.count({
     *   where: {
     *     // ... the filter for the ProgramParticipations we want to count
     *   }
     * })
    **/
    count<T extends ProgramParticipationCountArgs>(
      args?: Subset<T, ProgramParticipationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramParticipationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramParticipationAggregateArgs>(args: Subset<T, ProgramParticipationAggregateArgs>): Prisma.PrismaPromise<GetProgramParticipationAggregateType<T>>

    /**
     * Group by ProgramParticipation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramParticipationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramParticipationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramParticipationGroupByArgs['orderBy'] }
        : { orderBy?: ProgramParticipationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramParticipationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramParticipationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramParticipation model
   */
  readonly fields: ProgramParticipationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramParticipation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramParticipationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalProgram<T extends MedicalProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalProgramDefaultArgs<ExtArgs>>): Prisma__MedicalProgramClient<$Result.GetResult<Prisma.$MedicalProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramParticipation model
   */
  interface ProgramParticipationFieldRefs {
    readonly id: FieldRef<"ProgramParticipation", 'String'>
    readonly medicalProgramId: FieldRef<"ProgramParticipation", 'String'>
    readonly userProfileId: FieldRef<"ProgramParticipation", 'String'>
    readonly participationDate: FieldRef<"ProgramParticipation", 'DateTime'>
    readonly status: FieldRef<"ProgramParticipation", 'String'>
    readonly servicesReceived: FieldRef<"ProgramParticipation", 'String'>
    readonly notes: FieldRef<"ProgramParticipation", 'String'>
    readonly recordedBy: FieldRef<"ProgramParticipation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProgramParticipation findUnique
   */
  export type ProgramParticipationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where: ProgramParticipationWhereUniqueInput
  }

  /**
   * ProgramParticipation findUniqueOrThrow
   */
  export type ProgramParticipationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where: ProgramParticipationWhereUniqueInput
  }

  /**
   * ProgramParticipation findFirst
   */
  export type ProgramParticipationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramParticipations.
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramParticipations.
     */
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }

  /**
   * ProgramParticipation findFirstOrThrow
   */
  export type ProgramParticipationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipation to fetch.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramParticipations.
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramParticipations.
     */
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }

  /**
   * ProgramParticipation findMany
   */
  export type ProgramParticipationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter, which ProgramParticipations to fetch.
     */
    where?: ProgramParticipationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramParticipations to fetch.
     */
    orderBy?: ProgramParticipationOrderByWithRelationInput | ProgramParticipationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramParticipations.
     */
    cursor?: ProgramParticipationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramParticipations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramParticipations.
     */
    skip?: number
    distinct?: ProgramParticipationScalarFieldEnum | ProgramParticipationScalarFieldEnum[]
  }

  /**
   * ProgramParticipation create
   */
  export type ProgramParticipationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramParticipation.
     */
    data: XOR<ProgramParticipationCreateInput, ProgramParticipationUncheckedCreateInput>
  }

  /**
   * ProgramParticipation createMany
   */
  export type ProgramParticipationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramParticipations.
     */
    data: ProgramParticipationCreateManyInput | ProgramParticipationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramParticipation update
   */
  export type ProgramParticipationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramParticipation.
     */
    data: XOR<ProgramParticipationUpdateInput, ProgramParticipationUncheckedUpdateInput>
    /**
     * Choose, which ProgramParticipation to update.
     */
    where: ProgramParticipationWhereUniqueInput
  }

  /**
   * ProgramParticipation updateMany
   */
  export type ProgramParticipationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramParticipations.
     */
    data: XOR<ProgramParticipationUpdateManyMutationInput, ProgramParticipationUncheckedUpdateManyInput>
    /**
     * Filter which ProgramParticipations to update
     */
    where?: ProgramParticipationWhereInput
    /**
     * Limit how many ProgramParticipations to update.
     */
    limit?: number
  }

  /**
   * ProgramParticipation upsert
   */
  export type ProgramParticipationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramParticipation to update in case it exists.
     */
    where: ProgramParticipationWhereUniqueInput
    /**
     * In case the ProgramParticipation found by the `where` argument doesn't exist, create a new ProgramParticipation with this data.
     */
    create: XOR<ProgramParticipationCreateInput, ProgramParticipationUncheckedCreateInput>
    /**
     * In case the ProgramParticipation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramParticipationUpdateInput, ProgramParticipationUncheckedUpdateInput>
  }

  /**
   * ProgramParticipation delete
   */
  export type ProgramParticipationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
    /**
     * Filter which ProgramParticipation to delete.
     */
    where: ProgramParticipationWhereUniqueInput
  }

  /**
   * ProgramParticipation deleteMany
   */
  export type ProgramParticipationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramParticipations to delete
     */
    where?: ProgramParticipationWhereInput
    /**
     * Limit how many ProgramParticipations to delete.
     */
    limit?: number
  }

  /**
   * ProgramParticipation without action
   */
  export type ProgramParticipationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramParticipation
     */
    select?: ProgramParticipationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramParticipation
     */
    omit?: ProgramParticipationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramParticipationInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryMinAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    subject: string | null
    message: string | null
    priority: string | null
    status: string | null
    category: string | null
    createdAt: Date | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: string | null
    userProfileId: string | null
    subject: string | null
    message: string | null
    priority: string | null
    status: string | null
    category: string | null
    createdAt: Date | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    userProfileId: number
    subject: number
    message: number
    priority: number
    status: number
    category: number
    createdAt: number
    _all: number
  }


  export type InquiryMinAggregateInputType = {
    id?: true
    userProfileId?: true
    subject?: true
    message?: true
    priority?: true
    status?: true
    category?: true
    createdAt?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    userProfileId?: true
    subject?: true
    message?: true
    priority?: true
    status?: true
    category?: true
    createdAt?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    userProfileId?: true
    subject?: true
    message?: true
    priority?: true
    status?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: string
    userProfileId: string
    subject: string
    message: string
    priority: string
    status: string
    category: string | null
    createdAt: Date
    _count: InquiryCountAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userProfileId?: boolean
    subject?: boolean
    message?: boolean
    priority?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    inquiryResponses?: boolean | Inquiry$inquiryResponsesArgs<ExtArgs>
    _count?: boolean | InquiryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>



  export type InquirySelectScalar = {
    id?: boolean
    userProfileId?: boolean
    subject?: boolean
    message?: boolean
    priority?: boolean
    status?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type InquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userProfileId" | "subject" | "message" | "priority" | "status" | "category" | "createdAt", ExtArgs["result"]["inquiry"]>
  export type InquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    inquiryResponses?: boolean | Inquiry$inquiryResponsesArgs<ExtArgs>
    _count?: boolean | InquiryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
      inquiryResponses: Prisma.$InquiryResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userProfileId: string
      subject: string
      message: string
      priority: string
      status: string
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inquiryResponses<T extends Inquiry$inquiryResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$inquiryResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'String'>
    readonly userProfileId: FieldRef<"Inquiry", 'String'>
    readonly subject: FieldRef<"Inquiry", 'String'>
    readonly message: FieldRef<"Inquiry", 'String'>
    readonly priority: FieldRef<"Inquiry", 'String'>
    readonly status: FieldRef<"Inquiry", 'String'>
    readonly category: FieldRef<"Inquiry", 'String'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to update.
     */
    limit?: number
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to delete.
     */
    limit?: number
  }

  /**
   * Inquiry.inquiryResponses
   */
  export type Inquiry$inquiryResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    where?: InquiryResponseWhereInput
    orderBy?: InquiryResponseOrderByWithRelationInput | InquiryResponseOrderByWithRelationInput[]
    cursor?: InquiryResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryResponseScalarFieldEnum | InquiryResponseScalarFieldEnum[]
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
  }


  /**
   * Model InquiryResponse
   */

  export type AggregateInquiryResponse = {
    _count: InquiryResponseCountAggregateOutputType | null
    _min: InquiryResponseMinAggregateOutputType | null
    _max: InquiryResponseMaxAggregateOutputType | null
  }

  export type InquiryResponseMinAggregateOutputType = {
    id: string | null
    inquiryId: string | null
    message: string | null
    respondedBy: string | null
  }

  export type InquiryResponseMaxAggregateOutputType = {
    id: string | null
    inquiryId: string | null
    message: string | null
    respondedBy: string | null
  }

  export type InquiryResponseCountAggregateOutputType = {
    id: number
    inquiryId: number
    message: number
    respondedBy: number
    _all: number
  }


  export type InquiryResponseMinAggregateInputType = {
    id?: true
    inquiryId?: true
    message?: true
    respondedBy?: true
  }

  export type InquiryResponseMaxAggregateInputType = {
    id?: true
    inquiryId?: true
    message?: true
    respondedBy?: true
  }

  export type InquiryResponseCountAggregateInputType = {
    id?: true
    inquiryId?: true
    message?: true
    respondedBy?: true
    _all?: true
  }

  export type InquiryResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InquiryResponse to aggregate.
     */
    where?: InquiryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryResponses to fetch.
     */
    orderBy?: InquiryResponseOrderByWithRelationInput | InquiryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InquiryResponses
    **/
    _count?: true | InquiryResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryResponseMaxAggregateInputType
  }

  export type GetInquiryResponseAggregateType<T extends InquiryResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiryResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiryResponse[P]>
      : GetScalarType<T[P], AggregateInquiryResponse[P]>
  }




  export type InquiryResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryResponseWhereInput
    orderBy?: InquiryResponseOrderByWithAggregationInput | InquiryResponseOrderByWithAggregationInput[]
    by: InquiryResponseScalarFieldEnum[] | InquiryResponseScalarFieldEnum
    having?: InquiryResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryResponseCountAggregateInputType | true
    _min?: InquiryResponseMinAggregateInputType
    _max?: InquiryResponseMaxAggregateInputType
  }

  export type InquiryResponseGroupByOutputType = {
    id: string
    inquiryId: string
    message: string
    respondedBy: string
    _count: InquiryResponseCountAggregateOutputType | null
    _min: InquiryResponseMinAggregateOutputType | null
    _max: InquiryResponseMaxAggregateOutputType | null
  }

  type GetInquiryResponseGroupByPayload<T extends InquiryResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryResponseGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryResponseGroupByOutputType[P]>
        }
      >
    >


  export type InquiryResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inquiryId?: boolean
    message?: boolean
    respondedBy?: boolean
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
    responder?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inquiryResponse"]>



  export type InquiryResponseSelectScalar = {
    id?: boolean
    inquiryId?: boolean
    message?: boolean
    respondedBy?: boolean
  }

  export type InquiryResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inquiryId" | "message" | "respondedBy", ExtArgs["result"]["inquiryResponse"]>
  export type InquiryResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inquiry?: boolean | InquiryDefaultArgs<ExtArgs>
    responder?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $InquiryResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InquiryResponse"
    objects: {
      inquiry: Prisma.$InquiryPayload<ExtArgs>
      responder: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inquiryId: string
      message: string
      respondedBy: string
    }, ExtArgs["result"]["inquiryResponse"]>
    composites: {}
  }

  type InquiryResponseGetPayload<S extends boolean | null | undefined | InquiryResponseDefaultArgs> = $Result.GetResult<Prisma.$InquiryResponsePayload, S>

  type InquiryResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InquiryResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InquiryResponseCountAggregateInputType | true
    }

  export interface InquiryResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InquiryResponse'], meta: { name: 'InquiryResponse' } }
    /**
     * Find zero or one InquiryResponse that matches the filter.
     * @param {InquiryResponseFindUniqueArgs} args - Arguments to find a InquiryResponse
     * @example
     * // Get one InquiryResponse
     * const inquiryResponse = await prisma.inquiryResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryResponseFindUniqueArgs>(args: SelectSubset<T, InquiryResponseFindUniqueArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InquiryResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InquiryResponseFindUniqueOrThrowArgs} args - Arguments to find a InquiryResponse
     * @example
     * // Get one InquiryResponse
     * const inquiryResponse = await prisma.inquiryResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InquiryResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryResponseFindFirstArgs} args - Arguments to find a InquiryResponse
     * @example
     * // Get one InquiryResponse
     * const inquiryResponse = await prisma.inquiryResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryResponseFindFirstArgs>(args?: SelectSubset<T, InquiryResponseFindFirstArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InquiryResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryResponseFindFirstOrThrowArgs} args - Arguments to find a InquiryResponse
     * @example
     * // Get one InquiryResponse
     * const inquiryResponse = await prisma.inquiryResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InquiryResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InquiryResponses
     * const inquiryResponses = await prisma.inquiryResponse.findMany()
     * 
     * // Get first 10 InquiryResponses
     * const inquiryResponses = await prisma.inquiryResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryResponseWithIdOnly = await prisma.inquiryResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryResponseFindManyArgs>(args?: SelectSubset<T, InquiryResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InquiryResponse.
     * @param {InquiryResponseCreateArgs} args - Arguments to create a InquiryResponse.
     * @example
     * // Create one InquiryResponse
     * const InquiryResponse = await prisma.inquiryResponse.create({
     *   data: {
     *     // ... data to create a InquiryResponse
     *   }
     * })
     * 
     */
    create<T extends InquiryResponseCreateArgs>(args: SelectSubset<T, InquiryResponseCreateArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InquiryResponses.
     * @param {InquiryResponseCreateManyArgs} args - Arguments to create many InquiryResponses.
     * @example
     * // Create many InquiryResponses
     * const inquiryResponse = await prisma.inquiryResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryResponseCreateManyArgs>(args?: SelectSubset<T, InquiryResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InquiryResponse.
     * @param {InquiryResponseDeleteArgs} args - Arguments to delete one InquiryResponse.
     * @example
     * // Delete one InquiryResponse
     * const InquiryResponse = await prisma.inquiryResponse.delete({
     *   where: {
     *     // ... filter to delete one InquiryResponse
     *   }
     * })
     * 
     */
    delete<T extends InquiryResponseDeleteArgs>(args: SelectSubset<T, InquiryResponseDeleteArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InquiryResponse.
     * @param {InquiryResponseUpdateArgs} args - Arguments to update one InquiryResponse.
     * @example
     * // Update one InquiryResponse
     * const inquiryResponse = await prisma.inquiryResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryResponseUpdateArgs>(args: SelectSubset<T, InquiryResponseUpdateArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InquiryResponses.
     * @param {InquiryResponseDeleteManyArgs} args - Arguments to filter InquiryResponses to delete.
     * @example
     * // Delete a few InquiryResponses
     * const { count } = await prisma.inquiryResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryResponseDeleteManyArgs>(args?: SelectSubset<T, InquiryResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InquiryResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InquiryResponses
     * const inquiryResponse = await prisma.inquiryResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryResponseUpdateManyArgs>(args: SelectSubset<T, InquiryResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InquiryResponse.
     * @param {InquiryResponseUpsertArgs} args - Arguments to update or create a InquiryResponse.
     * @example
     * // Update or create a InquiryResponse
     * const inquiryResponse = await prisma.inquiryResponse.upsert({
     *   create: {
     *     // ... data to create a InquiryResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InquiryResponse we want to update
     *   }
     * })
     */
    upsert<T extends InquiryResponseUpsertArgs>(args: SelectSubset<T, InquiryResponseUpsertArgs<ExtArgs>>): Prisma__InquiryResponseClient<$Result.GetResult<Prisma.$InquiryResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InquiryResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryResponseCountArgs} args - Arguments to filter InquiryResponses to count.
     * @example
     * // Count the number of InquiryResponses
     * const count = await prisma.inquiryResponse.count({
     *   where: {
     *     // ... the filter for the InquiryResponses we want to count
     *   }
     * })
    **/
    count<T extends InquiryResponseCountArgs>(
      args?: Subset<T, InquiryResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InquiryResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryResponseAggregateArgs>(args: Subset<T, InquiryResponseAggregateArgs>): Prisma.PrismaPromise<GetInquiryResponseAggregateType<T>>

    /**
     * Group by InquiryResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryResponseGroupByArgs['orderBy'] }
        : { orderBy?: InquiryResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InquiryResponse model
   */
  readonly fields: InquiryResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InquiryResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    inquiry<T extends InquiryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InquiryDefaultArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responder<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InquiryResponse model
   */
  interface InquiryResponseFieldRefs {
    readonly id: FieldRef<"InquiryResponse", 'String'>
    readonly inquiryId: FieldRef<"InquiryResponse", 'String'>
    readonly message: FieldRef<"InquiryResponse", 'String'>
    readonly respondedBy: FieldRef<"InquiryResponse", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InquiryResponse findUnique
   */
  export type InquiryResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * Filter, which InquiryResponse to fetch.
     */
    where: InquiryResponseWhereUniqueInput
  }

  /**
   * InquiryResponse findUniqueOrThrow
   */
  export type InquiryResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * Filter, which InquiryResponse to fetch.
     */
    where: InquiryResponseWhereUniqueInput
  }

  /**
   * InquiryResponse findFirst
   */
  export type InquiryResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * Filter, which InquiryResponse to fetch.
     */
    where?: InquiryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryResponses to fetch.
     */
    orderBy?: InquiryResponseOrderByWithRelationInput | InquiryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InquiryResponses.
     */
    cursor?: InquiryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InquiryResponses.
     */
    distinct?: InquiryResponseScalarFieldEnum | InquiryResponseScalarFieldEnum[]
  }

  /**
   * InquiryResponse findFirstOrThrow
   */
  export type InquiryResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * Filter, which InquiryResponse to fetch.
     */
    where?: InquiryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryResponses to fetch.
     */
    orderBy?: InquiryResponseOrderByWithRelationInput | InquiryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InquiryResponses.
     */
    cursor?: InquiryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InquiryResponses.
     */
    distinct?: InquiryResponseScalarFieldEnum | InquiryResponseScalarFieldEnum[]
  }

  /**
   * InquiryResponse findMany
   */
  export type InquiryResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * Filter, which InquiryResponses to fetch.
     */
    where?: InquiryResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InquiryResponses to fetch.
     */
    orderBy?: InquiryResponseOrderByWithRelationInput | InquiryResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InquiryResponses.
     */
    cursor?: InquiryResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InquiryResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InquiryResponses.
     */
    skip?: number
    distinct?: InquiryResponseScalarFieldEnum | InquiryResponseScalarFieldEnum[]
  }

  /**
   * InquiryResponse create
   */
  export type InquiryResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a InquiryResponse.
     */
    data: XOR<InquiryResponseCreateInput, InquiryResponseUncheckedCreateInput>
  }

  /**
   * InquiryResponse createMany
   */
  export type InquiryResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InquiryResponses.
     */
    data: InquiryResponseCreateManyInput | InquiryResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InquiryResponse update
   */
  export type InquiryResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a InquiryResponse.
     */
    data: XOR<InquiryResponseUpdateInput, InquiryResponseUncheckedUpdateInput>
    /**
     * Choose, which InquiryResponse to update.
     */
    where: InquiryResponseWhereUniqueInput
  }

  /**
   * InquiryResponse updateMany
   */
  export type InquiryResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InquiryResponses.
     */
    data: XOR<InquiryResponseUpdateManyMutationInput, InquiryResponseUncheckedUpdateManyInput>
    /**
     * Filter which InquiryResponses to update
     */
    where?: InquiryResponseWhereInput
    /**
     * Limit how many InquiryResponses to update.
     */
    limit?: number
  }

  /**
   * InquiryResponse upsert
   */
  export type InquiryResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the InquiryResponse to update in case it exists.
     */
    where: InquiryResponseWhereUniqueInput
    /**
     * In case the InquiryResponse found by the `where` argument doesn't exist, create a new InquiryResponse with this data.
     */
    create: XOR<InquiryResponseCreateInput, InquiryResponseUncheckedCreateInput>
    /**
     * In case the InquiryResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryResponseUpdateInput, InquiryResponseUncheckedUpdateInput>
  }

  /**
   * InquiryResponse delete
   */
  export type InquiryResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
    /**
     * Filter which InquiryResponse to delete.
     */
    where: InquiryResponseWhereUniqueInput
  }

  /**
   * InquiryResponse deleteMany
   */
  export type InquiryResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InquiryResponses to delete
     */
    where?: InquiryResponseWhereInput
    /**
     * Limit how many InquiryResponses to delete.
     */
    limit?: number
  }

  /**
   * InquiryResponse without action
   */
  export type InquiryResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InquiryResponse
     */
    select?: InquiryResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InquiryResponse
     */
    omit?: InquiryResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryResponseInclude<ExtArgs> | null
  }


  /**
   * Model Survey
   */

  export type AggregateSurvey = {
    _count: SurveyCountAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  export type SurveyMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    surveyType: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    qrCode: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type SurveyMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    surveyType: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    qrCode: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type SurveyCountAggregateOutputType = {
    id: number
    title: number
    description: number
    surveyType: number
    isActive: number
    startDate: number
    endDate: number
    qrCode: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type SurveyMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    surveyType?: true
    isActive?: true
    startDate?: true
    endDate?: true
    qrCode?: true
    createdBy?: true
    createdAt?: true
  }

  export type SurveyMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    surveyType?: true
    isActive?: true
    startDate?: true
    endDate?: true
    qrCode?: true
    createdBy?: true
    createdAt?: true
  }

  export type SurveyCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    surveyType?: true
    isActive?: true
    startDate?: true
    endDate?: true
    qrCode?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type SurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Survey to aggregate.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Surveys
    **/
    _count?: true | SurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyMaxAggregateInputType
  }

  export type GetSurveyAggregateType<T extends SurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurvey[P]>
      : GetScalarType<T[P], AggregateSurvey[P]>
  }




  export type SurveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyWhereInput
    orderBy?: SurveyOrderByWithAggregationInput | SurveyOrderByWithAggregationInput[]
    by: SurveyScalarFieldEnum[] | SurveyScalarFieldEnum
    having?: SurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyCountAggregateInputType | true
    _min?: SurveyMinAggregateInputType
    _max?: SurveyMaxAggregateInputType
  }

  export type SurveyGroupByOutputType = {
    id: string
    title: string
    description: string
    surveyType: string
    isActive: boolean
    startDate: Date
    endDate: Date
    qrCode: string | null
    createdBy: string
    createdAt: Date
    _count: SurveyCountAggregateOutputType | null
    _min: SurveyMinAggregateOutputType | null
    _max: SurveyMaxAggregateOutputType | null
  }

  type GetSurveyGroupByPayload<T extends SurveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyGroupByOutputType[P]>
        }
      >
    >


  export type SurveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    surveyType?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    qrCode?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | AccountDefaultArgs<ExtArgs>
    surveyQuestions?: boolean | Survey$surveyQuestionsArgs<ExtArgs>
    surveyResponses?: boolean | Survey$surveyResponsesArgs<ExtArgs>
    _count?: boolean | SurveyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["survey"]>



  export type SurveySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    surveyType?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    qrCode?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type SurveyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "surveyType" | "isActive" | "startDate" | "endDate" | "qrCode" | "createdBy" | "createdAt", ExtArgs["result"]["survey"]>
  export type SurveyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AccountDefaultArgs<ExtArgs>
    surveyQuestions?: boolean | Survey$surveyQuestionsArgs<ExtArgs>
    surveyResponses?: boolean | Survey$surveyResponsesArgs<ExtArgs>
    _count?: boolean | SurveyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SurveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Survey"
    objects: {
      creator: Prisma.$AccountPayload<ExtArgs>
      surveyQuestions: Prisma.$SurveyQuestionPayload<ExtArgs>[]
      surveyResponses: Prisma.$SurveyResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      surveyType: string
      isActive: boolean
      startDate: Date
      endDate: Date
      qrCode: string | null
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["survey"]>
    composites: {}
  }

  type SurveyGetPayload<S extends boolean | null | undefined | SurveyDefaultArgs> = $Result.GetResult<Prisma.$SurveyPayload, S>

  type SurveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyCountAggregateInputType | true
    }

  export interface SurveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Survey'], meta: { name: 'Survey' } }
    /**
     * Find zero or one Survey that matches the filter.
     * @param {SurveyFindUniqueArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyFindUniqueArgs>(args: SelectSubset<T, SurveyFindUniqueArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Survey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyFindUniqueOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Survey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindFirstArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyFindFirstArgs>(args?: SelectSubset<T, SurveyFindFirstArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Survey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindFirstOrThrowArgs} args - Arguments to find a Survey
     * @example
     * // Get one Survey
     * const survey = await prisma.survey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Surveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surveys
     * const surveys = await prisma.survey.findMany()
     * 
     * // Get first 10 Surveys
     * const surveys = await prisma.survey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyWithIdOnly = await prisma.survey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyFindManyArgs>(args?: SelectSubset<T, SurveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Survey.
     * @param {SurveyCreateArgs} args - Arguments to create a Survey.
     * @example
     * // Create one Survey
     * const Survey = await prisma.survey.create({
     *   data: {
     *     // ... data to create a Survey
     *   }
     * })
     * 
     */
    create<T extends SurveyCreateArgs>(args: SelectSubset<T, SurveyCreateArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Surveys.
     * @param {SurveyCreateManyArgs} args - Arguments to create many Surveys.
     * @example
     * // Create many Surveys
     * const survey = await prisma.survey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyCreateManyArgs>(args?: SelectSubset<T, SurveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Survey.
     * @param {SurveyDeleteArgs} args - Arguments to delete one Survey.
     * @example
     * // Delete one Survey
     * const Survey = await prisma.survey.delete({
     *   where: {
     *     // ... filter to delete one Survey
     *   }
     * })
     * 
     */
    delete<T extends SurveyDeleteArgs>(args: SelectSubset<T, SurveyDeleteArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Survey.
     * @param {SurveyUpdateArgs} args - Arguments to update one Survey.
     * @example
     * // Update one Survey
     * const survey = await prisma.survey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyUpdateArgs>(args: SelectSubset<T, SurveyUpdateArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Surveys.
     * @param {SurveyDeleteManyArgs} args - Arguments to filter Surveys to delete.
     * @example
     * // Delete a few Surveys
     * const { count } = await prisma.survey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyDeleteManyArgs>(args?: SelectSubset<T, SurveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surveys
     * const survey = await prisma.survey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyUpdateManyArgs>(args: SelectSubset<T, SurveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Survey.
     * @param {SurveyUpsertArgs} args - Arguments to update or create a Survey.
     * @example
     * // Update or create a Survey
     * const survey = await prisma.survey.upsert({
     *   create: {
     *     // ... data to create a Survey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Survey we want to update
     *   }
     * })
     */
    upsert<T extends SurveyUpsertArgs>(args: SelectSubset<T, SurveyUpsertArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Surveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyCountArgs} args - Arguments to filter Surveys to count.
     * @example
     * // Count the number of Surveys
     * const count = await prisma.survey.count({
     *   where: {
     *     // ... the filter for the Surveys we want to count
     *   }
     * })
    **/
    count<T extends SurveyCountArgs>(
      args?: Subset<T, SurveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyAggregateArgs>(args: Subset<T, SurveyAggregateArgs>): Prisma.PrismaPromise<GetSurveyAggregateType<T>>

    /**
     * Group by Survey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyGroupByArgs['orderBy'] }
        : { orderBy?: SurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Survey model
   */
  readonly fields: SurveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Survey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    surveyQuestions<T extends Survey$surveyQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Survey$surveyQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surveyResponses<T extends Survey$surveyResponsesArgs<ExtArgs> = {}>(args?: Subset<T, Survey$surveyResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Survey model
   */
  interface SurveyFieldRefs {
    readonly id: FieldRef<"Survey", 'String'>
    readonly title: FieldRef<"Survey", 'String'>
    readonly description: FieldRef<"Survey", 'String'>
    readonly surveyType: FieldRef<"Survey", 'String'>
    readonly isActive: FieldRef<"Survey", 'Boolean'>
    readonly startDate: FieldRef<"Survey", 'DateTime'>
    readonly endDate: FieldRef<"Survey", 'DateTime'>
    readonly qrCode: FieldRef<"Survey", 'String'>
    readonly createdBy: FieldRef<"Survey", 'String'>
    readonly createdAt: FieldRef<"Survey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Survey findUnique
   */
  export type SurveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey findUniqueOrThrow
   */
  export type SurveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey findFirst
   */
  export type SurveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey findFirstOrThrow
   */
  export type SurveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Survey to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surveys.
     */
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey findMany
   */
  export type SurveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter, which Surveys to fetch.
     */
    where?: SurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surveys to fetch.
     */
    orderBy?: SurveyOrderByWithRelationInput | SurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Surveys.
     */
    cursor?: SurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surveys.
     */
    skip?: number
    distinct?: SurveyScalarFieldEnum | SurveyScalarFieldEnum[]
  }

  /**
   * Survey create
   */
  export type SurveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The data needed to create a Survey.
     */
    data: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
  }

  /**
   * Survey createMany
   */
  export type SurveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Surveys.
     */
    data: SurveyCreateManyInput | SurveyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Survey update
   */
  export type SurveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The data needed to update a Survey.
     */
    data: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
    /**
     * Choose, which Survey to update.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey updateMany
   */
  export type SurveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Surveys.
     */
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyInput>
    /**
     * Filter which Surveys to update
     */
    where?: SurveyWhereInput
    /**
     * Limit how many Surveys to update.
     */
    limit?: number
  }

  /**
   * Survey upsert
   */
  export type SurveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * The filter to search for the Survey to update in case it exists.
     */
    where: SurveyWhereUniqueInput
    /**
     * In case the Survey found by the `where` argument doesn't exist, create a new Survey with this data.
     */
    create: XOR<SurveyCreateInput, SurveyUncheckedCreateInput>
    /**
     * In case the Survey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyUpdateInput, SurveyUncheckedUpdateInput>
  }

  /**
   * Survey delete
   */
  export type SurveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
    /**
     * Filter which Survey to delete.
     */
    where: SurveyWhereUniqueInput
  }

  /**
   * Survey deleteMany
   */
  export type SurveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surveys to delete
     */
    where?: SurveyWhereInput
    /**
     * Limit how many Surveys to delete.
     */
    limit?: number
  }

  /**
   * Survey.surveyQuestions
   */
  export type Survey$surveyQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    where?: SurveyQuestionWhereInput
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    cursor?: SurveyQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * Survey.surveyResponses
   */
  export type Survey$surveyResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    cursor?: SurveyResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * Survey without action
   */
  export type SurveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Survey
     */
    select?: SurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Survey
     */
    omit?: SurveyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyInclude<ExtArgs> | null
  }


  /**
   * Model SurveyQuestion
   */

  export type AggregateSurveyQuestion = {
    _count: SurveyQuestionCountAggregateOutputType | null
    _avg: SurveyQuestionAvgAggregateOutputType | null
    _sum: SurveyQuestionSumAggregateOutputType | null
    _min: SurveyQuestionMinAggregateOutputType | null
    _max: SurveyQuestionMaxAggregateOutputType | null
  }

  export type SurveyQuestionAvgAggregateOutputType = {
    orderIndex: number | null
  }

  export type SurveyQuestionSumAggregateOutputType = {
    orderIndex: number | null
  }

  export type SurveyQuestionMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    questionText: string | null
    questionType: string | null
    isRequired: boolean | null
    orderIndex: number | null
  }

  export type SurveyQuestionMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    questionText: string | null
    questionType: string | null
    isRequired: boolean | null
    orderIndex: number | null
  }

  export type SurveyQuestionCountAggregateOutputType = {
    id: number
    surveyId: number
    questionText: number
    questionType: number
    options: number
    isRequired: number
    orderIndex: number
    _all: number
  }


  export type SurveyQuestionAvgAggregateInputType = {
    orderIndex?: true
  }

  export type SurveyQuestionSumAggregateInputType = {
    orderIndex?: true
  }

  export type SurveyQuestionMinAggregateInputType = {
    id?: true
    surveyId?: true
    questionText?: true
    questionType?: true
    isRequired?: true
    orderIndex?: true
  }

  export type SurveyQuestionMaxAggregateInputType = {
    id?: true
    surveyId?: true
    questionText?: true
    questionType?: true
    isRequired?: true
    orderIndex?: true
  }

  export type SurveyQuestionCountAggregateInputType = {
    id?: true
    surveyId?: true
    questionText?: true
    questionType?: true
    options?: true
    isRequired?: true
    orderIndex?: true
    _all?: true
  }

  export type SurveyQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyQuestion to aggregate.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyQuestions
    **/
    _count?: true | SurveyQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SurveyQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SurveyQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyQuestionMaxAggregateInputType
  }

  export type GetSurveyQuestionAggregateType<T extends SurveyQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyQuestion[P]>
      : GetScalarType<T[P], AggregateSurveyQuestion[P]>
  }




  export type SurveyQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyQuestionWhereInput
    orderBy?: SurveyQuestionOrderByWithAggregationInput | SurveyQuestionOrderByWithAggregationInput[]
    by: SurveyQuestionScalarFieldEnum[] | SurveyQuestionScalarFieldEnum
    having?: SurveyQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyQuestionCountAggregateInputType | true
    _avg?: SurveyQuestionAvgAggregateInputType
    _sum?: SurveyQuestionSumAggregateInputType
    _min?: SurveyQuestionMinAggregateInputType
    _max?: SurveyQuestionMaxAggregateInputType
  }

  export type SurveyQuestionGroupByOutputType = {
    id: string
    surveyId: string
    questionText: string
    questionType: string
    options: JsonValue
    isRequired: boolean
    orderIndex: number
    _count: SurveyQuestionCountAggregateOutputType | null
    _avg: SurveyQuestionAvgAggregateOutputType | null
    _sum: SurveyQuestionSumAggregateOutputType | null
    _min: SurveyQuestionMinAggregateOutputType | null
    _max: SurveyQuestionMaxAggregateOutputType | null
  }

  type GetSurveyQuestionGroupByPayload<T extends SurveyQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyQuestionGroupByOutputType[P]>
        }
      >
    >


  export type SurveyQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    questionText?: boolean
    questionType?: boolean
    options?: boolean
    isRequired?: boolean
    orderIndex?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    surveyAnswers?: boolean | SurveyQuestion$surveyAnswersArgs<ExtArgs>
    _count?: boolean | SurveyQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyQuestion"]>



  export type SurveyQuestionSelectScalar = {
    id?: boolean
    surveyId?: boolean
    questionText?: boolean
    questionType?: boolean
    options?: boolean
    isRequired?: boolean
    orderIndex?: boolean
  }

  export type SurveyQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "surveyId" | "questionText" | "questionType" | "options" | "isRequired" | "orderIndex", ExtArgs["result"]["surveyQuestion"]>
  export type SurveyQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    surveyAnswers?: boolean | SurveyQuestion$surveyAnswersArgs<ExtArgs>
    _count?: boolean | SurveyQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SurveyQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyQuestion"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
      surveyAnswers: Prisma.$SurveyAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      questionText: string
      questionType: string
      options: Prisma.JsonValue
      isRequired: boolean
      orderIndex: number
    }, ExtArgs["result"]["surveyQuestion"]>
    composites: {}
  }

  type SurveyQuestionGetPayload<S extends boolean | null | undefined | SurveyQuestionDefaultArgs> = $Result.GetResult<Prisma.$SurveyQuestionPayload, S>

  type SurveyQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyQuestionCountAggregateInputType | true
    }

  export interface SurveyQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyQuestion'], meta: { name: 'SurveyQuestion' } }
    /**
     * Find zero or one SurveyQuestion that matches the filter.
     * @param {SurveyQuestionFindUniqueArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyQuestionFindUniqueArgs>(args: SelectSubset<T, SurveyQuestionFindUniqueArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyQuestionFindUniqueOrThrowArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindFirstArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyQuestionFindFirstArgs>(args?: SelectSubset<T, SurveyQuestionFindFirstArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindFirstOrThrowArgs} args - Arguments to find a SurveyQuestion
     * @example
     * // Get one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestion.findMany()
     * 
     * // Get first 10 SurveyQuestions
     * const surveyQuestions = await prisma.surveyQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyQuestionWithIdOnly = await prisma.surveyQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyQuestionFindManyArgs>(args?: SelectSubset<T, SurveyQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyQuestion.
     * @param {SurveyQuestionCreateArgs} args - Arguments to create a SurveyQuestion.
     * @example
     * // Create one SurveyQuestion
     * const SurveyQuestion = await prisma.surveyQuestion.create({
     *   data: {
     *     // ... data to create a SurveyQuestion
     *   }
     * })
     * 
     */
    create<T extends SurveyQuestionCreateArgs>(args: SelectSubset<T, SurveyQuestionCreateArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyQuestions.
     * @param {SurveyQuestionCreateManyArgs} args - Arguments to create many SurveyQuestions.
     * @example
     * // Create many SurveyQuestions
     * const surveyQuestion = await prisma.surveyQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyQuestionCreateManyArgs>(args?: SelectSubset<T, SurveyQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyQuestion.
     * @param {SurveyQuestionDeleteArgs} args - Arguments to delete one SurveyQuestion.
     * @example
     * // Delete one SurveyQuestion
     * const SurveyQuestion = await prisma.surveyQuestion.delete({
     *   where: {
     *     // ... filter to delete one SurveyQuestion
     *   }
     * })
     * 
     */
    delete<T extends SurveyQuestionDeleteArgs>(args: SelectSubset<T, SurveyQuestionDeleteArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyQuestion.
     * @param {SurveyQuestionUpdateArgs} args - Arguments to update one SurveyQuestion.
     * @example
     * // Update one SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyQuestionUpdateArgs>(args: SelectSubset<T, SurveyQuestionUpdateArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyQuestions.
     * @param {SurveyQuestionDeleteManyArgs} args - Arguments to filter SurveyQuestions to delete.
     * @example
     * // Delete a few SurveyQuestions
     * const { count } = await prisma.surveyQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyQuestionDeleteManyArgs>(args?: SelectSubset<T, SurveyQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyQuestions
     * const surveyQuestion = await prisma.surveyQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyQuestionUpdateManyArgs>(args: SelectSubset<T, SurveyQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyQuestion.
     * @param {SurveyQuestionUpsertArgs} args - Arguments to update or create a SurveyQuestion.
     * @example
     * // Update or create a SurveyQuestion
     * const surveyQuestion = await prisma.surveyQuestion.upsert({
     *   create: {
     *     // ... data to create a SurveyQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyQuestion we want to update
     *   }
     * })
     */
    upsert<T extends SurveyQuestionUpsertArgs>(args: SelectSubset<T, SurveyQuestionUpsertArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionCountArgs} args - Arguments to filter SurveyQuestions to count.
     * @example
     * // Count the number of SurveyQuestions
     * const count = await prisma.surveyQuestion.count({
     *   where: {
     *     // ... the filter for the SurveyQuestions we want to count
     *   }
     * })
    **/
    count<T extends SurveyQuestionCountArgs>(
      args?: Subset<T, SurveyQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyQuestionAggregateArgs>(args: Subset<T, SurveyQuestionAggregateArgs>): Prisma.PrismaPromise<GetSurveyQuestionAggregateType<T>>

    /**
     * Group by SurveyQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyQuestionGroupByArgs['orderBy'] }
        : { orderBy?: SurveyQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyQuestion model
   */
  readonly fields: SurveyQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    surveyAnswers<T extends SurveyQuestion$surveyAnswersArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestion$surveyAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyQuestion model
   */
  interface SurveyQuestionFieldRefs {
    readonly id: FieldRef<"SurveyQuestion", 'String'>
    readonly surveyId: FieldRef<"SurveyQuestion", 'String'>
    readonly questionText: FieldRef<"SurveyQuestion", 'String'>
    readonly questionType: FieldRef<"SurveyQuestion", 'String'>
    readonly options: FieldRef<"SurveyQuestion", 'Json'>
    readonly isRequired: FieldRef<"SurveyQuestion", 'Boolean'>
    readonly orderIndex: FieldRef<"SurveyQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SurveyQuestion findUnique
   */
  export type SurveyQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion findUniqueOrThrow
   */
  export type SurveyQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion findFirst
   */
  export type SurveyQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestions.
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestions.
     */
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * SurveyQuestion findFirstOrThrow
   */
  export type SurveyQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestion to fetch.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyQuestions.
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyQuestions.
     */
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * SurveyQuestion findMany
   */
  export type SurveyQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter, which SurveyQuestions to fetch.
     */
    where?: SurveyQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyQuestions to fetch.
     */
    orderBy?: SurveyQuestionOrderByWithRelationInput | SurveyQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyQuestions.
     */
    cursor?: SurveyQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyQuestions.
     */
    skip?: number
    distinct?: SurveyQuestionScalarFieldEnum | SurveyQuestionScalarFieldEnum[]
  }

  /**
   * SurveyQuestion create
   */
  export type SurveyQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyQuestion.
     */
    data: XOR<SurveyQuestionCreateInput, SurveyQuestionUncheckedCreateInput>
  }

  /**
   * SurveyQuestion createMany
   */
  export type SurveyQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyQuestions.
     */
    data: SurveyQuestionCreateManyInput | SurveyQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyQuestion update
   */
  export type SurveyQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyQuestion.
     */
    data: XOR<SurveyQuestionUpdateInput, SurveyQuestionUncheckedUpdateInput>
    /**
     * Choose, which SurveyQuestion to update.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion updateMany
   */
  export type SurveyQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyQuestions.
     */
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyInput>
    /**
     * Filter which SurveyQuestions to update
     */
    where?: SurveyQuestionWhereInput
    /**
     * Limit how many SurveyQuestions to update.
     */
    limit?: number
  }

  /**
   * SurveyQuestion upsert
   */
  export type SurveyQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyQuestion to update in case it exists.
     */
    where: SurveyQuestionWhereUniqueInput
    /**
     * In case the SurveyQuestion found by the `where` argument doesn't exist, create a new SurveyQuestion with this data.
     */
    create: XOR<SurveyQuestionCreateInput, SurveyQuestionUncheckedCreateInput>
    /**
     * In case the SurveyQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyQuestionUpdateInput, SurveyQuestionUncheckedUpdateInput>
  }

  /**
   * SurveyQuestion delete
   */
  export type SurveyQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
    /**
     * Filter which SurveyQuestion to delete.
     */
    where: SurveyQuestionWhereUniqueInput
  }

  /**
   * SurveyQuestion deleteMany
   */
  export type SurveyQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyQuestions to delete
     */
    where?: SurveyQuestionWhereInput
    /**
     * Limit how many SurveyQuestions to delete.
     */
    limit?: number
  }

  /**
   * SurveyQuestion.surveyAnswers
   */
  export type SurveyQuestion$surveyAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    where?: SurveyAnswerWhereInput
    orderBy?: SurveyAnswerOrderByWithRelationInput | SurveyAnswerOrderByWithRelationInput[]
    cursor?: SurveyAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyAnswerScalarFieldEnum | SurveyAnswerScalarFieldEnum[]
  }

  /**
   * SurveyQuestion without action
   */
  export type SurveyQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyQuestion
     */
    select?: SurveyQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyQuestion
     */
    omit?: SurveyQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyQuestionInclude<ExtArgs> | null
  }


  /**
   * Model SurveyResponse
   */

  export type AggregateSurveyResponse = {
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  export type SurveyResponseMinAggregateOutputType = {
    id: string | null
    surveyId: string | null
    userProfileId: string | null
    ipAddress: string | null
    submittedAt: Date | null
  }

  export type SurveyResponseMaxAggregateOutputType = {
    id: string | null
    surveyId: string | null
    userProfileId: string | null
    ipAddress: string | null
    submittedAt: Date | null
  }

  export type SurveyResponseCountAggregateOutputType = {
    id: number
    surveyId: number
    userProfileId: number
    ipAddress: number
    submittedAt: number
    _all: number
  }


  export type SurveyResponseMinAggregateInputType = {
    id?: true
    surveyId?: true
    userProfileId?: true
    ipAddress?: true
    submittedAt?: true
  }

  export type SurveyResponseMaxAggregateInputType = {
    id?: true
    surveyId?: true
    userProfileId?: true
    ipAddress?: true
    submittedAt?: true
  }

  export type SurveyResponseCountAggregateInputType = {
    id?: true
    surveyId?: true
    userProfileId?: true
    ipAddress?: true
    submittedAt?: true
    _all?: true
  }

  export type SurveyResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponse to aggregate.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyResponses
    **/
    _count?: true | SurveyResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type GetSurveyResponseAggregateType<T extends SurveyResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyResponse[P]>
      : GetScalarType<T[P], AggregateSurveyResponse[P]>
  }




  export type SurveyResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyResponseWhereInput
    orderBy?: SurveyResponseOrderByWithAggregationInput | SurveyResponseOrderByWithAggregationInput[]
    by: SurveyResponseScalarFieldEnum[] | SurveyResponseScalarFieldEnum
    having?: SurveyResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyResponseCountAggregateInputType | true
    _min?: SurveyResponseMinAggregateInputType
    _max?: SurveyResponseMaxAggregateInputType
  }

  export type SurveyResponseGroupByOutputType = {
    id: string
    surveyId: string
    userProfileId: string
    ipAddress: string | null
    submittedAt: Date
    _count: SurveyResponseCountAggregateOutputType | null
    _min: SurveyResponseMinAggregateOutputType | null
    _max: SurveyResponseMaxAggregateOutputType | null
  }

  type GetSurveyResponseGroupByPayload<T extends SurveyResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyResponseGroupByOutputType[P]>
        }
      >
    >


  export type SurveyResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyId?: boolean
    userProfileId?: boolean
    ipAddress?: boolean
    submittedAt?: boolean
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    surveyAnswers?: boolean | SurveyResponse$surveyAnswersArgs<ExtArgs>
    _count?: boolean | SurveyResponseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyResponse"]>



  export type SurveyResponseSelectScalar = {
    id?: boolean
    surveyId?: boolean
    userProfileId?: boolean
    ipAddress?: boolean
    submittedAt?: boolean
  }

  export type SurveyResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "surveyId" | "userProfileId" | "ipAddress" | "submittedAt", ExtArgs["result"]["surveyResponse"]>
  export type SurveyResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    survey?: boolean | SurveyDefaultArgs<ExtArgs>
    userProfile?: boolean | UserProfileDefaultArgs<ExtArgs>
    surveyAnswers?: boolean | SurveyResponse$surveyAnswersArgs<ExtArgs>
    _count?: boolean | SurveyResponseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SurveyResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyResponse"
    objects: {
      survey: Prisma.$SurveyPayload<ExtArgs>
      userProfile: Prisma.$UserProfilePayload<ExtArgs>
      surveyAnswers: Prisma.$SurveyAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyId: string
      userProfileId: string
      ipAddress: string | null
      submittedAt: Date
    }, ExtArgs["result"]["surveyResponse"]>
    composites: {}
  }

  type SurveyResponseGetPayload<S extends boolean | null | undefined | SurveyResponseDefaultArgs> = $Result.GetResult<Prisma.$SurveyResponsePayload, S>

  type SurveyResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyResponseCountAggregateInputType | true
    }

  export interface SurveyResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyResponse'], meta: { name: 'SurveyResponse' } }
    /**
     * Find zero or one SurveyResponse that matches the filter.
     * @param {SurveyResponseFindUniqueArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyResponseFindUniqueArgs>(args: SelectSubset<T, SurveyResponseFindUniqueArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyResponseFindUniqueOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindFirstArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyResponseFindFirstArgs>(args?: SelectSubset<T, SurveyResponseFindFirstArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindFirstOrThrowArgs} args - Arguments to find a SurveyResponse
     * @example
     * // Get one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany()
     * 
     * // Get first 10 SurveyResponses
     * const surveyResponses = await prisma.surveyResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyResponseWithIdOnly = await prisma.surveyResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyResponseFindManyArgs>(args?: SelectSubset<T, SurveyResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyResponse.
     * @param {SurveyResponseCreateArgs} args - Arguments to create a SurveyResponse.
     * @example
     * // Create one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.create({
     *   data: {
     *     // ... data to create a SurveyResponse
     *   }
     * })
     * 
     */
    create<T extends SurveyResponseCreateArgs>(args: SelectSubset<T, SurveyResponseCreateArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyResponses.
     * @param {SurveyResponseCreateManyArgs} args - Arguments to create many SurveyResponses.
     * @example
     * // Create many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyResponseCreateManyArgs>(args?: SelectSubset<T, SurveyResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyResponse.
     * @param {SurveyResponseDeleteArgs} args - Arguments to delete one SurveyResponse.
     * @example
     * // Delete one SurveyResponse
     * const SurveyResponse = await prisma.surveyResponse.delete({
     *   where: {
     *     // ... filter to delete one SurveyResponse
     *   }
     * })
     * 
     */
    delete<T extends SurveyResponseDeleteArgs>(args: SelectSubset<T, SurveyResponseDeleteArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyResponse.
     * @param {SurveyResponseUpdateArgs} args - Arguments to update one SurveyResponse.
     * @example
     * // Update one SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyResponseUpdateArgs>(args: SelectSubset<T, SurveyResponseUpdateArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyResponses.
     * @param {SurveyResponseDeleteManyArgs} args - Arguments to filter SurveyResponses to delete.
     * @example
     * // Delete a few SurveyResponses
     * const { count } = await prisma.surveyResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyResponseDeleteManyArgs>(args?: SelectSubset<T, SurveyResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyResponses
     * const surveyResponse = await prisma.surveyResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyResponseUpdateManyArgs>(args: SelectSubset<T, SurveyResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyResponse.
     * @param {SurveyResponseUpsertArgs} args - Arguments to update or create a SurveyResponse.
     * @example
     * // Update or create a SurveyResponse
     * const surveyResponse = await prisma.surveyResponse.upsert({
     *   create: {
     *     // ... data to create a SurveyResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyResponse we want to update
     *   }
     * })
     */
    upsert<T extends SurveyResponseUpsertArgs>(args: SelectSubset<T, SurveyResponseUpsertArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseCountArgs} args - Arguments to filter SurveyResponses to count.
     * @example
     * // Count the number of SurveyResponses
     * const count = await prisma.surveyResponse.count({
     *   where: {
     *     // ... the filter for the SurveyResponses we want to count
     *   }
     * })
    **/
    count<T extends SurveyResponseCountArgs>(
      args?: Subset<T, SurveyResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyResponseAggregateArgs>(args: Subset<T, SurveyResponseAggregateArgs>): Prisma.PrismaPromise<GetSurveyResponseAggregateType<T>>

    /**
     * Group by SurveyResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyResponseGroupByArgs['orderBy'] }
        : { orderBy?: SurveyResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyResponse model
   */
  readonly fields: SurveyResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    survey<T extends SurveyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyDefaultArgs<ExtArgs>>): Prisma__SurveyClient<$Result.GetResult<Prisma.$SurveyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userProfile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    surveyAnswers<T extends SurveyResponse$surveyAnswersArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponse$surveyAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyResponse model
   */
  interface SurveyResponseFieldRefs {
    readonly id: FieldRef<"SurveyResponse", 'String'>
    readonly surveyId: FieldRef<"SurveyResponse", 'String'>
    readonly userProfileId: FieldRef<"SurveyResponse", 'String'>
    readonly ipAddress: FieldRef<"SurveyResponse", 'String'>
    readonly submittedAt: FieldRef<"SurveyResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurveyResponse findUnique
   */
  export type SurveyResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse findUniqueOrThrow
   */
  export type SurveyResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse findFirst
   */
  export type SurveyResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse findFirstOrThrow
   */
  export type SurveyResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponse to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyResponses.
     */
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse findMany
   */
  export type SurveyResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter, which SurveyResponses to fetch.
     */
    where?: SurveyResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyResponses to fetch.
     */
    orderBy?: SurveyResponseOrderByWithRelationInput | SurveyResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyResponses.
     */
    cursor?: SurveyResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyResponses.
     */
    skip?: number
    distinct?: SurveyResponseScalarFieldEnum | SurveyResponseScalarFieldEnum[]
  }

  /**
   * SurveyResponse create
   */
  export type SurveyResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyResponse.
     */
    data: XOR<SurveyResponseCreateInput, SurveyResponseUncheckedCreateInput>
  }

  /**
   * SurveyResponse createMany
   */
  export type SurveyResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyResponses.
     */
    data: SurveyResponseCreateManyInput | SurveyResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyResponse update
   */
  export type SurveyResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyResponse.
     */
    data: XOR<SurveyResponseUpdateInput, SurveyResponseUncheckedUpdateInput>
    /**
     * Choose, which SurveyResponse to update.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse updateMany
   */
  export type SurveyResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyResponses.
     */
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyInput>
    /**
     * Filter which SurveyResponses to update
     */
    where?: SurveyResponseWhereInput
    /**
     * Limit how many SurveyResponses to update.
     */
    limit?: number
  }

  /**
   * SurveyResponse upsert
   */
  export type SurveyResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyResponse to update in case it exists.
     */
    where: SurveyResponseWhereUniqueInput
    /**
     * In case the SurveyResponse found by the `where` argument doesn't exist, create a new SurveyResponse with this data.
     */
    create: XOR<SurveyResponseCreateInput, SurveyResponseUncheckedCreateInput>
    /**
     * In case the SurveyResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyResponseUpdateInput, SurveyResponseUncheckedUpdateInput>
  }

  /**
   * SurveyResponse delete
   */
  export type SurveyResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
    /**
     * Filter which SurveyResponse to delete.
     */
    where: SurveyResponseWhereUniqueInput
  }

  /**
   * SurveyResponse deleteMany
   */
  export type SurveyResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyResponses to delete
     */
    where?: SurveyResponseWhereInput
    /**
     * Limit how many SurveyResponses to delete.
     */
    limit?: number
  }

  /**
   * SurveyResponse.surveyAnswers
   */
  export type SurveyResponse$surveyAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    where?: SurveyAnswerWhereInput
    orderBy?: SurveyAnswerOrderByWithRelationInput | SurveyAnswerOrderByWithRelationInput[]
    cursor?: SurveyAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurveyAnswerScalarFieldEnum | SurveyAnswerScalarFieldEnum[]
  }

  /**
   * SurveyResponse without action
   */
  export type SurveyResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyResponse
     */
    select?: SurveyResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyResponse
     */
    omit?: SurveyResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyResponseInclude<ExtArgs> | null
  }


  /**
   * Model SurveyAnswer
   */

  export type AggregateSurveyAnswer = {
    _count: SurveyAnswerCountAggregateOutputType | null
    _min: SurveyAnswerMinAggregateOutputType | null
    _max: SurveyAnswerMaxAggregateOutputType | null
  }

  export type SurveyAnswerMinAggregateOutputType = {
    id: string | null
    surveyResponseId: string | null
    surveyQuestionId: string | null
    answer: string | null
  }

  export type SurveyAnswerMaxAggregateOutputType = {
    id: string | null
    surveyResponseId: string | null
    surveyQuestionId: string | null
    answer: string | null
  }

  export type SurveyAnswerCountAggregateOutputType = {
    id: number
    surveyResponseId: number
    surveyQuestionId: number
    answer: number
    _all: number
  }


  export type SurveyAnswerMinAggregateInputType = {
    id?: true
    surveyResponseId?: true
    surveyQuestionId?: true
    answer?: true
  }

  export type SurveyAnswerMaxAggregateInputType = {
    id?: true
    surveyResponseId?: true
    surveyQuestionId?: true
    answer?: true
  }

  export type SurveyAnswerCountAggregateInputType = {
    id?: true
    surveyResponseId?: true
    surveyQuestionId?: true
    answer?: true
    _all?: true
  }

  export type SurveyAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyAnswer to aggregate.
     */
    where?: SurveyAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyAnswers to fetch.
     */
    orderBy?: SurveyAnswerOrderByWithRelationInput | SurveyAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurveyAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurveyAnswers
    **/
    _count?: true | SurveyAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurveyAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurveyAnswerMaxAggregateInputType
  }

  export type GetSurveyAnswerAggregateType<T extends SurveyAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateSurveyAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurveyAnswer[P]>
      : GetScalarType<T[P], AggregateSurveyAnswer[P]>
  }




  export type SurveyAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurveyAnswerWhereInput
    orderBy?: SurveyAnswerOrderByWithAggregationInput | SurveyAnswerOrderByWithAggregationInput[]
    by: SurveyAnswerScalarFieldEnum[] | SurveyAnswerScalarFieldEnum
    having?: SurveyAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurveyAnswerCountAggregateInputType | true
    _min?: SurveyAnswerMinAggregateInputType
    _max?: SurveyAnswerMaxAggregateInputType
  }

  export type SurveyAnswerGroupByOutputType = {
    id: string
    surveyResponseId: string
    surveyQuestionId: string
    answer: string
    _count: SurveyAnswerCountAggregateOutputType | null
    _min: SurveyAnswerMinAggregateOutputType | null
    _max: SurveyAnswerMaxAggregateOutputType | null
  }

  type GetSurveyAnswerGroupByPayload<T extends SurveyAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurveyAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurveyAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurveyAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], SurveyAnswerGroupByOutputType[P]>
        }
      >
    >


  export type SurveyAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surveyResponseId?: boolean
    surveyQuestionId?: boolean
    answer?: boolean
    surveyResponse?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    surveyQuestion?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surveyAnswer"]>



  export type SurveyAnswerSelectScalar = {
    id?: boolean
    surveyResponseId?: boolean
    surveyQuestionId?: boolean
    answer?: boolean
  }

  export type SurveyAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "surveyResponseId" | "surveyQuestionId" | "answer", ExtArgs["result"]["surveyAnswer"]>
  export type SurveyAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surveyResponse?: boolean | SurveyResponseDefaultArgs<ExtArgs>
    surveyQuestion?: boolean | SurveyQuestionDefaultArgs<ExtArgs>
  }

  export type $SurveyAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurveyAnswer"
    objects: {
      surveyResponse: Prisma.$SurveyResponsePayload<ExtArgs>
      surveyQuestion: Prisma.$SurveyQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surveyResponseId: string
      surveyQuestionId: string
      answer: string
    }, ExtArgs["result"]["surveyAnswer"]>
    composites: {}
  }

  type SurveyAnswerGetPayload<S extends boolean | null | undefined | SurveyAnswerDefaultArgs> = $Result.GetResult<Prisma.$SurveyAnswerPayload, S>

  type SurveyAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurveyAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurveyAnswerCountAggregateInputType | true
    }

  export interface SurveyAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurveyAnswer'], meta: { name: 'SurveyAnswer' } }
    /**
     * Find zero or one SurveyAnswer that matches the filter.
     * @param {SurveyAnswerFindUniqueArgs} args - Arguments to find a SurveyAnswer
     * @example
     * // Get one SurveyAnswer
     * const surveyAnswer = await prisma.surveyAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurveyAnswerFindUniqueArgs>(args: SelectSubset<T, SurveyAnswerFindUniqueArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurveyAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurveyAnswerFindUniqueOrThrowArgs} args - Arguments to find a SurveyAnswer
     * @example
     * // Get one SurveyAnswer
     * const surveyAnswer = await prisma.surveyAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurveyAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, SurveyAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswerFindFirstArgs} args - Arguments to find a SurveyAnswer
     * @example
     * // Get one SurveyAnswer
     * const surveyAnswer = await prisma.surveyAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurveyAnswerFindFirstArgs>(args?: SelectSubset<T, SurveyAnswerFindFirstArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurveyAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswerFindFirstOrThrowArgs} args - Arguments to find a SurveyAnswer
     * @example
     * // Get one SurveyAnswer
     * const surveyAnswer = await prisma.surveyAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurveyAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, SurveyAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurveyAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswer.findMany()
     * 
     * // Get first 10 SurveyAnswers
     * const surveyAnswers = await prisma.surveyAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surveyAnswerWithIdOnly = await prisma.surveyAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurveyAnswerFindManyArgs>(args?: SelectSubset<T, SurveyAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurveyAnswer.
     * @param {SurveyAnswerCreateArgs} args - Arguments to create a SurveyAnswer.
     * @example
     * // Create one SurveyAnswer
     * const SurveyAnswer = await prisma.surveyAnswer.create({
     *   data: {
     *     // ... data to create a SurveyAnswer
     *   }
     * })
     * 
     */
    create<T extends SurveyAnswerCreateArgs>(args: SelectSubset<T, SurveyAnswerCreateArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurveyAnswers.
     * @param {SurveyAnswerCreateManyArgs} args - Arguments to create many SurveyAnswers.
     * @example
     * // Create many SurveyAnswers
     * const surveyAnswer = await prisma.surveyAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurveyAnswerCreateManyArgs>(args?: SelectSubset<T, SurveyAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SurveyAnswer.
     * @param {SurveyAnswerDeleteArgs} args - Arguments to delete one SurveyAnswer.
     * @example
     * // Delete one SurveyAnswer
     * const SurveyAnswer = await prisma.surveyAnswer.delete({
     *   where: {
     *     // ... filter to delete one SurveyAnswer
     *   }
     * })
     * 
     */
    delete<T extends SurveyAnswerDeleteArgs>(args: SelectSubset<T, SurveyAnswerDeleteArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurveyAnswer.
     * @param {SurveyAnswerUpdateArgs} args - Arguments to update one SurveyAnswer.
     * @example
     * // Update one SurveyAnswer
     * const surveyAnswer = await prisma.surveyAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurveyAnswerUpdateArgs>(args: SelectSubset<T, SurveyAnswerUpdateArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurveyAnswers.
     * @param {SurveyAnswerDeleteManyArgs} args - Arguments to filter SurveyAnswers to delete.
     * @example
     * // Delete a few SurveyAnswers
     * const { count } = await prisma.surveyAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurveyAnswerDeleteManyArgs>(args?: SelectSubset<T, SurveyAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurveyAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurveyAnswers
     * const surveyAnswer = await prisma.surveyAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurveyAnswerUpdateManyArgs>(args: SelectSubset<T, SurveyAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SurveyAnswer.
     * @param {SurveyAnswerUpsertArgs} args - Arguments to update or create a SurveyAnswer.
     * @example
     * // Update or create a SurveyAnswer
     * const surveyAnswer = await prisma.surveyAnswer.upsert({
     *   create: {
     *     // ... data to create a SurveyAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurveyAnswer we want to update
     *   }
     * })
     */
    upsert<T extends SurveyAnswerUpsertArgs>(args: SelectSubset<T, SurveyAnswerUpsertArgs<ExtArgs>>): Prisma__SurveyAnswerClient<$Result.GetResult<Prisma.$SurveyAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurveyAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswerCountArgs} args - Arguments to filter SurveyAnswers to count.
     * @example
     * // Count the number of SurveyAnswers
     * const count = await prisma.surveyAnswer.count({
     *   where: {
     *     // ... the filter for the SurveyAnswers we want to count
     *   }
     * })
    **/
    count<T extends SurveyAnswerCountArgs>(
      args?: Subset<T, SurveyAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurveyAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurveyAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurveyAnswerAggregateArgs>(args: Subset<T, SurveyAnswerAggregateArgs>): Prisma.PrismaPromise<GetSurveyAnswerAggregateType<T>>

    /**
     * Group by SurveyAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurveyAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurveyAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurveyAnswerGroupByArgs['orderBy'] }
        : { orderBy?: SurveyAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurveyAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurveyAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurveyAnswer model
   */
  readonly fields: SurveyAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurveyAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurveyAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surveyResponse<T extends SurveyResponseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyResponseDefaultArgs<ExtArgs>>): Prisma__SurveyResponseClient<$Result.GetResult<Prisma.$SurveyResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    surveyQuestion<T extends SurveyQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurveyQuestionDefaultArgs<ExtArgs>>): Prisma__SurveyQuestionClient<$Result.GetResult<Prisma.$SurveyQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurveyAnswer model
   */
  interface SurveyAnswerFieldRefs {
    readonly id: FieldRef<"SurveyAnswer", 'String'>
    readonly surveyResponseId: FieldRef<"SurveyAnswer", 'String'>
    readonly surveyQuestionId: FieldRef<"SurveyAnswer", 'String'>
    readonly answer: FieldRef<"SurveyAnswer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SurveyAnswer findUnique
   */
  export type SurveyAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SurveyAnswer to fetch.
     */
    where: SurveyAnswerWhereUniqueInput
  }

  /**
   * SurveyAnswer findUniqueOrThrow
   */
  export type SurveyAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SurveyAnswer to fetch.
     */
    where: SurveyAnswerWhereUniqueInput
  }

  /**
   * SurveyAnswer findFirst
   */
  export type SurveyAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SurveyAnswer to fetch.
     */
    where?: SurveyAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyAnswers to fetch.
     */
    orderBy?: SurveyAnswerOrderByWithRelationInput | SurveyAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyAnswers.
     */
    cursor?: SurveyAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyAnswers.
     */
    distinct?: SurveyAnswerScalarFieldEnum | SurveyAnswerScalarFieldEnum[]
  }

  /**
   * SurveyAnswer findFirstOrThrow
   */
  export type SurveyAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SurveyAnswer to fetch.
     */
    where?: SurveyAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyAnswers to fetch.
     */
    orderBy?: SurveyAnswerOrderByWithRelationInput | SurveyAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurveyAnswers.
     */
    cursor?: SurveyAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurveyAnswers.
     */
    distinct?: SurveyAnswerScalarFieldEnum | SurveyAnswerScalarFieldEnum[]
  }

  /**
   * SurveyAnswer findMany
   */
  export type SurveyAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * Filter, which SurveyAnswers to fetch.
     */
    where?: SurveyAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurveyAnswers to fetch.
     */
    orderBy?: SurveyAnswerOrderByWithRelationInput | SurveyAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurveyAnswers.
     */
    cursor?: SurveyAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurveyAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurveyAnswers.
     */
    skip?: number
    distinct?: SurveyAnswerScalarFieldEnum | SurveyAnswerScalarFieldEnum[]
  }

  /**
   * SurveyAnswer create
   */
  export type SurveyAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a SurveyAnswer.
     */
    data: XOR<SurveyAnswerCreateInput, SurveyAnswerUncheckedCreateInput>
  }

  /**
   * SurveyAnswer createMany
   */
  export type SurveyAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurveyAnswers.
     */
    data: SurveyAnswerCreateManyInput | SurveyAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurveyAnswer update
   */
  export type SurveyAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a SurveyAnswer.
     */
    data: XOR<SurveyAnswerUpdateInput, SurveyAnswerUncheckedUpdateInput>
    /**
     * Choose, which SurveyAnswer to update.
     */
    where: SurveyAnswerWhereUniqueInput
  }

  /**
   * SurveyAnswer updateMany
   */
  export type SurveyAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurveyAnswers.
     */
    data: XOR<SurveyAnswerUpdateManyMutationInput, SurveyAnswerUncheckedUpdateManyInput>
    /**
     * Filter which SurveyAnswers to update
     */
    where?: SurveyAnswerWhereInput
    /**
     * Limit how many SurveyAnswers to update.
     */
    limit?: number
  }

  /**
   * SurveyAnswer upsert
   */
  export type SurveyAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the SurveyAnswer to update in case it exists.
     */
    where: SurveyAnswerWhereUniqueInput
    /**
     * In case the SurveyAnswer found by the `where` argument doesn't exist, create a new SurveyAnswer with this data.
     */
    create: XOR<SurveyAnswerCreateInput, SurveyAnswerUncheckedCreateInput>
    /**
     * In case the SurveyAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurveyAnswerUpdateInput, SurveyAnswerUncheckedUpdateInput>
  }

  /**
   * SurveyAnswer delete
   */
  export type SurveyAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
    /**
     * Filter which SurveyAnswer to delete.
     */
    where: SurveyAnswerWhereUniqueInput
  }

  /**
   * SurveyAnswer deleteMany
   */
  export type SurveyAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurveyAnswers to delete
     */
    where?: SurveyAnswerWhereInput
    /**
     * Limit how many SurveyAnswers to delete.
     */
    limit?: number
  }

  /**
   * SurveyAnswer without action
   */
  export type SurveyAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurveyAnswer
     */
    select?: SurveyAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurveyAnswer
     */
    omit?: SurveyAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurveyAnswerInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsReport
   */

  export type AggregateAnalyticsReport = {
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  export type AnalyticsReportMinAggregateOutputType = {
    id: string | null
    reportName: string | null
    reportType: string | null
    reportPeriodStart: Date | null
    reportPeriodEnd: Date | null
    generatedBy: string | null
  }

  export type AnalyticsReportMaxAggregateOutputType = {
    id: string | null
    reportName: string | null
    reportType: string | null
    reportPeriodStart: Date | null
    reportPeriodEnd: Date | null
    generatedBy: string | null
  }

  export type AnalyticsReportCountAggregateOutputType = {
    id: number
    reportName: number
    reportType: number
    dataFilters: number
    reportData: number
    reportPeriodStart: number
    reportPeriodEnd: number
    generatedBy: number
    _all: number
  }


  export type AnalyticsReportMinAggregateInputType = {
    id?: true
    reportName?: true
    reportType?: true
    reportPeriodStart?: true
    reportPeriodEnd?: true
    generatedBy?: true
  }

  export type AnalyticsReportMaxAggregateInputType = {
    id?: true
    reportName?: true
    reportType?: true
    reportPeriodStart?: true
    reportPeriodEnd?: true
    generatedBy?: true
  }

  export type AnalyticsReportCountAggregateInputType = {
    id?: true
    reportName?: true
    reportType?: true
    dataFilters?: true
    reportData?: true
    reportPeriodStart?: true
    reportPeriodEnd?: true
    generatedBy?: true
    _all?: true
  }

  export type AnalyticsReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReport to aggregate.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsReports
    **/
    _count?: true | AnalyticsReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type GetAnalyticsReportAggregateType<T extends AnalyticsReportAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsReport[P]>
      : GetScalarType<T[P], AggregateAnalyticsReport[P]>
  }




  export type AnalyticsReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsReportWhereInput
    orderBy?: AnalyticsReportOrderByWithAggregationInput | AnalyticsReportOrderByWithAggregationInput[]
    by: AnalyticsReportScalarFieldEnum[] | AnalyticsReportScalarFieldEnum
    having?: AnalyticsReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsReportCountAggregateInputType | true
    _min?: AnalyticsReportMinAggregateInputType
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type AnalyticsReportGroupByOutputType = {
    id: string
    reportName: string
    reportType: string
    dataFilters: JsonValue
    reportData: JsonValue
    reportPeriodStart: Date
    reportPeriodEnd: Date
    generatedBy: string
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  type GetAnalyticsReportGroupByPayload<T extends AnalyticsReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportName?: boolean
    reportType?: boolean
    dataFilters?: boolean
    reportData?: boolean
    reportPeriodStart?: boolean
    reportPeriodEnd?: boolean
    generatedBy?: boolean
    generator?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsReport"]>



  export type AnalyticsReportSelectScalar = {
    id?: boolean
    reportName?: boolean
    reportType?: boolean
    dataFilters?: boolean
    reportData?: boolean
    reportPeriodStart?: boolean
    reportPeriodEnd?: boolean
    generatedBy?: boolean
  }

  export type AnalyticsReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportName" | "reportType" | "dataFilters" | "reportData" | "reportPeriodStart" | "reportPeriodEnd" | "generatedBy", ExtArgs["result"]["analyticsReport"]>
  export type AnalyticsReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generator?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $AnalyticsReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsReport"
    objects: {
      generator: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportName: string
      reportType: string
      dataFilters: Prisma.JsonValue
      reportData: Prisma.JsonValue
      reportPeriodStart: Date
      reportPeriodEnd: Date
      generatedBy: string
    }, ExtArgs["result"]["analyticsReport"]>
    composites: {}
  }

  type AnalyticsReportGetPayload<S extends boolean | null | undefined | AnalyticsReportDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsReportPayload, S>

  type AnalyticsReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsReportCountAggregateInputType | true
    }

  export interface AnalyticsReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsReport'], meta: { name: 'AnalyticsReport' } }
    /**
     * Find zero or one AnalyticsReport that matches the filter.
     * @param {AnalyticsReportFindUniqueArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsReportFindUniqueArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsReportFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsReportFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsReportFindFirstArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsReportFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany()
     * 
     * // Get first 10 AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsReportFindManyArgs>(args?: SelectSubset<T, AnalyticsReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsReport.
     * @param {AnalyticsReportCreateArgs} args - Arguments to create a AnalyticsReport.
     * @example
     * // Create one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.create({
     *   data: {
     *     // ... data to create a AnalyticsReport
     *   }
     * })
     * 
     */
    create<T extends AnalyticsReportCreateArgs>(args: SelectSubset<T, AnalyticsReportCreateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsReports.
     * @param {AnalyticsReportCreateManyArgs} args - Arguments to create many AnalyticsReports.
     * @example
     * // Create many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsReportCreateManyArgs>(args?: SelectSubset<T, AnalyticsReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AnalyticsReport.
     * @param {AnalyticsReportDeleteArgs} args - Arguments to delete one AnalyticsReport.
     * @example
     * // Delete one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsReport
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsReportDeleteArgs>(args: SelectSubset<T, AnalyticsReportDeleteArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsReport.
     * @param {AnalyticsReportUpdateArgs} args - Arguments to update one AnalyticsReport.
     * @example
     * // Update one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsReportUpdateArgs>(args: SelectSubset<T, AnalyticsReportUpdateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsReports.
     * @param {AnalyticsReportDeleteManyArgs} args - Arguments to filter AnalyticsReports to delete.
     * @example
     * // Delete a few AnalyticsReports
     * const { count } = await prisma.analyticsReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsReportDeleteManyArgs>(args?: SelectSubset<T, AnalyticsReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsReportUpdateManyArgs>(args: SelectSubset<T, AnalyticsReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsReport.
     * @param {AnalyticsReportUpsertArgs} args - Arguments to update or create a AnalyticsReport.
     * @example
     * // Update or create a AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.upsert({
     *   create: {
     *     // ... data to create a AnalyticsReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsReport we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsReportUpsertArgs>(args: SelectSubset<T, AnalyticsReportUpsertArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportCountArgs} args - Arguments to filter AnalyticsReports to count.
     * @example
     * // Count the number of AnalyticsReports
     * const count = await prisma.analyticsReport.count({
     *   where: {
     *     // ... the filter for the AnalyticsReports we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsReportCountArgs>(
      args?: Subset<T, AnalyticsReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsReportAggregateArgs>(args: Subset<T, AnalyticsReportAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsReportAggregateType<T>>

    /**
     * Group by AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsReportGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsReport model
   */
  readonly fields: AnalyticsReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsReport model
   */
  interface AnalyticsReportFieldRefs {
    readonly id: FieldRef<"AnalyticsReport", 'String'>
    readonly reportName: FieldRef<"AnalyticsReport", 'String'>
    readonly reportType: FieldRef<"AnalyticsReport", 'String'>
    readonly dataFilters: FieldRef<"AnalyticsReport", 'Json'>
    readonly reportData: FieldRef<"AnalyticsReport", 'Json'>
    readonly reportPeriodStart: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly reportPeriodEnd: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly generatedBy: FieldRef<"AnalyticsReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsReport findUnique
   */
  export type AnalyticsReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findUniqueOrThrow
   */
  export type AnalyticsReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findFirst
   */
  export type AnalyticsReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findFirstOrThrow
   */
  export type AnalyticsReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findMany
   */
  export type AnalyticsReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReports to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport create
   */
  export type AnalyticsReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsReport.
     */
    data: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
  }

  /**
   * AnalyticsReport createMany
   */
  export type AnalyticsReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsReports.
     */
    data: AnalyticsReportCreateManyInput | AnalyticsReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsReport update
   */
  export type AnalyticsReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsReport.
     */
    data: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsReport to update.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport updateMany
   */
  export type AnalyticsReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsReports.
     */
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsReports to update
     */
    where?: AnalyticsReportWhereInput
    /**
     * Limit how many AnalyticsReports to update.
     */
    limit?: number
  }

  /**
   * AnalyticsReport upsert
   */
  export type AnalyticsReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsReport to update in case it exists.
     */
    where: AnalyticsReportWhereUniqueInput
    /**
     * In case the AnalyticsReport found by the `where` argument doesn't exist, create a new AnalyticsReport with this data.
     */
    create: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
    /**
     * In case the AnalyticsReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
  }

  /**
   * AnalyticsReport delete
   */
  export type AnalyticsReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsReport to delete.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport deleteMany
   */
  export type AnalyticsReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReports to delete
     */
    where?: AnalyticsReportWhereInput
    /**
     * Limit how many AnalyticsReports to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsReport without action
   */
  export type AnalyticsReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsReport
     */
    omit?: AnalyticsReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
  }


  /**
   * Model PredictionModel
   */

  export type AggregatePredictionModel = {
    _count: PredictionModelCountAggregateOutputType | null
    _avg: PredictionModelAvgAggregateOutputType | null
    _sum: PredictionModelSumAggregateOutputType | null
    _min: PredictionModelMinAggregateOutputType | null
    _max: PredictionModelMaxAggregateOutputType | null
  }

  export type PredictionModelAvgAggregateOutputType = {
    accuracy: number | null
  }

  export type PredictionModelSumAggregateOutputType = {
    accuracy: number | null
  }

  export type PredictionModelMinAggregateOutputType = {
    id: string | null
    modelName: string | null
    modelType: string | null
    accuracy: number | null
    lastTrained: Date | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PredictionModelMaxAggregateOutputType = {
    id: string | null
    modelName: string | null
    modelType: string | null
    accuracy: number | null
    lastTrained: Date | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PredictionModelCountAggregateOutputType = {
    id: number
    modelName: number
    modelType: number
    modelParameters: number
    predictionResults: number
    accuracy: number
    lastTrained: number
    isActive: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type PredictionModelAvgAggregateInputType = {
    accuracy?: true
  }

  export type PredictionModelSumAggregateInputType = {
    accuracy?: true
  }

  export type PredictionModelMinAggregateInputType = {
    id?: true
    modelName?: true
    modelType?: true
    accuracy?: true
    lastTrained?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
  }

  export type PredictionModelMaxAggregateInputType = {
    id?: true
    modelName?: true
    modelType?: true
    accuracy?: true
    lastTrained?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
  }

  export type PredictionModelCountAggregateInputType = {
    id?: true
    modelName?: true
    modelType?: true
    modelParameters?: true
    predictionResults?: true
    accuracy?: true
    lastTrained?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type PredictionModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictionModel to aggregate.
     */
    where?: PredictionModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionModels to fetch.
     */
    orderBy?: PredictionModelOrderByWithRelationInput | PredictionModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PredictionModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PredictionModels
    **/
    _count?: true | PredictionModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PredictionModelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PredictionModelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PredictionModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PredictionModelMaxAggregateInputType
  }

  export type GetPredictionModelAggregateType<T extends PredictionModelAggregateArgs> = {
        [P in keyof T & keyof AggregatePredictionModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePredictionModel[P]>
      : GetScalarType<T[P], AggregatePredictionModel[P]>
  }




  export type PredictionModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionModelWhereInput
    orderBy?: PredictionModelOrderByWithAggregationInput | PredictionModelOrderByWithAggregationInput[]
    by: PredictionModelScalarFieldEnum[] | PredictionModelScalarFieldEnum
    having?: PredictionModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PredictionModelCountAggregateInputType | true
    _avg?: PredictionModelAvgAggregateInputType
    _sum?: PredictionModelSumAggregateInputType
    _min?: PredictionModelMinAggregateInputType
    _max?: PredictionModelMaxAggregateInputType
  }

  export type PredictionModelGroupByOutputType = {
    id: string
    modelName: string
    modelType: string
    modelParameters: JsonValue
    predictionResults: JsonValue | null
    accuracy: number | null
    lastTrained: Date | null
    isActive: boolean
    createdBy: string
    createdAt: Date
    _count: PredictionModelCountAggregateOutputType | null
    _avg: PredictionModelAvgAggregateOutputType | null
    _sum: PredictionModelSumAggregateOutputType | null
    _min: PredictionModelMinAggregateOutputType | null
    _max: PredictionModelMaxAggregateOutputType | null
  }

  type GetPredictionModelGroupByPayload<T extends PredictionModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PredictionModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PredictionModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PredictionModelGroupByOutputType[P]>
            : GetScalarType<T[P], PredictionModelGroupByOutputType[P]>
        }
      >
    >


  export type PredictionModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    modelType?: boolean
    modelParameters?: boolean
    predictionResults?: boolean
    accuracy?: boolean
    lastTrained?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    creator?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["predictionModel"]>



  export type PredictionModelSelectScalar = {
    id?: boolean
    modelName?: boolean
    modelType?: boolean
    modelParameters?: boolean
    predictionResults?: boolean
    accuracy?: boolean
    lastTrained?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type PredictionModelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelName" | "modelType" | "modelParameters" | "predictionResults" | "accuracy" | "lastTrained" | "isActive" | "createdBy" | "createdAt", ExtArgs["result"]["predictionModel"]>
  export type PredictionModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $PredictionModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PredictionModel"
    objects: {
      creator: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      modelName: string
      modelType: string
      modelParameters: Prisma.JsonValue
      predictionResults: Prisma.JsonValue | null
      accuracy: number | null
      lastTrained: Date | null
      isActive: boolean
      createdBy: string
      createdAt: Date
    }, ExtArgs["result"]["predictionModel"]>
    composites: {}
  }

  type PredictionModelGetPayload<S extends boolean | null | undefined | PredictionModelDefaultArgs> = $Result.GetResult<Prisma.$PredictionModelPayload, S>

  type PredictionModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PredictionModelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PredictionModelCountAggregateInputType | true
    }

  export interface PredictionModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PredictionModel'], meta: { name: 'PredictionModel' } }
    /**
     * Find zero or one PredictionModel that matches the filter.
     * @param {PredictionModelFindUniqueArgs} args - Arguments to find a PredictionModel
     * @example
     * // Get one PredictionModel
     * const predictionModel = await prisma.predictionModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PredictionModelFindUniqueArgs>(args: SelectSubset<T, PredictionModelFindUniqueArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PredictionModel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PredictionModelFindUniqueOrThrowArgs} args - Arguments to find a PredictionModel
     * @example
     * // Get one PredictionModel
     * const predictionModel = await prisma.predictionModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PredictionModelFindUniqueOrThrowArgs>(args: SelectSubset<T, PredictionModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PredictionModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionModelFindFirstArgs} args - Arguments to find a PredictionModel
     * @example
     * // Get one PredictionModel
     * const predictionModel = await prisma.predictionModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PredictionModelFindFirstArgs>(args?: SelectSubset<T, PredictionModelFindFirstArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PredictionModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionModelFindFirstOrThrowArgs} args - Arguments to find a PredictionModel
     * @example
     * // Get one PredictionModel
     * const predictionModel = await prisma.predictionModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PredictionModelFindFirstOrThrowArgs>(args?: SelectSubset<T, PredictionModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PredictionModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PredictionModels
     * const predictionModels = await prisma.predictionModel.findMany()
     * 
     * // Get first 10 PredictionModels
     * const predictionModels = await prisma.predictionModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predictionModelWithIdOnly = await prisma.predictionModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PredictionModelFindManyArgs>(args?: SelectSubset<T, PredictionModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PredictionModel.
     * @param {PredictionModelCreateArgs} args - Arguments to create a PredictionModel.
     * @example
     * // Create one PredictionModel
     * const PredictionModel = await prisma.predictionModel.create({
     *   data: {
     *     // ... data to create a PredictionModel
     *   }
     * })
     * 
     */
    create<T extends PredictionModelCreateArgs>(args: SelectSubset<T, PredictionModelCreateArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PredictionModels.
     * @param {PredictionModelCreateManyArgs} args - Arguments to create many PredictionModels.
     * @example
     * // Create many PredictionModels
     * const predictionModel = await prisma.predictionModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PredictionModelCreateManyArgs>(args?: SelectSubset<T, PredictionModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PredictionModel.
     * @param {PredictionModelDeleteArgs} args - Arguments to delete one PredictionModel.
     * @example
     * // Delete one PredictionModel
     * const PredictionModel = await prisma.predictionModel.delete({
     *   where: {
     *     // ... filter to delete one PredictionModel
     *   }
     * })
     * 
     */
    delete<T extends PredictionModelDeleteArgs>(args: SelectSubset<T, PredictionModelDeleteArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PredictionModel.
     * @param {PredictionModelUpdateArgs} args - Arguments to update one PredictionModel.
     * @example
     * // Update one PredictionModel
     * const predictionModel = await prisma.predictionModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PredictionModelUpdateArgs>(args: SelectSubset<T, PredictionModelUpdateArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PredictionModels.
     * @param {PredictionModelDeleteManyArgs} args - Arguments to filter PredictionModels to delete.
     * @example
     * // Delete a few PredictionModels
     * const { count } = await prisma.predictionModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PredictionModelDeleteManyArgs>(args?: SelectSubset<T, PredictionModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PredictionModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PredictionModels
     * const predictionModel = await prisma.predictionModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PredictionModelUpdateManyArgs>(args: SelectSubset<T, PredictionModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PredictionModel.
     * @param {PredictionModelUpsertArgs} args - Arguments to update or create a PredictionModel.
     * @example
     * // Update or create a PredictionModel
     * const predictionModel = await prisma.predictionModel.upsert({
     *   create: {
     *     // ... data to create a PredictionModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PredictionModel we want to update
     *   }
     * })
     */
    upsert<T extends PredictionModelUpsertArgs>(args: SelectSubset<T, PredictionModelUpsertArgs<ExtArgs>>): Prisma__PredictionModelClient<$Result.GetResult<Prisma.$PredictionModelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PredictionModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionModelCountArgs} args - Arguments to filter PredictionModels to count.
     * @example
     * // Count the number of PredictionModels
     * const count = await prisma.predictionModel.count({
     *   where: {
     *     // ... the filter for the PredictionModels we want to count
     *   }
     * })
    **/
    count<T extends PredictionModelCountArgs>(
      args?: Subset<T, PredictionModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PredictionModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PredictionModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PredictionModelAggregateArgs>(args: Subset<T, PredictionModelAggregateArgs>): Prisma.PrismaPromise<GetPredictionModelAggregateType<T>>

    /**
     * Group by PredictionModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PredictionModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PredictionModelGroupByArgs['orderBy'] }
        : { orderBy?: PredictionModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PredictionModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredictionModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PredictionModel model
   */
  readonly fields: PredictionModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PredictionModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PredictionModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PredictionModel model
   */
  interface PredictionModelFieldRefs {
    readonly id: FieldRef<"PredictionModel", 'String'>
    readonly modelName: FieldRef<"PredictionModel", 'String'>
    readonly modelType: FieldRef<"PredictionModel", 'String'>
    readonly modelParameters: FieldRef<"PredictionModel", 'Json'>
    readonly predictionResults: FieldRef<"PredictionModel", 'Json'>
    readonly accuracy: FieldRef<"PredictionModel", 'Float'>
    readonly lastTrained: FieldRef<"PredictionModel", 'DateTime'>
    readonly isActive: FieldRef<"PredictionModel", 'Boolean'>
    readonly createdBy: FieldRef<"PredictionModel", 'String'>
    readonly createdAt: FieldRef<"PredictionModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PredictionModel findUnique
   */
  export type PredictionModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * Filter, which PredictionModel to fetch.
     */
    where: PredictionModelWhereUniqueInput
  }

  /**
   * PredictionModel findUniqueOrThrow
   */
  export type PredictionModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * Filter, which PredictionModel to fetch.
     */
    where: PredictionModelWhereUniqueInput
  }

  /**
   * PredictionModel findFirst
   */
  export type PredictionModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * Filter, which PredictionModel to fetch.
     */
    where?: PredictionModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionModels to fetch.
     */
    orderBy?: PredictionModelOrderByWithRelationInput | PredictionModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictionModels.
     */
    cursor?: PredictionModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictionModels.
     */
    distinct?: PredictionModelScalarFieldEnum | PredictionModelScalarFieldEnum[]
  }

  /**
   * PredictionModel findFirstOrThrow
   */
  export type PredictionModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * Filter, which PredictionModel to fetch.
     */
    where?: PredictionModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionModels to fetch.
     */
    orderBy?: PredictionModelOrderByWithRelationInput | PredictionModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictionModels.
     */
    cursor?: PredictionModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictionModels.
     */
    distinct?: PredictionModelScalarFieldEnum | PredictionModelScalarFieldEnum[]
  }

  /**
   * PredictionModel findMany
   */
  export type PredictionModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * Filter, which PredictionModels to fetch.
     */
    where?: PredictionModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionModels to fetch.
     */
    orderBy?: PredictionModelOrderByWithRelationInput | PredictionModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PredictionModels.
     */
    cursor?: PredictionModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionModels.
     */
    skip?: number
    distinct?: PredictionModelScalarFieldEnum | PredictionModelScalarFieldEnum[]
  }

  /**
   * PredictionModel create
   */
  export type PredictionModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * The data needed to create a PredictionModel.
     */
    data: XOR<PredictionModelCreateInput, PredictionModelUncheckedCreateInput>
  }

  /**
   * PredictionModel createMany
   */
  export type PredictionModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PredictionModels.
     */
    data: PredictionModelCreateManyInput | PredictionModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PredictionModel update
   */
  export type PredictionModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * The data needed to update a PredictionModel.
     */
    data: XOR<PredictionModelUpdateInput, PredictionModelUncheckedUpdateInput>
    /**
     * Choose, which PredictionModel to update.
     */
    where: PredictionModelWhereUniqueInput
  }

  /**
   * PredictionModel updateMany
   */
  export type PredictionModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PredictionModels.
     */
    data: XOR<PredictionModelUpdateManyMutationInput, PredictionModelUncheckedUpdateManyInput>
    /**
     * Filter which PredictionModels to update
     */
    where?: PredictionModelWhereInput
    /**
     * Limit how many PredictionModels to update.
     */
    limit?: number
  }

  /**
   * PredictionModel upsert
   */
  export type PredictionModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * The filter to search for the PredictionModel to update in case it exists.
     */
    where: PredictionModelWhereUniqueInput
    /**
     * In case the PredictionModel found by the `where` argument doesn't exist, create a new PredictionModel with this data.
     */
    create: XOR<PredictionModelCreateInput, PredictionModelUncheckedCreateInput>
    /**
     * In case the PredictionModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PredictionModelUpdateInput, PredictionModelUncheckedUpdateInput>
  }

  /**
   * PredictionModel delete
   */
  export type PredictionModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
    /**
     * Filter which PredictionModel to delete.
     */
    where: PredictionModelWhereUniqueInput
  }

  /**
   * PredictionModel deleteMany
   */
  export type PredictionModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictionModels to delete
     */
    where?: PredictionModelWhereInput
    /**
     * Limit how many PredictionModels to delete.
     */
    limit?: number
  }

  /**
   * PredictionModel without action
   */
  export type PredictionModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionModel
     */
    select?: PredictionModelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PredictionModel
     */
    omit?: PredictionModelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionModelInclude<ExtArgs> | null
  }


  /**
   * Model SystemLog
   */

  export type AggregateSystemLog = {
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  export type SystemLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SystemLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type SystemLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldData: number
    newData: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type SystemLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SystemLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
  }

  export type SystemLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldData?: true
    newData?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type SystemLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLog to aggregate.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemLogs
    **/
    _count?: true | SystemLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemLogMaxAggregateInputType
  }

  export type GetSystemLogAggregateType<T extends SystemLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemLog[P]>
      : GetScalarType<T[P], AggregateSystemLog[P]>
  }




  export type SystemLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemLogWhereInput
    orderBy?: SystemLogOrderByWithAggregationInput | SystemLogOrderByWithAggregationInput[]
    by: SystemLogScalarFieldEnum[] | SystemLogScalarFieldEnum
    having?: SystemLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemLogCountAggregateInputType | true
    _min?: SystemLogMinAggregateInputType
    _max?: SystemLogMaxAggregateInputType
  }

  export type SystemLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldData: JsonValue | null
    newData: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    _count: SystemLogCountAggregateOutputType | null
    _min: SystemLogMinAggregateOutputType | null
    _max: SystemLogMaxAggregateOutputType | null
  }

  type GetSystemLogGroupByPayload<T extends SystemLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
            : GetScalarType<T[P], SystemLogGroupByOutputType[P]>
        }
      >
    >


  export type SystemLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemLog"]>



  export type SystemLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldData?: boolean
    newData?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type SystemLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "oldData" | "newData" | "ipAddress" | "userAgent", ExtArgs["result"]["systemLog"]>
  export type SystemLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $SystemLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemLog"
    objects: {
      user: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string
      oldData: Prisma.JsonValue | null
      newData: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["systemLog"]>
    composites: {}
  }

  type SystemLogGetPayload<S extends boolean | null | undefined | SystemLogDefaultArgs> = $Result.GetResult<Prisma.$SystemLogPayload, S>

  type SystemLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemLogCountAggregateInputType | true
    }

  export interface SystemLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemLog'], meta: { name: 'SystemLog' } }
    /**
     * Find zero or one SystemLog that matches the filter.
     * @param {SystemLogFindUniqueArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemLogFindUniqueArgs>(args: SelectSubset<T, SystemLogFindUniqueArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemLogFindUniqueOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemLogFindFirstArgs>(args?: SelectSubset<T, SystemLogFindFirstArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindFirstOrThrowArgs} args - Arguments to find a SystemLog
     * @example
     * // Get one SystemLog
     * const systemLog = await prisma.systemLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemLogs
     * const systemLogs = await prisma.systemLog.findMany()
     * 
     * // Get first 10 SystemLogs
     * const systemLogs = await prisma.systemLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemLogWithIdOnly = await prisma.systemLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemLogFindManyArgs>(args?: SelectSubset<T, SystemLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemLog.
     * @param {SystemLogCreateArgs} args - Arguments to create a SystemLog.
     * @example
     * // Create one SystemLog
     * const SystemLog = await prisma.systemLog.create({
     *   data: {
     *     // ... data to create a SystemLog
     *   }
     * })
     * 
     */
    create<T extends SystemLogCreateArgs>(args: SelectSubset<T, SystemLogCreateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemLogs.
     * @param {SystemLogCreateManyArgs} args - Arguments to create many SystemLogs.
     * @example
     * // Create many SystemLogs
     * const systemLog = await prisma.systemLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemLogCreateManyArgs>(args?: SelectSubset<T, SystemLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemLog.
     * @param {SystemLogDeleteArgs} args - Arguments to delete one SystemLog.
     * @example
     * // Delete one SystemLog
     * const SystemLog = await prisma.systemLog.delete({
     *   where: {
     *     // ... filter to delete one SystemLog
     *   }
     * })
     * 
     */
    delete<T extends SystemLogDeleteArgs>(args: SelectSubset<T, SystemLogDeleteArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemLog.
     * @param {SystemLogUpdateArgs} args - Arguments to update one SystemLog.
     * @example
     * // Update one SystemLog
     * const systemLog = await prisma.systemLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemLogUpdateArgs>(args: SelectSubset<T, SystemLogUpdateArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemLogs.
     * @param {SystemLogDeleteManyArgs} args - Arguments to filter SystemLogs to delete.
     * @example
     * // Delete a few SystemLogs
     * const { count } = await prisma.systemLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemLogDeleteManyArgs>(args?: SelectSubset<T, SystemLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemLogs
     * const systemLog = await prisma.systemLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemLogUpdateManyArgs>(args: SelectSubset<T, SystemLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemLog.
     * @param {SystemLogUpsertArgs} args - Arguments to update or create a SystemLog.
     * @example
     * // Update or create a SystemLog
     * const systemLog = await prisma.systemLog.upsert({
     *   create: {
     *     // ... data to create a SystemLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemLog we want to update
     *   }
     * })
     */
    upsert<T extends SystemLogUpsertArgs>(args: SelectSubset<T, SystemLogUpsertArgs<ExtArgs>>): Prisma__SystemLogClient<$Result.GetResult<Prisma.$SystemLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogCountArgs} args - Arguments to filter SystemLogs to count.
     * @example
     * // Count the number of SystemLogs
     * const count = await prisma.systemLog.count({
     *   where: {
     *     // ... the filter for the SystemLogs we want to count
     *   }
     * })
    **/
    count<T extends SystemLogCountArgs>(
      args?: Subset<T, SystemLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemLogAggregateArgs>(args: Subset<T, SystemLogAggregateArgs>): Prisma.PrismaPromise<GetSystemLogAggregateType<T>>

    /**
     * Group by SystemLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemLogGroupByArgs['orderBy'] }
        : { orderBy?: SystemLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemLog model
   */
  readonly fields: SystemLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemLog model
   */
  interface SystemLogFieldRefs {
    readonly id: FieldRef<"SystemLog", 'String'>
    readonly userId: FieldRef<"SystemLog", 'String'>
    readonly action: FieldRef<"SystemLog", 'String'>
    readonly entityType: FieldRef<"SystemLog", 'String'>
    readonly entityId: FieldRef<"SystemLog", 'String'>
    readonly oldData: FieldRef<"SystemLog", 'Json'>
    readonly newData: FieldRef<"SystemLog", 'Json'>
    readonly ipAddress: FieldRef<"SystemLog", 'String'>
    readonly userAgent: FieldRef<"SystemLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemLog findUnique
   */
  export type SystemLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findUniqueOrThrow
   */
  export type SystemLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog findFirst
   */
  export type SystemLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findFirstOrThrow
   */
  export type SystemLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLog to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemLogs.
     */
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog findMany
   */
  export type SystemLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter, which SystemLogs to fetch.
     */
    where?: SystemLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemLogs to fetch.
     */
    orderBy?: SystemLogOrderByWithRelationInput | SystemLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemLogs.
     */
    cursor?: SystemLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemLogs.
     */
    skip?: number
    distinct?: SystemLogScalarFieldEnum | SystemLogScalarFieldEnum[]
  }

  /**
   * SystemLog create
   */
  export type SystemLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemLog.
     */
    data: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
  }

  /**
   * SystemLog createMany
   */
  export type SystemLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemLogs.
     */
    data: SystemLogCreateManyInput | SystemLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemLog update
   */
  export type SystemLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemLog.
     */
    data: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
    /**
     * Choose, which SystemLog to update.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog updateMany
   */
  export type SystemLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemLogs.
     */
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyInput>
    /**
     * Filter which SystemLogs to update
     */
    where?: SystemLogWhereInput
    /**
     * Limit how many SystemLogs to update.
     */
    limit?: number
  }

  /**
   * SystemLog upsert
   */
  export type SystemLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemLog to update in case it exists.
     */
    where: SystemLogWhereUniqueInput
    /**
     * In case the SystemLog found by the `where` argument doesn't exist, create a new SystemLog with this data.
     */
    create: XOR<SystemLogCreateInput, SystemLogUncheckedCreateInput>
    /**
     * In case the SystemLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemLogUpdateInput, SystemLogUncheckedUpdateInput>
  }

  /**
   * SystemLog delete
   */
  export type SystemLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
    /**
     * Filter which SystemLog to delete.
     */
    where: SystemLogWhereUniqueInput
  }

  /**
   * SystemLog deleteMany
   */
  export type SystemLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemLogs to delete
     */
    where?: SystemLogWhereInput
    /**
     * Limit how many SystemLogs to delete.
     */
    limit?: number
  }

  /**
   * SystemLog without action
   */
  export type SystemLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemLog
     */
    select?: SystemLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemLog
     */
    omit?: SystemLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profilePictureUrl: 'profilePictureUrl',
    emailVerified: 'emailVerified'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    fullName: 'fullName',
    dateOfBirth: 'dateOfBirth',
    age: 'age',
    gender: 'gender',
    address: 'address',
    contactNumber: 'contactNumber',
    religion: 'religion',
    civilStatus: 'civilStatus',
    occupation: 'occupation',
    educationLevel: 'educationLevel',
    philhealthNumber: 'philhealthNumber',
    nhtsStatus: 'nhtsStatus',
    personWithDisability: 'personWithDisability',
    indigenousPeople: 'indigenousPeople',
    createdAt: 'createdAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const HealthWorkerScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    name: 'name',
    role: 'role',
    contactNumber: 'contactNumber',
    signature: 'signature',
    isActive: 'isActive'
  };

  export type HealthWorkerScalarFieldEnum = (typeof HealthWorkerScalarFieldEnum)[keyof typeof HealthWorkerScalarFieldEnum]


  export const FamilyRecordScalarFieldEnum: {
    id: 'id',
    familyId: 'familyId',
    headOfFamilyId: 'headOfFamilyId',
    address: 'address',
    contactNumber: 'contactNumber',
    smsConsent: 'smsConsent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FamilyRecordScalarFieldEnum = (typeof FamilyRecordScalarFieldEnum)[keyof typeof FamilyRecordScalarFieldEnum]


  export const FamilyMemberScalarFieldEnum: {
    id: 'id',
    familyRecordId: 'familyRecordId',
    userProfileId: 'userProfileId',
    memberName: 'memberName',
    relationship: 'relationship',
    gender: 'gender',
    age: 'age',
    occupation: 'occupation',
    civilStatus: 'civilStatus'
  };

  export type FamilyMemberScalarFieldEnum = (typeof FamilyMemberScalarFieldEnum)[keyof typeof FamilyMemberScalarFieldEnum]


  export const FamilyHealthHistoryScalarFieldEnum: {
    id: 'id',
    familyRecordId: 'familyRecordId',
    geneticConditions: 'geneticConditions',
    chronicDiseases: 'chronicDiseases',
    recordedDate: 'recordedDate',
    recordedBy: 'recordedBy'
  };

  export type FamilyHealthHistoryScalarFieldEnum = (typeof FamilyHealthHistoryScalarFieldEnum)[keyof typeof FamilyHealthHistoryScalarFieldEnum]


  export const MaternalHealthScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    mothersName: 'mothersName',
    mothersAge: 'mothersAge',
    mothersBirthday: 'mothersBirthday',
    mothersMaidenName: 'mothersMaidenName',
    mothersReligion: 'mothersReligion',
    mothersEducation: 'mothersEducation',
    mothersOccupation: 'mothersOccupation',
    numberOfChildren: 'numberOfChildren',
    gravidaPara: 'gravidaPara',
    menarcheAge: 'menarcheAge',
    lastMenstrualPeriod: 'lastMenstrualPeriod',
    expectedDeliveryDate: 'expectedDeliveryDate',
    tetanusToxoidStatus: 'tetanusToxoidStatus',
    createdAt: 'createdAt'
  };

  export type MaternalHealthScalarFieldEnum = (typeof MaternalHealthScalarFieldEnum)[keyof typeof MaternalHealthScalarFieldEnum]


  export const PrenatalVisitScalarFieldEnum: {
    id: 'id',
    maternalHealthId: 'maternalHealthId',
    visitDate: 'visitDate',
    gestationalAgeWeeks: 'gestationalAgeWeeks',
    weightKg: 'weightKg',
    heightCm: 'heightCm',
    bloodPressure: 'bloodPressure',
    fundalHeightCm: 'fundalHeightCm',
    fetalHeartTone: 'fetalHeartTone',
    nextVisitDate: 'nextVisitDate',
    recordedBy: 'recordedBy'
  };

  export type PrenatalVisitScalarFieldEnum = (typeof PrenatalVisitScalarFieldEnum)[keyof typeof PrenatalVisitScalarFieldEnum]


  export const LaboratoryTestScalarFieldEnum: {
    id: 'id',
    prenatalVisitId: 'prenatalVisitId',
    userProfileId: 'userProfileId',
    testDate: 'testDate',
    testType: 'testType',
    testCompleted: 'testCompleted',
    recordedBy: 'recordedBy'
  };

  export type LaboratoryTestScalarFieldEnum = (typeof LaboratoryTestScalarFieldEnum)[keyof typeof LaboratoryTestScalarFieldEnum]


  export const InterventionScalarFieldEnum: {
    id: 'id',
    prenatalVisitId: 'prenatalVisitId',
    tetanusToxoidDose: 'tetanusToxoidDose',
    tetanusToxoidLocation: 'tetanusToxoidLocation',
    tetanusToxoidDate: 'tetanusToxoidDate',
    ironSupplementation: 'ironSupplementation',
    ironMedication: 'ironMedication',
    vitaminSupplementation: 'vitaminSupplementation',
    vitaminMedication: 'vitaminMedication',
    calciumSupplementation: 'calciumSupplementation',
    calciumMedication: 'calciumMedication',
    healthEducationTopics: 'healthEducationTopics'
  };

  export type InterventionScalarFieldEnum = (typeof InterventionScalarFieldEnum)[keyof typeof InterventionScalarFieldEnum]


  export const BirthInformationScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    maternalHealthId: 'maternalHealthId',
    placeOfDelivery: 'placeOfDelivery',
    timeOfDelivery: 'timeOfDelivery',
    deliveryType: 'deliveryType',
    birthWeightKg: 'birthWeightKg',
    birthHeightCm: 'birthHeightCm',
    newbornScreeningDate: 'newbornScreeningDate',
    newbornScreeningCompleted: 'newbornScreeningCompleted',
    feedingType: 'feedingType',
    createdAt: 'createdAt',
    recordedBy: 'recordedBy'
  };

  export type BirthInformationScalarFieldEnum = (typeof BirthInformationScalarFieldEnum)[keyof typeof BirthInformationScalarFieldEnum]


  export const ImmunizationEventScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    visitDate: 'visitDate',
    temperatureCelsius: 'temperatureCelsius',
    weightKg: 'weightKg',
    heightCm: 'heightCm',
    adverseReactions: 'adverseReactions',
    healthWorkerName: 'healthWorkerName',
    healthWorkerSignature: 'healthWorkerSignature',
    nextFollowupDate: 'nextFollowupDate',
    recordedBy: 'recordedBy'
  };

  export type ImmunizationEventScalarFieldEnum = (typeof ImmunizationEventScalarFieldEnum)[keyof typeof ImmunizationEventScalarFieldEnum]


  export const VaccineGivenScalarFieldEnum: {
    id: 'id',
    immunizationEventId: 'immunizationEventId',
    vaccineName: 'vaccineName',
    doseNumber: 'doseNumber',
    dateGiven: 'dateGiven',
    lotNumber: 'lotNumber'
  };

  export type VaccineGivenScalarFieldEnum = (typeof VaccineGivenScalarFieldEnum)[keyof typeof VaccineGivenScalarFieldEnum]


  export const VitalSignsScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    recordDate: 'recordDate',
    bloodPressure: 'bloodPressure',
    heartRate: 'heartRate',
    respiratoryRate: 'respiratoryRate',
    temperatureCelsius: 'temperatureCelsius',
    pulseRate: 'pulseRate',
    recordedBy: 'recordedBy'
  };

  export type VitalSignsScalarFieldEnum = (typeof VitalSignsScalarFieldEnum)[keyof typeof VitalSignsScalarFieldEnum]


  export const AnthropometricMeasurementScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    measurementDate: 'measurementDate',
    weightKg: 'weightKg',
    heightCm: 'heightCm',
    headCircumferenceCm: 'headCircumferenceCm',
    waistCircumferenceCm: 'waistCircumferenceCm',
    bmi: 'bmi',
    recordedBy: 'recordedBy'
  };

  export type AnthropometricMeasurementScalarFieldEnum = (typeof AnthropometricMeasurementScalarFieldEnum)[keyof typeof AnthropometricMeasurementScalarFieldEnum]


  export const GrowthTrackingScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    trackingDate: 'trackingDate',
    weightForAge: 'weightForAge',
    heightForAge: 'heightForAge',
    weightForHeight: 'weightForHeight',
    recordedBy: 'recordedBy'
  };

  export type GrowthTrackingScalarFieldEnum = (typeof GrowthTrackingScalarFieldEnum)[keyof typeof GrowthTrackingScalarFieldEnum]


  export const NCDRiskAssessmentScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    assessmentDate: 'assessmentDate',
    smokingStatus: 'smokingStatus',
    alcoholIntake: 'alcoholIntake',
    physicalActivity: 'physicalActivity',
    fruitVegetableIntake: 'fruitVegetableIntake',
    familyHistoryDiabetes: 'familyHistoryDiabetes',
    familyHistoryHypertension: 'familyHistoryHypertension',
    familyHistoryHeartDisease: 'familyHistoryHeartDisease',
    familyHistoryStroke: 'familyHistoryStroke',
    screeningCompleted: 'screeningCompleted',
    followUpNeeded: 'followUpNeeded',
    lifestyleModifications: 'lifestyleModifications',
    healthEducationReceived: 'healthEducationReceived',
    recordedBy: 'recordedBy'
  };

  export type NCDRiskAssessmentScalarFieldEnum = (typeof NCDRiskAssessmentScalarFieldEnum)[keyof typeof NCDRiskAssessmentScalarFieldEnum]


  export const VisitRecordScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    visitDate: 'visitDate',
    visitType: 'visitType',
    visitFrequency: 'visitFrequency',
    referred: 'referred',
    facilityName: 'facilityName',
    referralReason: 'referralReason',
    recordedBy: 'recordedBy'
  };

  export type VisitRecordScalarFieldEnum = (typeof VisitRecordScalarFieldEnum)[keyof typeof VisitRecordScalarFieldEnum]


  export const HealthEducationScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    topicsCovered: 'topicsCovered',
    dateProvided: 'dateProvided',
    providedBy: 'providedBy'
  };

  export type HealthEducationScalarFieldEnum = (typeof HealthEducationScalarFieldEnum)[keyof typeof HealthEducationScalarFieldEnum]


  export const NutritionalCounselingScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    recommendations: 'recommendations',
    dateProvided: 'dateProvided',
    providedBy: 'providedBy'
  };

  export type NutritionalCounselingScalarFieldEnum = (typeof NutritionalCounselingScalarFieldEnum)[keyof typeof NutritionalCounselingScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    facilityName: 'facilityName',
    reason: 'reason',
    dateReferred: 'dateReferred',
    status: 'status',
    referredBy: 'referredBy'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    nextVisitDate: 'nextVisitDate',
    visitType: 'visitType',
    appointmentStatus: 'appointmentStatus',
    scheduledBy: 'scheduledBy',
    createdAt: 'createdAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const ImmunizationReminderScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    vaccineName: 'vaccineName',
    dueDate: 'dueDate',
    reminderSent: 'reminderSent',
    sentAt: 'sentAt'
  };

  export type ImmunizationReminderScalarFieldEnum = (typeof ImmunizationReminderScalarFieldEnum)[keyof typeof ImmunizationReminderScalarFieldEnum]


  export const TestReminderScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    testName: 'testName',
    dueDate: 'dueDate',
    reminderSent: 'reminderSent',
    sentAt: 'sentAt'
  };

  export type TestReminderScalarFieldEnum = (typeof TestReminderScalarFieldEnum)[keyof typeof TestReminderScalarFieldEnum]


  export const VirtualCheckupScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    healthWorkerId: 'healthWorkerId',
    scheduledDate: 'scheduledDate',
    scheduledTime: 'scheduledTime',
    meetingUrl: 'meetingUrl',
    status: 'status',
    consultationType: 'consultationType',
    chiefComplaint: 'chiefComplaint',
    notes: 'notes',
    durationMinutes: 'durationMinutes',
    createdAt: 'createdAt'
  };

  export type VirtualCheckupScalarFieldEnum = (typeof VirtualCheckupScalarFieldEnum)[keyof typeof VirtualCheckupScalarFieldEnum]


  export const VirtualCheckupNoteScalarFieldEnum: {
    id: 'id',
    virtualCheckupId: 'virtualCheckupId',
    note: 'note',
    createdBy: 'createdBy'
  };

  export type VirtualCheckupNoteScalarFieldEnum = (typeof VirtualCheckupNoteScalarFieldEnum)[keyof typeof VirtualCheckupNoteScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    eventType: 'eventType',
    eventDate: 'eventDate',
    startTime: 'startTime',
    endTime: 'endTime',
    venue: 'venue',
    targetAudience: 'targetAudience',
    maxParticipants: 'maxParticipants',
    status: 'status',
    bannerImageUrl: 'bannerImageUrl',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventRegistrationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userProfileId: 'userProfileId',
    registrationDate: 'registrationDate',
    status: 'status',
    notes: 'notes'
  };

  export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


  export const MedicalProgramScalarFieldEnum: {
    id: 'id',
    programName: 'programName',
    description: 'description',
    programType: 'programType',
    startDate: 'startDate',
    endDate: 'endDate',
    venue: 'venue',
    targetDemographic: 'targetDemographic',
    targetParticipants: 'targetParticipants',
    status: 'status',
    bannerImageUrl: 'bannerImageUrl',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type MedicalProgramScalarFieldEnum = (typeof MedicalProgramScalarFieldEnum)[keyof typeof MedicalProgramScalarFieldEnum]


  export const ProgramParticipationScalarFieldEnum: {
    id: 'id',
    medicalProgramId: 'medicalProgramId',
    userProfileId: 'userProfileId',
    participationDate: 'participationDate',
    status: 'status',
    servicesReceived: 'servicesReceived',
    notes: 'notes',
    recordedBy: 'recordedBy'
  };

  export type ProgramParticipationScalarFieldEnum = (typeof ProgramParticipationScalarFieldEnum)[keyof typeof ProgramParticipationScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    subject: 'subject',
    message: 'message',
    priority: 'priority',
    status: 'status',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const InquiryResponseScalarFieldEnum: {
    id: 'id',
    inquiryId: 'inquiryId',
    message: 'message',
    respondedBy: 'respondedBy'
  };

  export type InquiryResponseScalarFieldEnum = (typeof InquiryResponseScalarFieldEnum)[keyof typeof InquiryResponseScalarFieldEnum]


  export const SurveyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    surveyType: 'surveyType',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    qrCode: 'qrCode',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


  export const SurveyQuestionScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    questionText: 'questionText',
    questionType: 'questionType',
    options: 'options',
    isRequired: 'isRequired',
    orderIndex: 'orderIndex'
  };

  export type SurveyQuestionScalarFieldEnum = (typeof SurveyQuestionScalarFieldEnum)[keyof typeof SurveyQuestionScalarFieldEnum]


  export const SurveyResponseScalarFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    userProfileId: 'userProfileId',
    ipAddress: 'ipAddress',
    submittedAt: 'submittedAt'
  };

  export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


  export const SurveyAnswerScalarFieldEnum: {
    id: 'id',
    surveyResponseId: 'surveyResponseId',
    surveyQuestionId: 'surveyQuestionId',
    answer: 'answer'
  };

  export type SurveyAnswerScalarFieldEnum = (typeof SurveyAnswerScalarFieldEnum)[keyof typeof SurveyAnswerScalarFieldEnum]


  export const AnalyticsReportScalarFieldEnum: {
    id: 'id',
    reportName: 'reportName',
    reportType: 'reportType',
    dataFilters: 'dataFilters',
    reportData: 'reportData',
    reportPeriodStart: 'reportPeriodStart',
    reportPeriodEnd: 'reportPeriodEnd',
    generatedBy: 'generatedBy'
  };

  export type AnalyticsReportScalarFieldEnum = (typeof AnalyticsReportScalarFieldEnum)[keyof typeof AnalyticsReportScalarFieldEnum]


  export const PredictionModelScalarFieldEnum: {
    id: 'id',
    modelName: 'modelName',
    modelType: 'modelType',
    modelParameters: 'modelParameters',
    predictionResults: 'predictionResults',
    accuracy: 'accuracy',
    lastTrained: 'lastTrained',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type PredictionModelScalarFieldEnum = (typeof PredictionModelScalarFieldEnum)[keyof typeof PredictionModelScalarFieldEnum]


  export const SystemLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldData: 'oldData',
    newData: 'newData',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SystemLogScalarFieldEnum = (typeof SystemLogScalarFieldEnum)[keyof typeof SystemLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const AccountOrderByRelevanceFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    role: 'role',
    profilePictureUrl: 'profilePictureUrl'
  };

  export type AccountOrderByRelevanceFieldEnum = (typeof AccountOrderByRelevanceFieldEnum)[keyof typeof AccountOrderByRelevanceFieldEnum]


  export const UserProfileOrderByRelevanceFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    fullName: 'fullName',
    gender: 'gender',
    address: 'address',
    contactNumber: 'contactNumber',
    religion: 'religion',
    civilStatus: 'civilStatus',
    occupation: 'occupation',
    educationLevel: 'educationLevel',
    philhealthNumber: 'philhealthNumber',
    nhtsStatus: 'nhtsStatus'
  };

  export type UserProfileOrderByRelevanceFieldEnum = (typeof UserProfileOrderByRelevanceFieldEnum)[keyof typeof UserProfileOrderByRelevanceFieldEnum]


  export const HealthWorkerOrderByRelevanceFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    name: 'name',
    role: 'role',
    contactNumber: 'contactNumber',
    signature: 'signature'
  };

  export type HealthWorkerOrderByRelevanceFieldEnum = (typeof HealthWorkerOrderByRelevanceFieldEnum)[keyof typeof HealthWorkerOrderByRelevanceFieldEnum]


  export const FamilyRecordOrderByRelevanceFieldEnum: {
    id: 'id',
    familyId: 'familyId',
    headOfFamilyId: 'headOfFamilyId',
    address: 'address',
    contactNumber: 'contactNumber'
  };

  export type FamilyRecordOrderByRelevanceFieldEnum = (typeof FamilyRecordOrderByRelevanceFieldEnum)[keyof typeof FamilyRecordOrderByRelevanceFieldEnum]


  export const FamilyMemberOrderByRelevanceFieldEnum: {
    id: 'id',
    familyRecordId: 'familyRecordId',
    userProfileId: 'userProfileId',
    memberName: 'memberName',
    relationship: 'relationship',
    gender: 'gender',
    occupation: 'occupation',
    civilStatus: 'civilStatus'
  };

  export type FamilyMemberOrderByRelevanceFieldEnum = (typeof FamilyMemberOrderByRelevanceFieldEnum)[keyof typeof FamilyMemberOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const FamilyHealthHistoryOrderByRelevanceFieldEnum: {
    id: 'id',
    familyRecordId: 'familyRecordId',
    recordedBy: 'recordedBy'
  };

  export type FamilyHealthHistoryOrderByRelevanceFieldEnum = (typeof FamilyHealthHistoryOrderByRelevanceFieldEnum)[keyof typeof FamilyHealthHistoryOrderByRelevanceFieldEnum]


  export const MaternalHealthOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    mothersName: 'mothersName',
    mothersMaidenName: 'mothersMaidenName',
    mothersReligion: 'mothersReligion',
    mothersEducation: 'mothersEducation',
    mothersOccupation: 'mothersOccupation',
    gravidaPara: 'gravidaPara',
    tetanusToxoidStatus: 'tetanusToxoidStatus'
  };

  export type MaternalHealthOrderByRelevanceFieldEnum = (typeof MaternalHealthOrderByRelevanceFieldEnum)[keyof typeof MaternalHealthOrderByRelevanceFieldEnum]


  export const PrenatalVisitOrderByRelevanceFieldEnum: {
    id: 'id',
    maternalHealthId: 'maternalHealthId',
    bloodPressure: 'bloodPressure',
    fetalHeartTone: 'fetalHeartTone',
    recordedBy: 'recordedBy'
  };

  export type PrenatalVisitOrderByRelevanceFieldEnum = (typeof PrenatalVisitOrderByRelevanceFieldEnum)[keyof typeof PrenatalVisitOrderByRelevanceFieldEnum]


  export const LaboratoryTestOrderByRelevanceFieldEnum: {
    id: 'id',
    prenatalVisitId: 'prenatalVisitId',
    userProfileId: 'userProfileId',
    testType: 'testType',
    recordedBy: 'recordedBy'
  };

  export type LaboratoryTestOrderByRelevanceFieldEnum = (typeof LaboratoryTestOrderByRelevanceFieldEnum)[keyof typeof LaboratoryTestOrderByRelevanceFieldEnum]


  export const InterventionOrderByRelevanceFieldEnum: {
    id: 'id',
    prenatalVisitId: 'prenatalVisitId',
    tetanusToxoidDose: 'tetanusToxoidDose',
    tetanusToxoidLocation: 'tetanusToxoidLocation',
    ironMedication: 'ironMedication',
    vitaminMedication: 'vitaminMedication',
    calciumMedication: 'calciumMedication'
  };

  export type InterventionOrderByRelevanceFieldEnum = (typeof InterventionOrderByRelevanceFieldEnum)[keyof typeof InterventionOrderByRelevanceFieldEnum]


  export const BirthInformationOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    maternalHealthId: 'maternalHealthId',
    placeOfDelivery: 'placeOfDelivery',
    timeOfDelivery: 'timeOfDelivery',
    deliveryType: 'deliveryType',
    feedingType: 'feedingType',
    recordedBy: 'recordedBy'
  };

  export type BirthInformationOrderByRelevanceFieldEnum = (typeof BirthInformationOrderByRelevanceFieldEnum)[keyof typeof BirthInformationOrderByRelevanceFieldEnum]


  export const ImmunizationEventOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    adverseReactions: 'adverseReactions',
    healthWorkerName: 'healthWorkerName',
    healthWorkerSignature: 'healthWorkerSignature',
    recordedBy: 'recordedBy'
  };

  export type ImmunizationEventOrderByRelevanceFieldEnum = (typeof ImmunizationEventOrderByRelevanceFieldEnum)[keyof typeof ImmunizationEventOrderByRelevanceFieldEnum]


  export const VaccineGivenOrderByRelevanceFieldEnum: {
    id: 'id',
    immunizationEventId: 'immunizationEventId',
    vaccineName: 'vaccineName',
    doseNumber: 'doseNumber',
    lotNumber: 'lotNumber'
  };

  export type VaccineGivenOrderByRelevanceFieldEnum = (typeof VaccineGivenOrderByRelevanceFieldEnum)[keyof typeof VaccineGivenOrderByRelevanceFieldEnum]


  export const VitalSignsOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    bloodPressure: 'bloodPressure',
    recordedBy: 'recordedBy'
  };

  export type VitalSignsOrderByRelevanceFieldEnum = (typeof VitalSignsOrderByRelevanceFieldEnum)[keyof typeof VitalSignsOrderByRelevanceFieldEnum]


  export const AnthropometricMeasurementOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    recordedBy: 'recordedBy'
  };

  export type AnthropometricMeasurementOrderByRelevanceFieldEnum = (typeof AnthropometricMeasurementOrderByRelevanceFieldEnum)[keyof typeof AnthropometricMeasurementOrderByRelevanceFieldEnum]


  export const GrowthTrackingOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    weightForAge: 'weightForAge',
    heightForAge: 'heightForAge',
    weightForHeight: 'weightForHeight',
    recordedBy: 'recordedBy'
  };

  export type GrowthTrackingOrderByRelevanceFieldEnum = (typeof GrowthTrackingOrderByRelevanceFieldEnum)[keyof typeof GrowthTrackingOrderByRelevanceFieldEnum]


  export const NCDRiskAssessmentOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    smokingStatus: 'smokingStatus',
    alcoholIntake: 'alcoholIntake',
    physicalActivity: 'physicalActivity',
    fruitVegetableIntake: 'fruitVegetableIntake',
    recordedBy: 'recordedBy'
  };

  export type NCDRiskAssessmentOrderByRelevanceFieldEnum = (typeof NCDRiskAssessmentOrderByRelevanceFieldEnum)[keyof typeof NCDRiskAssessmentOrderByRelevanceFieldEnum]


  export const VisitRecordOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    visitType: 'visitType',
    visitFrequency: 'visitFrequency',
    facilityName: 'facilityName',
    referralReason: 'referralReason',
    recordedBy: 'recordedBy'
  };

  export type VisitRecordOrderByRelevanceFieldEnum = (typeof VisitRecordOrderByRelevanceFieldEnum)[keyof typeof VisitRecordOrderByRelevanceFieldEnum]


  export const HealthEducationOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    providedBy: 'providedBy'
  };

  export type HealthEducationOrderByRelevanceFieldEnum = (typeof HealthEducationOrderByRelevanceFieldEnum)[keyof typeof HealthEducationOrderByRelevanceFieldEnum]


  export const NutritionalCounselingOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    recommendations: 'recommendations',
    providedBy: 'providedBy'
  };

  export type NutritionalCounselingOrderByRelevanceFieldEnum = (typeof NutritionalCounselingOrderByRelevanceFieldEnum)[keyof typeof NutritionalCounselingOrderByRelevanceFieldEnum]


  export const ReferralOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    facilityName: 'facilityName',
    reason: 'reason',
    status: 'status',
    referredBy: 'referredBy'
  };

  export type ReferralOrderByRelevanceFieldEnum = (typeof ReferralOrderByRelevanceFieldEnum)[keyof typeof ReferralOrderByRelevanceFieldEnum]


  export const AppointmentOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    visitType: 'visitType',
    appointmentStatus: 'appointmentStatus',
    scheduledBy: 'scheduledBy'
  };

  export type AppointmentOrderByRelevanceFieldEnum = (typeof AppointmentOrderByRelevanceFieldEnum)[keyof typeof AppointmentOrderByRelevanceFieldEnum]


  export const ImmunizationReminderOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    vaccineName: 'vaccineName'
  };

  export type ImmunizationReminderOrderByRelevanceFieldEnum = (typeof ImmunizationReminderOrderByRelevanceFieldEnum)[keyof typeof ImmunizationReminderOrderByRelevanceFieldEnum]


  export const TestReminderOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    testName: 'testName'
  };

  export type TestReminderOrderByRelevanceFieldEnum = (typeof TestReminderOrderByRelevanceFieldEnum)[keyof typeof TestReminderOrderByRelevanceFieldEnum]


  export const VirtualCheckupOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    healthWorkerId: 'healthWorkerId',
    scheduledTime: 'scheduledTime',
    meetingUrl: 'meetingUrl',
    status: 'status',
    consultationType: 'consultationType',
    chiefComplaint: 'chiefComplaint',
    notes: 'notes'
  };

  export type VirtualCheckupOrderByRelevanceFieldEnum = (typeof VirtualCheckupOrderByRelevanceFieldEnum)[keyof typeof VirtualCheckupOrderByRelevanceFieldEnum]


  export const VirtualCheckupNoteOrderByRelevanceFieldEnum: {
    id: 'id',
    virtualCheckupId: 'virtualCheckupId',
    note: 'note',
    createdBy: 'createdBy'
  };

  export type VirtualCheckupNoteOrderByRelevanceFieldEnum = (typeof VirtualCheckupNoteOrderByRelevanceFieldEnum)[keyof typeof VirtualCheckupNoteOrderByRelevanceFieldEnum]


  export const EventOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    eventType: 'eventType',
    startTime: 'startTime',
    endTime: 'endTime',
    venue: 'venue',
    targetAudience: 'targetAudience',
    status: 'status',
    bannerImageUrl: 'bannerImageUrl',
    createdBy: 'createdBy'
  };

  export type EventOrderByRelevanceFieldEnum = (typeof EventOrderByRelevanceFieldEnum)[keyof typeof EventOrderByRelevanceFieldEnum]


  export const EventRegistrationOrderByRelevanceFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userProfileId: 'userProfileId',
    status: 'status',
    notes: 'notes'
  };

  export type EventRegistrationOrderByRelevanceFieldEnum = (typeof EventRegistrationOrderByRelevanceFieldEnum)[keyof typeof EventRegistrationOrderByRelevanceFieldEnum]


  export const MedicalProgramOrderByRelevanceFieldEnum: {
    id: 'id',
    programName: 'programName',
    description: 'description',
    programType: 'programType',
    venue: 'venue',
    targetDemographic: 'targetDemographic',
    status: 'status',
    bannerImageUrl: 'bannerImageUrl',
    createdBy: 'createdBy'
  };

  export type MedicalProgramOrderByRelevanceFieldEnum = (typeof MedicalProgramOrderByRelevanceFieldEnum)[keyof typeof MedicalProgramOrderByRelevanceFieldEnum]


  export const ProgramParticipationOrderByRelevanceFieldEnum: {
    id: 'id',
    medicalProgramId: 'medicalProgramId',
    userProfileId: 'userProfileId',
    status: 'status',
    servicesReceived: 'servicesReceived',
    notes: 'notes',
    recordedBy: 'recordedBy'
  };

  export type ProgramParticipationOrderByRelevanceFieldEnum = (typeof ProgramParticipationOrderByRelevanceFieldEnum)[keyof typeof ProgramParticipationOrderByRelevanceFieldEnum]


  export const InquiryOrderByRelevanceFieldEnum: {
    id: 'id',
    userProfileId: 'userProfileId',
    subject: 'subject',
    message: 'message',
    priority: 'priority',
    status: 'status',
    category: 'category'
  };

  export type InquiryOrderByRelevanceFieldEnum = (typeof InquiryOrderByRelevanceFieldEnum)[keyof typeof InquiryOrderByRelevanceFieldEnum]


  export const InquiryResponseOrderByRelevanceFieldEnum: {
    id: 'id',
    inquiryId: 'inquiryId',
    message: 'message',
    respondedBy: 'respondedBy'
  };

  export type InquiryResponseOrderByRelevanceFieldEnum = (typeof InquiryResponseOrderByRelevanceFieldEnum)[keyof typeof InquiryResponseOrderByRelevanceFieldEnum]


  export const SurveyOrderByRelevanceFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    surveyType: 'surveyType',
    qrCode: 'qrCode',
    createdBy: 'createdBy'
  };

  export type SurveyOrderByRelevanceFieldEnum = (typeof SurveyOrderByRelevanceFieldEnum)[keyof typeof SurveyOrderByRelevanceFieldEnum]


  export const SurveyQuestionOrderByRelevanceFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    questionText: 'questionText',
    questionType: 'questionType'
  };

  export type SurveyQuestionOrderByRelevanceFieldEnum = (typeof SurveyQuestionOrderByRelevanceFieldEnum)[keyof typeof SurveyQuestionOrderByRelevanceFieldEnum]


  export const SurveyResponseOrderByRelevanceFieldEnum: {
    id: 'id',
    surveyId: 'surveyId',
    userProfileId: 'userProfileId',
    ipAddress: 'ipAddress'
  };

  export type SurveyResponseOrderByRelevanceFieldEnum = (typeof SurveyResponseOrderByRelevanceFieldEnum)[keyof typeof SurveyResponseOrderByRelevanceFieldEnum]


  export const SurveyAnswerOrderByRelevanceFieldEnum: {
    id: 'id',
    surveyResponseId: 'surveyResponseId',
    surveyQuestionId: 'surveyQuestionId',
    answer: 'answer'
  };

  export type SurveyAnswerOrderByRelevanceFieldEnum = (typeof SurveyAnswerOrderByRelevanceFieldEnum)[keyof typeof SurveyAnswerOrderByRelevanceFieldEnum]


  export const AnalyticsReportOrderByRelevanceFieldEnum: {
    id: 'id',
    reportName: 'reportName',
    reportType: 'reportType',
    generatedBy: 'generatedBy'
  };

  export type AnalyticsReportOrderByRelevanceFieldEnum = (typeof AnalyticsReportOrderByRelevanceFieldEnum)[keyof typeof AnalyticsReportOrderByRelevanceFieldEnum]


  export const PredictionModelOrderByRelevanceFieldEnum: {
    id: 'id',
    modelName: 'modelName',
    modelType: 'modelType',
    createdBy: 'createdBy'
  };

  export type PredictionModelOrderByRelevanceFieldEnum = (typeof PredictionModelOrderByRelevanceFieldEnum)[keyof typeof PredictionModelOrderByRelevanceFieldEnum]


  export const SystemLogOrderByRelevanceFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type SystemLogOrderByRelevanceFieldEnum = (typeof SystemLogOrderByRelevanceFieldEnum)[keyof typeof SystemLogOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    email?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    role?: StringFilter<"Account"> | string
    isActive?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    profilePictureUrl?: StringNullableFilter<"Account"> | string | null
    emailVerified?: BoolFilter<"Account"> | boolean
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    healthWorkers?: HealthWorkerListRelationFilter
    events?: EventListRelationFilter
    surveys?: SurveyListRelationFilter
    inquiryResponses?: InquiryResponseListRelationFilter
    analyticsReports?: AnalyticsReportListRelationFilter
    predictionModels?: PredictionModelListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    medicalPrograms?: MedicalProgramListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    healthWorkers?: HealthWorkerOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    surveys?: SurveyOrderByRelationAggregateInput
    inquiryResponses?: InquiryResponseOrderByRelationAggregateInput
    analyticsReports?: AnalyticsReportOrderByRelationAggregateInput
    predictionModels?: PredictionModelOrderByRelationAggregateInput
    systemLogs?: SystemLogOrderByRelationAggregateInput
    medicalPrograms?: MedicalProgramOrderByRelationAggregateInput
    _relevance?: AccountOrderByRelevanceInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    password?: StringFilter<"Account"> | string
    role?: StringFilter<"Account"> | string
    isActive?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    profilePictureUrl?: StringNullableFilter<"Account"> | string | null
    emailVerified?: BoolFilter<"Account"> | boolean
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    healthWorkers?: HealthWorkerListRelationFilter
    events?: EventListRelationFilter
    surveys?: SurveyListRelationFilter
    inquiryResponses?: InquiryResponseListRelationFilter
    analyticsReports?: AnalyticsReportListRelationFilter
    predictionModels?: PredictionModelListRelationFilter
    systemLogs?: SystemLogListRelationFilter
    medicalPrograms?: MedicalProgramListRelationFilter
  }, "id" | "email">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    email?: StringWithAggregatesFilter<"Account"> | string
    password?: StringWithAggregatesFilter<"Account"> | string
    role?: StringWithAggregatesFilter<"Account"> | string
    isActive?: BoolWithAggregatesFilter<"Account"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    profilePictureUrl?: StringNullableWithAggregatesFilter<"Account"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"Account"> | boolean
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    accountId?: StringFilter<"UserProfile"> | string
    fullName?: StringFilter<"UserProfile"> | string
    dateOfBirth?: DateTimeFilter<"UserProfile"> | Date | string
    age?: IntFilter<"UserProfile"> | number
    gender?: StringFilter<"UserProfile"> | string
    address?: StringFilter<"UserProfile"> | string
    contactNumber?: StringFilter<"UserProfile"> | string
    religion?: StringNullableFilter<"UserProfile"> | string | null
    civilStatus?: StringFilter<"UserProfile"> | string
    occupation?: StringNullableFilter<"UserProfile"> | string | null
    educationLevel?: StringNullableFilter<"UserProfile"> | string | null
    philhealthNumber?: StringNullableFilter<"UserProfile"> | string | null
    nhtsStatus?: StringNullableFilter<"UserProfile"> | string | null
    personWithDisability?: BoolFilter<"UserProfile"> | boolean
    indigenousPeople?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    familyRecordsHeaded?: FamilyRecordListRelationFilter
    familyMembers?: FamilyMemberListRelationFilter
    maternalHealthRecords?: MaternalHealthListRelationFilter
    birthInformation?: BirthInformationListRelationFilter
    immunizationEvents?: ImmunizationEventListRelationFilter
    vitalSigns?: VitalSignsListRelationFilter
    anthropometricMeasurements?: AnthropometricMeasurementListRelationFilter
    growthTracking?: GrowthTrackingListRelationFilter
    ncdRiskAssessments?: NCDRiskAssessmentListRelationFilter
    visitRecords?: VisitRecordListRelationFilter
    healthEducation?: HealthEducationListRelationFilter
    nutritionalCounseling?: NutritionalCounselingListRelationFilter
    referrals?: ReferralListRelationFilter
    appointments?: AppointmentListRelationFilter
    immunizationReminders?: ImmunizationReminderListRelationFilter
    testReminders?: TestReminderListRelationFilter
    virtualCheckups?: VirtualCheckupListRelationFilter
    eventRegistrations?: EventRegistrationListRelationFilter
    programParticipations?: ProgramParticipationListRelationFilter
    inquiries?: InquiryListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    religion?: SortOrderInput | SortOrder
    civilStatus?: SortOrder
    occupation?: SortOrderInput | SortOrder
    educationLevel?: SortOrderInput | SortOrder
    philhealthNumber?: SortOrderInput | SortOrder
    nhtsStatus?: SortOrderInput | SortOrder
    personWithDisability?: SortOrder
    indigenousPeople?: SortOrder
    createdAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    familyRecordsHeaded?: FamilyRecordOrderByRelationAggregateInput
    familyMembers?: FamilyMemberOrderByRelationAggregateInput
    maternalHealthRecords?: MaternalHealthOrderByRelationAggregateInput
    birthInformation?: BirthInformationOrderByRelationAggregateInput
    immunizationEvents?: ImmunizationEventOrderByRelationAggregateInput
    vitalSigns?: VitalSignsOrderByRelationAggregateInput
    anthropometricMeasurements?: AnthropometricMeasurementOrderByRelationAggregateInput
    growthTracking?: GrowthTrackingOrderByRelationAggregateInput
    ncdRiskAssessments?: NCDRiskAssessmentOrderByRelationAggregateInput
    visitRecords?: VisitRecordOrderByRelationAggregateInput
    healthEducation?: HealthEducationOrderByRelationAggregateInput
    nutritionalCounseling?: NutritionalCounselingOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    immunizationReminders?: ImmunizationReminderOrderByRelationAggregateInput
    testReminders?: TestReminderOrderByRelationAggregateInput
    virtualCheckups?: VirtualCheckupOrderByRelationAggregateInput
    eventRegistrations?: EventRegistrationOrderByRelationAggregateInput
    programParticipations?: ProgramParticipationOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
    surveyResponses?: SurveyResponseOrderByRelationAggregateInput
    _relevance?: UserProfileOrderByRelevanceInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    fullName?: StringFilter<"UserProfile"> | string
    dateOfBirth?: DateTimeFilter<"UserProfile"> | Date | string
    age?: IntFilter<"UserProfile"> | number
    gender?: StringFilter<"UserProfile"> | string
    address?: StringFilter<"UserProfile"> | string
    contactNumber?: StringFilter<"UserProfile"> | string
    religion?: StringNullableFilter<"UserProfile"> | string | null
    civilStatus?: StringFilter<"UserProfile"> | string
    occupation?: StringNullableFilter<"UserProfile"> | string | null
    educationLevel?: StringNullableFilter<"UserProfile"> | string | null
    philhealthNumber?: StringNullableFilter<"UserProfile"> | string | null
    nhtsStatus?: StringNullableFilter<"UserProfile"> | string | null
    personWithDisability?: BoolFilter<"UserProfile"> | boolean
    indigenousPeople?: BoolFilter<"UserProfile"> | boolean
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    familyRecordsHeaded?: FamilyRecordListRelationFilter
    familyMembers?: FamilyMemberListRelationFilter
    maternalHealthRecords?: MaternalHealthListRelationFilter
    birthInformation?: BirthInformationListRelationFilter
    immunizationEvents?: ImmunizationEventListRelationFilter
    vitalSigns?: VitalSignsListRelationFilter
    anthropometricMeasurements?: AnthropometricMeasurementListRelationFilter
    growthTracking?: GrowthTrackingListRelationFilter
    ncdRiskAssessments?: NCDRiskAssessmentListRelationFilter
    visitRecords?: VisitRecordListRelationFilter
    healthEducation?: HealthEducationListRelationFilter
    nutritionalCounseling?: NutritionalCounselingListRelationFilter
    referrals?: ReferralListRelationFilter
    appointments?: AppointmentListRelationFilter
    immunizationReminders?: ImmunizationReminderListRelationFilter
    testReminders?: TestReminderListRelationFilter
    virtualCheckups?: VirtualCheckupListRelationFilter
    eventRegistrations?: EventRegistrationListRelationFilter
    programParticipations?: ProgramParticipationListRelationFilter
    inquiries?: InquiryListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
  }, "id" | "accountId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    religion?: SortOrderInput | SortOrder
    civilStatus?: SortOrder
    occupation?: SortOrderInput | SortOrder
    educationLevel?: SortOrderInput | SortOrder
    philhealthNumber?: SortOrderInput | SortOrder
    nhtsStatus?: SortOrderInput | SortOrder
    personWithDisability?: SortOrder
    indigenousPeople?: SortOrder
    createdAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    accountId?: StringWithAggregatesFilter<"UserProfile"> | string
    fullName?: StringWithAggregatesFilter<"UserProfile"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    age?: IntWithAggregatesFilter<"UserProfile"> | number
    gender?: StringWithAggregatesFilter<"UserProfile"> | string
    address?: StringWithAggregatesFilter<"UserProfile"> | string
    contactNumber?: StringWithAggregatesFilter<"UserProfile"> | string
    religion?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    civilStatus?: StringWithAggregatesFilter<"UserProfile"> | string
    occupation?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    educationLevel?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    philhealthNumber?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    nhtsStatus?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    personWithDisability?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    indigenousPeople?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type HealthWorkerWhereInput = {
    AND?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    OR?: HealthWorkerWhereInput[]
    NOT?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    id?: StringFilter<"HealthWorker"> | string
    accountId?: StringFilter<"HealthWorker"> | string
    name?: StringFilter<"HealthWorker"> | string
    role?: StringFilter<"HealthWorker"> | string
    contactNumber?: StringFilter<"HealthWorker"> | string
    signature?: StringNullableFilter<"HealthWorker"> | string | null
    isActive?: BoolFilter<"HealthWorker"> | boolean
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    virtualCheckups?: VirtualCheckupListRelationFilter
  }

  export type HealthWorkerOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    signature?: SortOrderInput | SortOrder
    isActive?: SortOrder
    account?: AccountOrderByWithRelationInput
    virtualCheckups?: VirtualCheckupOrderByRelationAggregateInput
    _relevance?: HealthWorkerOrderByRelevanceInput
  }

  export type HealthWorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    OR?: HealthWorkerWhereInput[]
    NOT?: HealthWorkerWhereInput | HealthWorkerWhereInput[]
    accountId?: StringFilter<"HealthWorker"> | string
    name?: StringFilter<"HealthWorker"> | string
    role?: StringFilter<"HealthWorker"> | string
    contactNumber?: StringFilter<"HealthWorker"> | string
    signature?: StringNullableFilter<"HealthWorker"> | string | null
    isActive?: BoolFilter<"HealthWorker"> | boolean
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    virtualCheckups?: VirtualCheckupListRelationFilter
  }, "id">

  export type HealthWorkerOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    signature?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: HealthWorkerCountOrderByAggregateInput
    _max?: HealthWorkerMaxOrderByAggregateInput
    _min?: HealthWorkerMinOrderByAggregateInput
  }

  export type HealthWorkerScalarWhereWithAggregatesInput = {
    AND?: HealthWorkerScalarWhereWithAggregatesInput | HealthWorkerScalarWhereWithAggregatesInput[]
    OR?: HealthWorkerScalarWhereWithAggregatesInput[]
    NOT?: HealthWorkerScalarWhereWithAggregatesInput | HealthWorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthWorker"> | string
    accountId?: StringWithAggregatesFilter<"HealthWorker"> | string
    name?: StringWithAggregatesFilter<"HealthWorker"> | string
    role?: StringWithAggregatesFilter<"HealthWorker"> | string
    contactNumber?: StringWithAggregatesFilter<"HealthWorker"> | string
    signature?: StringNullableWithAggregatesFilter<"HealthWorker"> | string | null
    isActive?: BoolWithAggregatesFilter<"HealthWorker"> | boolean
  }

  export type FamilyRecordWhereInput = {
    AND?: FamilyRecordWhereInput | FamilyRecordWhereInput[]
    OR?: FamilyRecordWhereInput[]
    NOT?: FamilyRecordWhereInput | FamilyRecordWhereInput[]
    id?: StringFilter<"FamilyRecord"> | string
    familyId?: StringFilter<"FamilyRecord"> | string
    headOfFamilyId?: StringFilter<"FamilyRecord"> | string
    address?: StringFilter<"FamilyRecord"> | string
    contactNumber?: StringFilter<"FamilyRecord"> | string
    smsConsent?: BoolFilter<"FamilyRecord"> | boolean
    createdAt?: DateTimeFilter<"FamilyRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyRecord"> | Date | string
    headOfFamily?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    members?: FamilyMemberListRelationFilter
    familyHealthHistory?: XOR<FamilyHealthHistoryNullableScalarRelationFilter, FamilyHealthHistoryWhereInput> | null
  }

  export type FamilyRecordOrderByWithRelationInput = {
    id?: SortOrder
    familyId?: SortOrder
    headOfFamilyId?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    smsConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    headOfFamily?: UserProfileOrderByWithRelationInput
    members?: FamilyMemberOrderByRelationAggregateInput
    familyHealthHistory?: FamilyHealthHistoryOrderByWithRelationInput
    _relevance?: FamilyRecordOrderByRelevanceInput
  }

  export type FamilyRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    familyId?: string
    AND?: FamilyRecordWhereInput | FamilyRecordWhereInput[]
    OR?: FamilyRecordWhereInput[]
    NOT?: FamilyRecordWhereInput | FamilyRecordWhereInput[]
    headOfFamilyId?: StringFilter<"FamilyRecord"> | string
    address?: StringFilter<"FamilyRecord"> | string
    contactNumber?: StringFilter<"FamilyRecord"> | string
    smsConsent?: BoolFilter<"FamilyRecord"> | boolean
    createdAt?: DateTimeFilter<"FamilyRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyRecord"> | Date | string
    headOfFamily?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    members?: FamilyMemberListRelationFilter
    familyHealthHistory?: XOR<FamilyHealthHistoryNullableScalarRelationFilter, FamilyHealthHistoryWhereInput> | null
  }, "id" | "familyId">

  export type FamilyRecordOrderByWithAggregationInput = {
    id?: SortOrder
    familyId?: SortOrder
    headOfFamilyId?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    smsConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FamilyRecordCountOrderByAggregateInput
    _max?: FamilyRecordMaxOrderByAggregateInput
    _min?: FamilyRecordMinOrderByAggregateInput
  }

  export type FamilyRecordScalarWhereWithAggregatesInput = {
    AND?: FamilyRecordScalarWhereWithAggregatesInput | FamilyRecordScalarWhereWithAggregatesInput[]
    OR?: FamilyRecordScalarWhereWithAggregatesInput[]
    NOT?: FamilyRecordScalarWhereWithAggregatesInput | FamilyRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyRecord"> | string
    familyId?: StringWithAggregatesFilter<"FamilyRecord"> | string
    headOfFamilyId?: StringWithAggregatesFilter<"FamilyRecord"> | string
    address?: StringWithAggregatesFilter<"FamilyRecord"> | string
    contactNumber?: StringWithAggregatesFilter<"FamilyRecord"> | string
    smsConsent?: BoolWithAggregatesFilter<"FamilyRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FamilyRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FamilyRecord"> | Date | string
  }

  export type FamilyMemberWhereInput = {
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    id?: StringFilter<"FamilyMember"> | string
    familyRecordId?: StringFilter<"FamilyMember"> | string
    userProfileId?: StringNullableFilter<"FamilyMember"> | string | null
    memberName?: StringFilter<"FamilyMember"> | string
    relationship?: StringFilter<"FamilyMember"> | string
    gender?: StringFilter<"FamilyMember"> | string
    age?: IntFilter<"FamilyMember"> | number
    occupation?: StringNullableFilter<"FamilyMember"> | string | null
    civilStatus?: StringFilter<"FamilyMember"> | string
    familyRecord?: XOR<FamilyRecordScalarRelationFilter, FamilyRecordWhereInput>
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
  }

  export type FamilyMemberOrderByWithRelationInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    userProfileId?: SortOrderInput | SortOrder
    memberName?: SortOrder
    relationship?: SortOrder
    gender?: SortOrder
    age?: SortOrder
    occupation?: SortOrderInput | SortOrder
    civilStatus?: SortOrder
    familyRecord?: FamilyRecordOrderByWithRelationInput
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: FamilyMemberOrderByRelevanceInput
  }

  export type FamilyMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    OR?: FamilyMemberWhereInput[]
    NOT?: FamilyMemberWhereInput | FamilyMemberWhereInput[]
    familyRecordId?: StringFilter<"FamilyMember"> | string
    userProfileId?: StringNullableFilter<"FamilyMember"> | string | null
    memberName?: StringFilter<"FamilyMember"> | string
    relationship?: StringFilter<"FamilyMember"> | string
    gender?: StringFilter<"FamilyMember"> | string
    age?: IntFilter<"FamilyMember"> | number
    occupation?: StringNullableFilter<"FamilyMember"> | string | null
    civilStatus?: StringFilter<"FamilyMember"> | string
    familyRecord?: XOR<FamilyRecordScalarRelationFilter, FamilyRecordWhereInput>
    userProfile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
  }, "id">

  export type FamilyMemberOrderByWithAggregationInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    userProfileId?: SortOrderInput | SortOrder
    memberName?: SortOrder
    relationship?: SortOrder
    gender?: SortOrder
    age?: SortOrder
    occupation?: SortOrderInput | SortOrder
    civilStatus?: SortOrder
    _count?: FamilyMemberCountOrderByAggregateInput
    _avg?: FamilyMemberAvgOrderByAggregateInput
    _max?: FamilyMemberMaxOrderByAggregateInput
    _min?: FamilyMemberMinOrderByAggregateInput
    _sum?: FamilyMemberSumOrderByAggregateInput
  }

  export type FamilyMemberScalarWhereWithAggregatesInput = {
    AND?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    OR?: FamilyMemberScalarWhereWithAggregatesInput[]
    NOT?: FamilyMemberScalarWhereWithAggregatesInput | FamilyMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyMember"> | string
    familyRecordId?: StringWithAggregatesFilter<"FamilyMember"> | string
    userProfileId?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    memberName?: StringWithAggregatesFilter<"FamilyMember"> | string
    relationship?: StringWithAggregatesFilter<"FamilyMember"> | string
    gender?: StringWithAggregatesFilter<"FamilyMember"> | string
    age?: IntWithAggregatesFilter<"FamilyMember"> | number
    occupation?: StringNullableWithAggregatesFilter<"FamilyMember"> | string | null
    civilStatus?: StringWithAggregatesFilter<"FamilyMember"> | string
  }

  export type FamilyHealthHistoryWhereInput = {
    AND?: FamilyHealthHistoryWhereInput | FamilyHealthHistoryWhereInput[]
    OR?: FamilyHealthHistoryWhereInput[]
    NOT?: FamilyHealthHistoryWhereInput | FamilyHealthHistoryWhereInput[]
    id?: StringFilter<"FamilyHealthHistory"> | string
    familyRecordId?: StringFilter<"FamilyHealthHistory"> | string
    geneticConditions?: JsonFilter<"FamilyHealthHistory">
    chronicDiseases?: JsonFilter<"FamilyHealthHistory">
    recordedDate?: DateTimeFilter<"FamilyHealthHistory"> | Date | string
    recordedBy?: StringFilter<"FamilyHealthHistory"> | string
    familyRecord?: XOR<FamilyRecordScalarRelationFilter, FamilyRecordWhereInput>
  }

  export type FamilyHealthHistoryOrderByWithRelationInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    geneticConditions?: SortOrder
    chronicDiseases?: SortOrder
    recordedDate?: SortOrder
    recordedBy?: SortOrder
    familyRecord?: FamilyRecordOrderByWithRelationInput
    _relevance?: FamilyHealthHistoryOrderByRelevanceInput
  }

  export type FamilyHealthHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    familyRecordId?: string
    AND?: FamilyHealthHistoryWhereInput | FamilyHealthHistoryWhereInput[]
    OR?: FamilyHealthHistoryWhereInput[]
    NOT?: FamilyHealthHistoryWhereInput | FamilyHealthHistoryWhereInput[]
    geneticConditions?: JsonFilter<"FamilyHealthHistory">
    chronicDiseases?: JsonFilter<"FamilyHealthHistory">
    recordedDate?: DateTimeFilter<"FamilyHealthHistory"> | Date | string
    recordedBy?: StringFilter<"FamilyHealthHistory"> | string
    familyRecord?: XOR<FamilyRecordScalarRelationFilter, FamilyRecordWhereInput>
  }, "id" | "familyRecordId">

  export type FamilyHealthHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    geneticConditions?: SortOrder
    chronicDiseases?: SortOrder
    recordedDate?: SortOrder
    recordedBy?: SortOrder
    _count?: FamilyHealthHistoryCountOrderByAggregateInput
    _max?: FamilyHealthHistoryMaxOrderByAggregateInput
    _min?: FamilyHealthHistoryMinOrderByAggregateInput
  }

  export type FamilyHealthHistoryScalarWhereWithAggregatesInput = {
    AND?: FamilyHealthHistoryScalarWhereWithAggregatesInput | FamilyHealthHistoryScalarWhereWithAggregatesInput[]
    OR?: FamilyHealthHistoryScalarWhereWithAggregatesInput[]
    NOT?: FamilyHealthHistoryScalarWhereWithAggregatesInput | FamilyHealthHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FamilyHealthHistory"> | string
    familyRecordId?: StringWithAggregatesFilter<"FamilyHealthHistory"> | string
    geneticConditions?: JsonWithAggregatesFilter<"FamilyHealthHistory">
    chronicDiseases?: JsonWithAggregatesFilter<"FamilyHealthHistory">
    recordedDate?: DateTimeWithAggregatesFilter<"FamilyHealthHistory"> | Date | string
    recordedBy?: StringWithAggregatesFilter<"FamilyHealthHistory"> | string
  }

  export type MaternalHealthWhereInput = {
    AND?: MaternalHealthWhereInput | MaternalHealthWhereInput[]
    OR?: MaternalHealthWhereInput[]
    NOT?: MaternalHealthWhereInput | MaternalHealthWhereInput[]
    id?: StringFilter<"MaternalHealth"> | string
    userProfileId?: StringFilter<"MaternalHealth"> | string
    mothersName?: StringFilter<"MaternalHealth"> | string
    mothersAge?: IntFilter<"MaternalHealth"> | number
    mothersBirthday?: DateTimeFilter<"MaternalHealth"> | Date | string
    mothersMaidenName?: StringFilter<"MaternalHealth"> | string
    mothersReligion?: StringNullableFilter<"MaternalHealth"> | string | null
    mothersEducation?: StringNullableFilter<"MaternalHealth"> | string | null
    mothersOccupation?: StringNullableFilter<"MaternalHealth"> | string | null
    numberOfChildren?: IntFilter<"MaternalHealth"> | number
    gravidaPara?: StringFilter<"MaternalHealth"> | string
    menarcheAge?: IntFilter<"MaternalHealth"> | number
    lastMenstrualPeriod?: DateTimeFilter<"MaternalHealth"> | Date | string
    expectedDeliveryDate?: DateTimeFilter<"MaternalHealth"> | Date | string
    tetanusToxoidStatus?: StringNullableFilter<"MaternalHealth"> | string | null
    createdAt?: DateTimeFilter<"MaternalHealth"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    prenatalVisits?: PrenatalVisitListRelationFilter
    birthInformation?: BirthInformationListRelationFilter
  }

  export type MaternalHealthOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    mothersName?: SortOrder
    mothersAge?: SortOrder
    mothersBirthday?: SortOrder
    mothersMaidenName?: SortOrder
    mothersReligion?: SortOrderInput | SortOrder
    mothersEducation?: SortOrderInput | SortOrder
    mothersOccupation?: SortOrderInput | SortOrder
    numberOfChildren?: SortOrder
    gravidaPara?: SortOrder
    menarcheAge?: SortOrder
    lastMenstrualPeriod?: SortOrder
    expectedDeliveryDate?: SortOrder
    tetanusToxoidStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    prenatalVisits?: PrenatalVisitOrderByRelationAggregateInput
    birthInformation?: BirthInformationOrderByRelationAggregateInput
    _relevance?: MaternalHealthOrderByRelevanceInput
  }

  export type MaternalHealthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaternalHealthWhereInput | MaternalHealthWhereInput[]
    OR?: MaternalHealthWhereInput[]
    NOT?: MaternalHealthWhereInput | MaternalHealthWhereInput[]
    userProfileId?: StringFilter<"MaternalHealth"> | string
    mothersName?: StringFilter<"MaternalHealth"> | string
    mothersAge?: IntFilter<"MaternalHealth"> | number
    mothersBirthday?: DateTimeFilter<"MaternalHealth"> | Date | string
    mothersMaidenName?: StringFilter<"MaternalHealth"> | string
    mothersReligion?: StringNullableFilter<"MaternalHealth"> | string | null
    mothersEducation?: StringNullableFilter<"MaternalHealth"> | string | null
    mothersOccupation?: StringNullableFilter<"MaternalHealth"> | string | null
    numberOfChildren?: IntFilter<"MaternalHealth"> | number
    gravidaPara?: StringFilter<"MaternalHealth"> | string
    menarcheAge?: IntFilter<"MaternalHealth"> | number
    lastMenstrualPeriod?: DateTimeFilter<"MaternalHealth"> | Date | string
    expectedDeliveryDate?: DateTimeFilter<"MaternalHealth"> | Date | string
    tetanusToxoidStatus?: StringNullableFilter<"MaternalHealth"> | string | null
    createdAt?: DateTimeFilter<"MaternalHealth"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    prenatalVisits?: PrenatalVisitListRelationFilter
    birthInformation?: BirthInformationListRelationFilter
  }, "id">

  export type MaternalHealthOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    mothersName?: SortOrder
    mothersAge?: SortOrder
    mothersBirthday?: SortOrder
    mothersMaidenName?: SortOrder
    mothersReligion?: SortOrderInput | SortOrder
    mothersEducation?: SortOrderInput | SortOrder
    mothersOccupation?: SortOrderInput | SortOrder
    numberOfChildren?: SortOrder
    gravidaPara?: SortOrder
    menarcheAge?: SortOrder
    lastMenstrualPeriod?: SortOrder
    expectedDeliveryDate?: SortOrder
    tetanusToxoidStatus?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MaternalHealthCountOrderByAggregateInput
    _avg?: MaternalHealthAvgOrderByAggregateInput
    _max?: MaternalHealthMaxOrderByAggregateInput
    _min?: MaternalHealthMinOrderByAggregateInput
    _sum?: MaternalHealthSumOrderByAggregateInput
  }

  export type MaternalHealthScalarWhereWithAggregatesInput = {
    AND?: MaternalHealthScalarWhereWithAggregatesInput | MaternalHealthScalarWhereWithAggregatesInput[]
    OR?: MaternalHealthScalarWhereWithAggregatesInput[]
    NOT?: MaternalHealthScalarWhereWithAggregatesInput | MaternalHealthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaternalHealth"> | string
    userProfileId?: StringWithAggregatesFilter<"MaternalHealth"> | string
    mothersName?: StringWithAggregatesFilter<"MaternalHealth"> | string
    mothersAge?: IntWithAggregatesFilter<"MaternalHealth"> | number
    mothersBirthday?: DateTimeWithAggregatesFilter<"MaternalHealth"> | Date | string
    mothersMaidenName?: StringWithAggregatesFilter<"MaternalHealth"> | string
    mothersReligion?: StringNullableWithAggregatesFilter<"MaternalHealth"> | string | null
    mothersEducation?: StringNullableWithAggregatesFilter<"MaternalHealth"> | string | null
    mothersOccupation?: StringNullableWithAggregatesFilter<"MaternalHealth"> | string | null
    numberOfChildren?: IntWithAggregatesFilter<"MaternalHealth"> | number
    gravidaPara?: StringWithAggregatesFilter<"MaternalHealth"> | string
    menarcheAge?: IntWithAggregatesFilter<"MaternalHealth"> | number
    lastMenstrualPeriod?: DateTimeWithAggregatesFilter<"MaternalHealth"> | Date | string
    expectedDeliveryDate?: DateTimeWithAggregatesFilter<"MaternalHealth"> | Date | string
    tetanusToxoidStatus?: StringNullableWithAggregatesFilter<"MaternalHealth"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaternalHealth"> | Date | string
  }

  export type PrenatalVisitWhereInput = {
    AND?: PrenatalVisitWhereInput | PrenatalVisitWhereInput[]
    OR?: PrenatalVisitWhereInput[]
    NOT?: PrenatalVisitWhereInput | PrenatalVisitWhereInput[]
    id?: StringFilter<"PrenatalVisit"> | string
    maternalHealthId?: StringFilter<"PrenatalVisit"> | string
    visitDate?: DateTimeFilter<"PrenatalVisit"> | Date | string
    gestationalAgeWeeks?: IntFilter<"PrenatalVisit"> | number
    weightKg?: FloatFilter<"PrenatalVisit"> | number
    heightCm?: FloatFilter<"PrenatalVisit"> | number
    bloodPressure?: StringFilter<"PrenatalVisit"> | string
    fundalHeightCm?: FloatFilter<"PrenatalVisit"> | number
    fetalHeartTone?: StringFilter<"PrenatalVisit"> | string
    nextVisitDate?: DateTimeNullableFilter<"PrenatalVisit"> | Date | string | null
    recordedBy?: StringFilter<"PrenatalVisit"> | string
    maternalHealth?: XOR<MaternalHealthScalarRelationFilter, MaternalHealthWhereInput>
    laboratoryTests?: LaboratoryTestListRelationFilter
    interventions?: InterventionListRelationFilter
  }

  export type PrenatalVisitOrderByWithRelationInput = {
    id?: SortOrder
    maternalHealthId?: SortOrder
    visitDate?: SortOrder
    gestationalAgeWeeks?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bloodPressure?: SortOrder
    fundalHeightCm?: SortOrder
    fetalHeartTone?: SortOrder
    nextVisitDate?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    maternalHealth?: MaternalHealthOrderByWithRelationInput
    laboratoryTests?: LaboratoryTestOrderByRelationAggregateInput
    interventions?: InterventionOrderByRelationAggregateInput
    _relevance?: PrenatalVisitOrderByRelevanceInput
  }

  export type PrenatalVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrenatalVisitWhereInput | PrenatalVisitWhereInput[]
    OR?: PrenatalVisitWhereInput[]
    NOT?: PrenatalVisitWhereInput | PrenatalVisitWhereInput[]
    maternalHealthId?: StringFilter<"PrenatalVisit"> | string
    visitDate?: DateTimeFilter<"PrenatalVisit"> | Date | string
    gestationalAgeWeeks?: IntFilter<"PrenatalVisit"> | number
    weightKg?: FloatFilter<"PrenatalVisit"> | number
    heightCm?: FloatFilter<"PrenatalVisit"> | number
    bloodPressure?: StringFilter<"PrenatalVisit"> | string
    fundalHeightCm?: FloatFilter<"PrenatalVisit"> | number
    fetalHeartTone?: StringFilter<"PrenatalVisit"> | string
    nextVisitDate?: DateTimeNullableFilter<"PrenatalVisit"> | Date | string | null
    recordedBy?: StringFilter<"PrenatalVisit"> | string
    maternalHealth?: XOR<MaternalHealthScalarRelationFilter, MaternalHealthWhereInput>
    laboratoryTests?: LaboratoryTestListRelationFilter
    interventions?: InterventionListRelationFilter
  }, "id">

  export type PrenatalVisitOrderByWithAggregationInput = {
    id?: SortOrder
    maternalHealthId?: SortOrder
    visitDate?: SortOrder
    gestationalAgeWeeks?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bloodPressure?: SortOrder
    fundalHeightCm?: SortOrder
    fetalHeartTone?: SortOrder
    nextVisitDate?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    _count?: PrenatalVisitCountOrderByAggregateInput
    _avg?: PrenatalVisitAvgOrderByAggregateInput
    _max?: PrenatalVisitMaxOrderByAggregateInput
    _min?: PrenatalVisitMinOrderByAggregateInput
    _sum?: PrenatalVisitSumOrderByAggregateInput
  }

  export type PrenatalVisitScalarWhereWithAggregatesInput = {
    AND?: PrenatalVisitScalarWhereWithAggregatesInput | PrenatalVisitScalarWhereWithAggregatesInput[]
    OR?: PrenatalVisitScalarWhereWithAggregatesInput[]
    NOT?: PrenatalVisitScalarWhereWithAggregatesInput | PrenatalVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrenatalVisit"> | string
    maternalHealthId?: StringWithAggregatesFilter<"PrenatalVisit"> | string
    visitDate?: DateTimeWithAggregatesFilter<"PrenatalVisit"> | Date | string
    gestationalAgeWeeks?: IntWithAggregatesFilter<"PrenatalVisit"> | number
    weightKg?: FloatWithAggregatesFilter<"PrenatalVisit"> | number
    heightCm?: FloatWithAggregatesFilter<"PrenatalVisit"> | number
    bloodPressure?: StringWithAggregatesFilter<"PrenatalVisit"> | string
    fundalHeightCm?: FloatWithAggregatesFilter<"PrenatalVisit"> | number
    fetalHeartTone?: StringWithAggregatesFilter<"PrenatalVisit"> | string
    nextVisitDate?: DateTimeNullableWithAggregatesFilter<"PrenatalVisit"> | Date | string | null
    recordedBy?: StringWithAggregatesFilter<"PrenatalVisit"> | string
  }

  export type LaboratoryTestWhereInput = {
    AND?: LaboratoryTestWhereInput | LaboratoryTestWhereInput[]
    OR?: LaboratoryTestWhereInput[]
    NOT?: LaboratoryTestWhereInput | LaboratoryTestWhereInput[]
    id?: StringFilter<"LaboratoryTest"> | string
    prenatalVisitId?: StringFilter<"LaboratoryTest"> | string
    userProfileId?: StringFilter<"LaboratoryTest"> | string
    testDate?: DateTimeFilter<"LaboratoryTest"> | Date | string
    testType?: StringFilter<"LaboratoryTest"> | string
    testCompleted?: BoolFilter<"LaboratoryTest"> | boolean
    recordedBy?: StringFilter<"LaboratoryTest"> | string
    prenatalVisit?: XOR<PrenatalVisitScalarRelationFilter, PrenatalVisitWhereInput>
  }

  export type LaboratoryTestOrderByWithRelationInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    userProfileId?: SortOrder
    testDate?: SortOrder
    testType?: SortOrder
    testCompleted?: SortOrder
    recordedBy?: SortOrder
    prenatalVisit?: PrenatalVisitOrderByWithRelationInput
    _relevance?: LaboratoryTestOrderByRelevanceInput
  }

  export type LaboratoryTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaboratoryTestWhereInput | LaboratoryTestWhereInput[]
    OR?: LaboratoryTestWhereInput[]
    NOT?: LaboratoryTestWhereInput | LaboratoryTestWhereInput[]
    prenatalVisitId?: StringFilter<"LaboratoryTest"> | string
    userProfileId?: StringFilter<"LaboratoryTest"> | string
    testDate?: DateTimeFilter<"LaboratoryTest"> | Date | string
    testType?: StringFilter<"LaboratoryTest"> | string
    testCompleted?: BoolFilter<"LaboratoryTest"> | boolean
    recordedBy?: StringFilter<"LaboratoryTest"> | string
    prenatalVisit?: XOR<PrenatalVisitScalarRelationFilter, PrenatalVisitWhereInput>
  }, "id">

  export type LaboratoryTestOrderByWithAggregationInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    userProfileId?: SortOrder
    testDate?: SortOrder
    testType?: SortOrder
    testCompleted?: SortOrder
    recordedBy?: SortOrder
    _count?: LaboratoryTestCountOrderByAggregateInput
    _max?: LaboratoryTestMaxOrderByAggregateInput
    _min?: LaboratoryTestMinOrderByAggregateInput
  }

  export type LaboratoryTestScalarWhereWithAggregatesInput = {
    AND?: LaboratoryTestScalarWhereWithAggregatesInput | LaboratoryTestScalarWhereWithAggregatesInput[]
    OR?: LaboratoryTestScalarWhereWithAggregatesInput[]
    NOT?: LaboratoryTestScalarWhereWithAggregatesInput | LaboratoryTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LaboratoryTest"> | string
    prenatalVisitId?: StringWithAggregatesFilter<"LaboratoryTest"> | string
    userProfileId?: StringWithAggregatesFilter<"LaboratoryTest"> | string
    testDate?: DateTimeWithAggregatesFilter<"LaboratoryTest"> | Date | string
    testType?: StringWithAggregatesFilter<"LaboratoryTest"> | string
    testCompleted?: BoolWithAggregatesFilter<"LaboratoryTest"> | boolean
    recordedBy?: StringWithAggregatesFilter<"LaboratoryTest"> | string
  }

  export type InterventionWhereInput = {
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    id?: StringFilter<"Intervention"> | string
    prenatalVisitId?: StringFilter<"Intervention"> | string
    tetanusToxoidDose?: StringNullableFilter<"Intervention"> | string | null
    tetanusToxoidLocation?: StringNullableFilter<"Intervention"> | string | null
    tetanusToxoidDate?: DateTimeNullableFilter<"Intervention"> | Date | string | null
    ironSupplementation?: BoolFilter<"Intervention"> | boolean
    ironMedication?: StringNullableFilter<"Intervention"> | string | null
    vitaminSupplementation?: BoolFilter<"Intervention"> | boolean
    vitaminMedication?: StringNullableFilter<"Intervention"> | string | null
    calciumSupplementation?: BoolFilter<"Intervention"> | boolean
    calciumMedication?: StringNullableFilter<"Intervention"> | string | null
    healthEducationTopics?: JsonFilter<"Intervention">
    prenatalVisit?: XOR<PrenatalVisitScalarRelationFilter, PrenatalVisitWhereInput>
  }

  export type InterventionOrderByWithRelationInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    tetanusToxoidDose?: SortOrderInput | SortOrder
    tetanusToxoidLocation?: SortOrderInput | SortOrder
    tetanusToxoidDate?: SortOrderInput | SortOrder
    ironSupplementation?: SortOrder
    ironMedication?: SortOrderInput | SortOrder
    vitaminSupplementation?: SortOrder
    vitaminMedication?: SortOrderInput | SortOrder
    calciumSupplementation?: SortOrder
    calciumMedication?: SortOrderInput | SortOrder
    healthEducationTopics?: SortOrder
    prenatalVisit?: PrenatalVisitOrderByWithRelationInput
    _relevance?: InterventionOrderByRelevanceInput
  }

  export type InterventionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterventionWhereInput | InterventionWhereInput[]
    OR?: InterventionWhereInput[]
    NOT?: InterventionWhereInput | InterventionWhereInput[]
    prenatalVisitId?: StringFilter<"Intervention"> | string
    tetanusToxoidDose?: StringNullableFilter<"Intervention"> | string | null
    tetanusToxoidLocation?: StringNullableFilter<"Intervention"> | string | null
    tetanusToxoidDate?: DateTimeNullableFilter<"Intervention"> | Date | string | null
    ironSupplementation?: BoolFilter<"Intervention"> | boolean
    ironMedication?: StringNullableFilter<"Intervention"> | string | null
    vitaminSupplementation?: BoolFilter<"Intervention"> | boolean
    vitaminMedication?: StringNullableFilter<"Intervention"> | string | null
    calciumSupplementation?: BoolFilter<"Intervention"> | boolean
    calciumMedication?: StringNullableFilter<"Intervention"> | string | null
    healthEducationTopics?: JsonFilter<"Intervention">
    prenatalVisit?: XOR<PrenatalVisitScalarRelationFilter, PrenatalVisitWhereInput>
  }, "id">

  export type InterventionOrderByWithAggregationInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    tetanusToxoidDose?: SortOrderInput | SortOrder
    tetanusToxoidLocation?: SortOrderInput | SortOrder
    tetanusToxoidDate?: SortOrderInput | SortOrder
    ironSupplementation?: SortOrder
    ironMedication?: SortOrderInput | SortOrder
    vitaminSupplementation?: SortOrder
    vitaminMedication?: SortOrderInput | SortOrder
    calciumSupplementation?: SortOrder
    calciumMedication?: SortOrderInput | SortOrder
    healthEducationTopics?: SortOrder
    _count?: InterventionCountOrderByAggregateInput
    _max?: InterventionMaxOrderByAggregateInput
    _min?: InterventionMinOrderByAggregateInput
  }

  export type InterventionScalarWhereWithAggregatesInput = {
    AND?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    OR?: InterventionScalarWhereWithAggregatesInput[]
    NOT?: InterventionScalarWhereWithAggregatesInput | InterventionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Intervention"> | string
    prenatalVisitId?: StringWithAggregatesFilter<"Intervention"> | string
    tetanusToxoidDose?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    tetanusToxoidLocation?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    tetanusToxoidDate?: DateTimeNullableWithAggregatesFilter<"Intervention"> | Date | string | null
    ironSupplementation?: BoolWithAggregatesFilter<"Intervention"> | boolean
    ironMedication?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    vitaminSupplementation?: BoolWithAggregatesFilter<"Intervention"> | boolean
    vitaminMedication?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    calciumSupplementation?: BoolWithAggregatesFilter<"Intervention"> | boolean
    calciumMedication?: StringNullableWithAggregatesFilter<"Intervention"> | string | null
    healthEducationTopics?: JsonWithAggregatesFilter<"Intervention">
  }

  export type BirthInformationWhereInput = {
    AND?: BirthInformationWhereInput | BirthInformationWhereInput[]
    OR?: BirthInformationWhereInput[]
    NOT?: BirthInformationWhereInput | BirthInformationWhereInput[]
    id?: StringFilter<"BirthInformation"> | string
    userProfileId?: StringFilter<"BirthInformation"> | string
    maternalHealthId?: StringFilter<"BirthInformation"> | string
    placeOfDelivery?: StringFilter<"BirthInformation"> | string
    timeOfDelivery?: StringFilter<"BirthInformation"> | string
    deliveryType?: StringFilter<"BirthInformation"> | string
    birthWeightKg?: FloatFilter<"BirthInformation"> | number
    birthHeightCm?: FloatFilter<"BirthInformation"> | number
    newbornScreeningDate?: DateTimeNullableFilter<"BirthInformation"> | Date | string | null
    newbornScreeningCompleted?: BoolFilter<"BirthInformation"> | boolean
    feedingType?: StringFilter<"BirthInformation"> | string
    createdAt?: DateTimeFilter<"BirthInformation"> | Date | string
    recordedBy?: StringFilter<"BirthInformation"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    maternalHealth?: XOR<MaternalHealthScalarRelationFilter, MaternalHealthWhereInput>
  }

  export type BirthInformationOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    maternalHealthId?: SortOrder
    placeOfDelivery?: SortOrder
    timeOfDelivery?: SortOrder
    deliveryType?: SortOrder
    birthWeightKg?: SortOrder
    birthHeightCm?: SortOrder
    newbornScreeningDate?: SortOrderInput | SortOrder
    newbornScreeningCompleted?: SortOrder
    feedingType?: SortOrder
    createdAt?: SortOrder
    recordedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    maternalHealth?: MaternalHealthOrderByWithRelationInput
    _relevance?: BirthInformationOrderByRelevanceInput
  }

  export type BirthInformationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BirthInformationWhereInput | BirthInformationWhereInput[]
    OR?: BirthInformationWhereInput[]
    NOT?: BirthInformationWhereInput | BirthInformationWhereInput[]
    userProfileId?: StringFilter<"BirthInformation"> | string
    maternalHealthId?: StringFilter<"BirthInformation"> | string
    placeOfDelivery?: StringFilter<"BirthInformation"> | string
    timeOfDelivery?: StringFilter<"BirthInformation"> | string
    deliveryType?: StringFilter<"BirthInformation"> | string
    birthWeightKg?: FloatFilter<"BirthInformation"> | number
    birthHeightCm?: FloatFilter<"BirthInformation"> | number
    newbornScreeningDate?: DateTimeNullableFilter<"BirthInformation"> | Date | string | null
    newbornScreeningCompleted?: BoolFilter<"BirthInformation"> | boolean
    feedingType?: StringFilter<"BirthInformation"> | string
    createdAt?: DateTimeFilter<"BirthInformation"> | Date | string
    recordedBy?: StringFilter<"BirthInformation"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    maternalHealth?: XOR<MaternalHealthScalarRelationFilter, MaternalHealthWhereInput>
  }, "id">

  export type BirthInformationOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    maternalHealthId?: SortOrder
    placeOfDelivery?: SortOrder
    timeOfDelivery?: SortOrder
    deliveryType?: SortOrder
    birthWeightKg?: SortOrder
    birthHeightCm?: SortOrder
    newbornScreeningDate?: SortOrderInput | SortOrder
    newbornScreeningCompleted?: SortOrder
    feedingType?: SortOrder
    createdAt?: SortOrder
    recordedBy?: SortOrder
    _count?: BirthInformationCountOrderByAggregateInput
    _avg?: BirthInformationAvgOrderByAggregateInput
    _max?: BirthInformationMaxOrderByAggregateInput
    _min?: BirthInformationMinOrderByAggregateInput
    _sum?: BirthInformationSumOrderByAggregateInput
  }

  export type BirthInformationScalarWhereWithAggregatesInput = {
    AND?: BirthInformationScalarWhereWithAggregatesInput | BirthInformationScalarWhereWithAggregatesInput[]
    OR?: BirthInformationScalarWhereWithAggregatesInput[]
    NOT?: BirthInformationScalarWhereWithAggregatesInput | BirthInformationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BirthInformation"> | string
    userProfileId?: StringWithAggregatesFilter<"BirthInformation"> | string
    maternalHealthId?: StringWithAggregatesFilter<"BirthInformation"> | string
    placeOfDelivery?: StringWithAggregatesFilter<"BirthInformation"> | string
    timeOfDelivery?: StringWithAggregatesFilter<"BirthInformation"> | string
    deliveryType?: StringWithAggregatesFilter<"BirthInformation"> | string
    birthWeightKg?: FloatWithAggregatesFilter<"BirthInformation"> | number
    birthHeightCm?: FloatWithAggregatesFilter<"BirthInformation"> | number
    newbornScreeningDate?: DateTimeNullableWithAggregatesFilter<"BirthInformation"> | Date | string | null
    newbornScreeningCompleted?: BoolWithAggregatesFilter<"BirthInformation"> | boolean
    feedingType?: StringWithAggregatesFilter<"BirthInformation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BirthInformation"> | Date | string
    recordedBy?: StringWithAggregatesFilter<"BirthInformation"> | string
  }

  export type ImmunizationEventWhereInput = {
    AND?: ImmunizationEventWhereInput | ImmunizationEventWhereInput[]
    OR?: ImmunizationEventWhereInput[]
    NOT?: ImmunizationEventWhereInput | ImmunizationEventWhereInput[]
    id?: StringFilter<"ImmunizationEvent"> | string
    userProfileId?: StringFilter<"ImmunizationEvent"> | string
    visitDate?: DateTimeFilter<"ImmunizationEvent"> | Date | string
    temperatureCelsius?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    weightKg?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    heightCm?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    adverseReactions?: StringNullableFilter<"ImmunizationEvent"> | string | null
    healthWorkerName?: StringFilter<"ImmunizationEvent"> | string
    healthWorkerSignature?: StringNullableFilter<"ImmunizationEvent"> | string | null
    nextFollowupDate?: DateTimeNullableFilter<"ImmunizationEvent"> | Date | string | null
    recordedBy?: StringFilter<"ImmunizationEvent"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    vaccinesGiven?: VaccineGivenListRelationFilter
  }

  export type ImmunizationEventOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    temperatureCelsius?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    adverseReactions?: SortOrderInput | SortOrder
    healthWorkerName?: SortOrder
    healthWorkerSignature?: SortOrderInput | SortOrder
    nextFollowupDate?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    vaccinesGiven?: VaccineGivenOrderByRelationAggregateInput
    _relevance?: ImmunizationEventOrderByRelevanceInput
  }

  export type ImmunizationEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImmunizationEventWhereInput | ImmunizationEventWhereInput[]
    OR?: ImmunizationEventWhereInput[]
    NOT?: ImmunizationEventWhereInput | ImmunizationEventWhereInput[]
    userProfileId?: StringFilter<"ImmunizationEvent"> | string
    visitDate?: DateTimeFilter<"ImmunizationEvent"> | Date | string
    temperatureCelsius?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    weightKg?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    heightCm?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    adverseReactions?: StringNullableFilter<"ImmunizationEvent"> | string | null
    healthWorkerName?: StringFilter<"ImmunizationEvent"> | string
    healthWorkerSignature?: StringNullableFilter<"ImmunizationEvent"> | string | null
    nextFollowupDate?: DateTimeNullableFilter<"ImmunizationEvent"> | Date | string | null
    recordedBy?: StringFilter<"ImmunizationEvent"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    vaccinesGiven?: VaccineGivenListRelationFilter
  }, "id">

  export type ImmunizationEventOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    temperatureCelsius?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    adverseReactions?: SortOrderInput | SortOrder
    healthWorkerName?: SortOrder
    healthWorkerSignature?: SortOrderInput | SortOrder
    nextFollowupDate?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    _count?: ImmunizationEventCountOrderByAggregateInput
    _avg?: ImmunizationEventAvgOrderByAggregateInput
    _max?: ImmunizationEventMaxOrderByAggregateInput
    _min?: ImmunizationEventMinOrderByAggregateInput
    _sum?: ImmunizationEventSumOrderByAggregateInput
  }

  export type ImmunizationEventScalarWhereWithAggregatesInput = {
    AND?: ImmunizationEventScalarWhereWithAggregatesInput | ImmunizationEventScalarWhereWithAggregatesInput[]
    OR?: ImmunizationEventScalarWhereWithAggregatesInput[]
    NOT?: ImmunizationEventScalarWhereWithAggregatesInput | ImmunizationEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImmunizationEvent"> | string
    userProfileId?: StringWithAggregatesFilter<"ImmunizationEvent"> | string
    visitDate?: DateTimeWithAggregatesFilter<"ImmunizationEvent"> | Date | string
    temperatureCelsius?: FloatNullableWithAggregatesFilter<"ImmunizationEvent"> | number | null
    weightKg?: FloatNullableWithAggregatesFilter<"ImmunizationEvent"> | number | null
    heightCm?: FloatNullableWithAggregatesFilter<"ImmunizationEvent"> | number | null
    adverseReactions?: StringNullableWithAggregatesFilter<"ImmunizationEvent"> | string | null
    healthWorkerName?: StringWithAggregatesFilter<"ImmunizationEvent"> | string
    healthWorkerSignature?: StringNullableWithAggregatesFilter<"ImmunizationEvent"> | string | null
    nextFollowupDate?: DateTimeNullableWithAggregatesFilter<"ImmunizationEvent"> | Date | string | null
    recordedBy?: StringWithAggregatesFilter<"ImmunizationEvent"> | string
  }

  export type VaccineGivenWhereInput = {
    AND?: VaccineGivenWhereInput | VaccineGivenWhereInput[]
    OR?: VaccineGivenWhereInput[]
    NOT?: VaccineGivenWhereInput | VaccineGivenWhereInput[]
    id?: StringFilter<"VaccineGiven"> | string
    immunizationEventId?: StringFilter<"VaccineGiven"> | string
    vaccineName?: StringFilter<"VaccineGiven"> | string
    doseNumber?: StringFilter<"VaccineGiven"> | string
    dateGiven?: DateTimeFilter<"VaccineGiven"> | Date | string
    lotNumber?: StringNullableFilter<"VaccineGiven"> | string | null
    immunizationEvent?: XOR<ImmunizationEventScalarRelationFilter, ImmunizationEventWhereInput>
  }

  export type VaccineGivenOrderByWithRelationInput = {
    id?: SortOrder
    immunizationEventId?: SortOrder
    vaccineName?: SortOrder
    doseNumber?: SortOrder
    dateGiven?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    immunizationEvent?: ImmunizationEventOrderByWithRelationInput
    _relevance?: VaccineGivenOrderByRelevanceInput
  }

  export type VaccineGivenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VaccineGivenWhereInput | VaccineGivenWhereInput[]
    OR?: VaccineGivenWhereInput[]
    NOT?: VaccineGivenWhereInput | VaccineGivenWhereInput[]
    immunizationEventId?: StringFilter<"VaccineGiven"> | string
    vaccineName?: StringFilter<"VaccineGiven"> | string
    doseNumber?: StringFilter<"VaccineGiven"> | string
    dateGiven?: DateTimeFilter<"VaccineGiven"> | Date | string
    lotNumber?: StringNullableFilter<"VaccineGiven"> | string | null
    immunizationEvent?: XOR<ImmunizationEventScalarRelationFilter, ImmunizationEventWhereInput>
  }, "id">

  export type VaccineGivenOrderByWithAggregationInput = {
    id?: SortOrder
    immunizationEventId?: SortOrder
    vaccineName?: SortOrder
    doseNumber?: SortOrder
    dateGiven?: SortOrder
    lotNumber?: SortOrderInput | SortOrder
    _count?: VaccineGivenCountOrderByAggregateInput
    _max?: VaccineGivenMaxOrderByAggregateInput
    _min?: VaccineGivenMinOrderByAggregateInput
  }

  export type VaccineGivenScalarWhereWithAggregatesInput = {
    AND?: VaccineGivenScalarWhereWithAggregatesInput | VaccineGivenScalarWhereWithAggregatesInput[]
    OR?: VaccineGivenScalarWhereWithAggregatesInput[]
    NOT?: VaccineGivenScalarWhereWithAggregatesInput | VaccineGivenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VaccineGiven"> | string
    immunizationEventId?: StringWithAggregatesFilter<"VaccineGiven"> | string
    vaccineName?: StringWithAggregatesFilter<"VaccineGiven"> | string
    doseNumber?: StringWithAggregatesFilter<"VaccineGiven"> | string
    dateGiven?: DateTimeWithAggregatesFilter<"VaccineGiven"> | Date | string
    lotNumber?: StringNullableWithAggregatesFilter<"VaccineGiven"> | string | null
  }

  export type VitalSignsWhereInput = {
    AND?: VitalSignsWhereInput | VitalSignsWhereInput[]
    OR?: VitalSignsWhereInput[]
    NOT?: VitalSignsWhereInput | VitalSignsWhereInput[]
    id?: StringFilter<"VitalSigns"> | string
    userProfileId?: StringFilter<"VitalSigns"> | string
    recordDate?: DateTimeFilter<"VitalSigns"> | Date | string
    bloodPressure?: StringNullableFilter<"VitalSigns"> | string | null
    heartRate?: IntNullableFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    temperatureCelsius?: FloatNullableFilter<"VitalSigns"> | number | null
    pulseRate?: IntNullableFilter<"VitalSigns"> | number | null
    recordedBy?: StringFilter<"VitalSigns"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type VitalSignsOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recordDate?: SortOrder
    bloodPressure?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    temperatureCelsius?: SortOrderInput | SortOrder
    pulseRate?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: VitalSignsOrderByRelevanceInput
  }

  export type VitalSignsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VitalSignsWhereInput | VitalSignsWhereInput[]
    OR?: VitalSignsWhereInput[]
    NOT?: VitalSignsWhereInput | VitalSignsWhereInput[]
    userProfileId?: StringFilter<"VitalSigns"> | string
    recordDate?: DateTimeFilter<"VitalSigns"> | Date | string
    bloodPressure?: StringNullableFilter<"VitalSigns"> | string | null
    heartRate?: IntNullableFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    temperatureCelsius?: FloatNullableFilter<"VitalSigns"> | number | null
    pulseRate?: IntNullableFilter<"VitalSigns"> | number | null
    recordedBy?: StringFilter<"VitalSigns"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type VitalSignsOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recordDate?: SortOrder
    bloodPressure?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    respiratoryRate?: SortOrderInput | SortOrder
    temperatureCelsius?: SortOrderInput | SortOrder
    pulseRate?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    _count?: VitalSignsCountOrderByAggregateInput
    _avg?: VitalSignsAvgOrderByAggregateInput
    _max?: VitalSignsMaxOrderByAggregateInput
    _min?: VitalSignsMinOrderByAggregateInput
    _sum?: VitalSignsSumOrderByAggregateInput
  }

  export type VitalSignsScalarWhereWithAggregatesInput = {
    AND?: VitalSignsScalarWhereWithAggregatesInput | VitalSignsScalarWhereWithAggregatesInput[]
    OR?: VitalSignsScalarWhereWithAggregatesInput[]
    NOT?: VitalSignsScalarWhereWithAggregatesInput | VitalSignsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VitalSigns"> | string
    userProfileId?: StringWithAggregatesFilter<"VitalSigns"> | string
    recordDate?: DateTimeWithAggregatesFilter<"VitalSigns"> | Date | string
    bloodPressure?: StringNullableWithAggregatesFilter<"VitalSigns"> | string | null
    heartRate?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    temperatureCelsius?: FloatNullableWithAggregatesFilter<"VitalSigns"> | number | null
    pulseRate?: IntNullableWithAggregatesFilter<"VitalSigns"> | number | null
    recordedBy?: StringWithAggregatesFilter<"VitalSigns"> | string
  }

  export type AnthropometricMeasurementWhereInput = {
    AND?: AnthropometricMeasurementWhereInput | AnthropometricMeasurementWhereInput[]
    OR?: AnthropometricMeasurementWhereInput[]
    NOT?: AnthropometricMeasurementWhereInput | AnthropometricMeasurementWhereInput[]
    id?: StringFilter<"AnthropometricMeasurement"> | string
    userProfileId?: StringFilter<"AnthropometricMeasurement"> | string
    measurementDate?: DateTimeFilter<"AnthropometricMeasurement"> | Date | string
    weightKg?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    heightCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    headCircumferenceCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    waistCircumferenceCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    bmi?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    recordedBy?: StringFilter<"AnthropometricMeasurement"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type AnthropometricMeasurementOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    measurementDate?: SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    headCircumferenceCm?: SortOrderInput | SortOrder
    waistCircumferenceCm?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: AnthropometricMeasurementOrderByRelevanceInput
  }

  export type AnthropometricMeasurementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnthropometricMeasurementWhereInput | AnthropometricMeasurementWhereInput[]
    OR?: AnthropometricMeasurementWhereInput[]
    NOT?: AnthropometricMeasurementWhereInput | AnthropometricMeasurementWhereInput[]
    userProfileId?: StringFilter<"AnthropometricMeasurement"> | string
    measurementDate?: DateTimeFilter<"AnthropometricMeasurement"> | Date | string
    weightKg?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    heightCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    headCircumferenceCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    waistCircumferenceCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    bmi?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    recordedBy?: StringFilter<"AnthropometricMeasurement"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type AnthropometricMeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    measurementDate?: SortOrder
    weightKg?: SortOrderInput | SortOrder
    heightCm?: SortOrderInput | SortOrder
    headCircumferenceCm?: SortOrderInput | SortOrder
    waistCircumferenceCm?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    _count?: AnthropometricMeasurementCountOrderByAggregateInput
    _avg?: AnthropometricMeasurementAvgOrderByAggregateInput
    _max?: AnthropometricMeasurementMaxOrderByAggregateInput
    _min?: AnthropometricMeasurementMinOrderByAggregateInput
    _sum?: AnthropometricMeasurementSumOrderByAggregateInput
  }

  export type AnthropometricMeasurementScalarWhereWithAggregatesInput = {
    AND?: AnthropometricMeasurementScalarWhereWithAggregatesInput | AnthropometricMeasurementScalarWhereWithAggregatesInput[]
    OR?: AnthropometricMeasurementScalarWhereWithAggregatesInput[]
    NOT?: AnthropometricMeasurementScalarWhereWithAggregatesInput | AnthropometricMeasurementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnthropometricMeasurement"> | string
    userProfileId?: StringWithAggregatesFilter<"AnthropometricMeasurement"> | string
    measurementDate?: DateTimeWithAggregatesFilter<"AnthropometricMeasurement"> | Date | string
    weightKg?: FloatNullableWithAggregatesFilter<"AnthropometricMeasurement"> | number | null
    heightCm?: FloatNullableWithAggregatesFilter<"AnthropometricMeasurement"> | number | null
    headCircumferenceCm?: FloatNullableWithAggregatesFilter<"AnthropometricMeasurement"> | number | null
    waistCircumferenceCm?: FloatNullableWithAggregatesFilter<"AnthropometricMeasurement"> | number | null
    bmi?: FloatNullableWithAggregatesFilter<"AnthropometricMeasurement"> | number | null
    recordedBy?: StringWithAggregatesFilter<"AnthropometricMeasurement"> | string
  }

  export type GrowthTrackingWhereInput = {
    AND?: GrowthTrackingWhereInput | GrowthTrackingWhereInput[]
    OR?: GrowthTrackingWhereInput[]
    NOT?: GrowthTrackingWhereInput | GrowthTrackingWhereInput[]
    id?: StringFilter<"GrowthTracking"> | string
    userProfileId?: StringFilter<"GrowthTracking"> | string
    trackingDate?: DateTimeFilter<"GrowthTracking"> | Date | string
    weightForAge?: StringNullableFilter<"GrowthTracking"> | string | null
    heightForAge?: StringNullableFilter<"GrowthTracking"> | string | null
    weightForHeight?: StringNullableFilter<"GrowthTracking"> | string | null
    recordedBy?: StringFilter<"GrowthTracking"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type GrowthTrackingOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    trackingDate?: SortOrder
    weightForAge?: SortOrderInput | SortOrder
    heightForAge?: SortOrderInput | SortOrder
    weightForHeight?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: GrowthTrackingOrderByRelevanceInput
  }

  export type GrowthTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GrowthTrackingWhereInput | GrowthTrackingWhereInput[]
    OR?: GrowthTrackingWhereInput[]
    NOT?: GrowthTrackingWhereInput | GrowthTrackingWhereInput[]
    userProfileId?: StringFilter<"GrowthTracking"> | string
    trackingDate?: DateTimeFilter<"GrowthTracking"> | Date | string
    weightForAge?: StringNullableFilter<"GrowthTracking"> | string | null
    heightForAge?: StringNullableFilter<"GrowthTracking"> | string | null
    weightForHeight?: StringNullableFilter<"GrowthTracking"> | string | null
    recordedBy?: StringFilter<"GrowthTracking"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type GrowthTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    trackingDate?: SortOrder
    weightForAge?: SortOrderInput | SortOrder
    heightForAge?: SortOrderInput | SortOrder
    weightForHeight?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    _count?: GrowthTrackingCountOrderByAggregateInput
    _max?: GrowthTrackingMaxOrderByAggregateInput
    _min?: GrowthTrackingMinOrderByAggregateInput
  }

  export type GrowthTrackingScalarWhereWithAggregatesInput = {
    AND?: GrowthTrackingScalarWhereWithAggregatesInput | GrowthTrackingScalarWhereWithAggregatesInput[]
    OR?: GrowthTrackingScalarWhereWithAggregatesInput[]
    NOT?: GrowthTrackingScalarWhereWithAggregatesInput | GrowthTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GrowthTracking"> | string
    userProfileId?: StringWithAggregatesFilter<"GrowthTracking"> | string
    trackingDate?: DateTimeWithAggregatesFilter<"GrowthTracking"> | Date | string
    weightForAge?: StringNullableWithAggregatesFilter<"GrowthTracking"> | string | null
    heightForAge?: StringNullableWithAggregatesFilter<"GrowthTracking"> | string | null
    weightForHeight?: StringNullableWithAggregatesFilter<"GrowthTracking"> | string | null
    recordedBy?: StringWithAggregatesFilter<"GrowthTracking"> | string
  }

  export type NCDRiskAssessmentWhereInput = {
    AND?: NCDRiskAssessmentWhereInput | NCDRiskAssessmentWhereInput[]
    OR?: NCDRiskAssessmentWhereInput[]
    NOT?: NCDRiskAssessmentWhereInput | NCDRiskAssessmentWhereInput[]
    id?: StringFilter<"NCDRiskAssessment"> | string
    userProfileId?: StringFilter<"NCDRiskAssessment"> | string
    assessmentDate?: DateTimeFilter<"NCDRiskAssessment"> | Date | string
    smokingStatus?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    alcoholIntake?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    physicalActivity?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    fruitVegetableIntake?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    familyHistoryDiabetes?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHypertension?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHeartDisease?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryStroke?: BoolFilter<"NCDRiskAssessment"> | boolean
    screeningCompleted?: BoolFilter<"NCDRiskAssessment"> | boolean
    followUpNeeded?: BoolFilter<"NCDRiskAssessment"> | boolean
    lifestyleModifications?: JsonFilter<"NCDRiskAssessment">
    healthEducationReceived?: JsonFilter<"NCDRiskAssessment">
    recordedBy?: StringFilter<"NCDRiskAssessment"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type NCDRiskAssessmentOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    assessmentDate?: SortOrder
    smokingStatus?: SortOrderInput | SortOrder
    alcoholIntake?: SortOrderInput | SortOrder
    physicalActivity?: SortOrderInput | SortOrder
    fruitVegetableIntake?: SortOrderInput | SortOrder
    familyHistoryDiabetes?: SortOrder
    familyHistoryHypertension?: SortOrder
    familyHistoryHeartDisease?: SortOrder
    familyHistoryStroke?: SortOrder
    screeningCompleted?: SortOrder
    followUpNeeded?: SortOrder
    lifestyleModifications?: SortOrder
    healthEducationReceived?: SortOrder
    recordedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: NCDRiskAssessmentOrderByRelevanceInput
  }

  export type NCDRiskAssessmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NCDRiskAssessmentWhereInput | NCDRiskAssessmentWhereInput[]
    OR?: NCDRiskAssessmentWhereInput[]
    NOT?: NCDRiskAssessmentWhereInput | NCDRiskAssessmentWhereInput[]
    userProfileId?: StringFilter<"NCDRiskAssessment"> | string
    assessmentDate?: DateTimeFilter<"NCDRiskAssessment"> | Date | string
    smokingStatus?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    alcoholIntake?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    physicalActivity?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    fruitVegetableIntake?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    familyHistoryDiabetes?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHypertension?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHeartDisease?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryStroke?: BoolFilter<"NCDRiskAssessment"> | boolean
    screeningCompleted?: BoolFilter<"NCDRiskAssessment"> | boolean
    followUpNeeded?: BoolFilter<"NCDRiskAssessment"> | boolean
    lifestyleModifications?: JsonFilter<"NCDRiskAssessment">
    healthEducationReceived?: JsonFilter<"NCDRiskAssessment">
    recordedBy?: StringFilter<"NCDRiskAssessment"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type NCDRiskAssessmentOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    assessmentDate?: SortOrder
    smokingStatus?: SortOrderInput | SortOrder
    alcoholIntake?: SortOrderInput | SortOrder
    physicalActivity?: SortOrderInput | SortOrder
    fruitVegetableIntake?: SortOrderInput | SortOrder
    familyHistoryDiabetes?: SortOrder
    familyHistoryHypertension?: SortOrder
    familyHistoryHeartDisease?: SortOrder
    familyHistoryStroke?: SortOrder
    screeningCompleted?: SortOrder
    followUpNeeded?: SortOrder
    lifestyleModifications?: SortOrder
    healthEducationReceived?: SortOrder
    recordedBy?: SortOrder
    _count?: NCDRiskAssessmentCountOrderByAggregateInput
    _max?: NCDRiskAssessmentMaxOrderByAggregateInput
    _min?: NCDRiskAssessmentMinOrderByAggregateInput
  }

  export type NCDRiskAssessmentScalarWhereWithAggregatesInput = {
    AND?: NCDRiskAssessmentScalarWhereWithAggregatesInput | NCDRiskAssessmentScalarWhereWithAggregatesInput[]
    OR?: NCDRiskAssessmentScalarWhereWithAggregatesInput[]
    NOT?: NCDRiskAssessmentScalarWhereWithAggregatesInput | NCDRiskAssessmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NCDRiskAssessment"> | string
    userProfileId?: StringWithAggregatesFilter<"NCDRiskAssessment"> | string
    assessmentDate?: DateTimeWithAggregatesFilter<"NCDRiskAssessment"> | Date | string
    smokingStatus?: StringNullableWithAggregatesFilter<"NCDRiskAssessment"> | string | null
    alcoholIntake?: StringNullableWithAggregatesFilter<"NCDRiskAssessment"> | string | null
    physicalActivity?: StringNullableWithAggregatesFilter<"NCDRiskAssessment"> | string | null
    fruitVegetableIntake?: StringNullableWithAggregatesFilter<"NCDRiskAssessment"> | string | null
    familyHistoryDiabetes?: BoolWithAggregatesFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHypertension?: BoolWithAggregatesFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHeartDisease?: BoolWithAggregatesFilter<"NCDRiskAssessment"> | boolean
    familyHistoryStroke?: BoolWithAggregatesFilter<"NCDRiskAssessment"> | boolean
    screeningCompleted?: BoolWithAggregatesFilter<"NCDRiskAssessment"> | boolean
    followUpNeeded?: BoolWithAggregatesFilter<"NCDRiskAssessment"> | boolean
    lifestyleModifications?: JsonWithAggregatesFilter<"NCDRiskAssessment">
    healthEducationReceived?: JsonWithAggregatesFilter<"NCDRiskAssessment">
    recordedBy?: StringWithAggregatesFilter<"NCDRiskAssessment"> | string
  }

  export type VisitRecordWhereInput = {
    AND?: VisitRecordWhereInput | VisitRecordWhereInput[]
    OR?: VisitRecordWhereInput[]
    NOT?: VisitRecordWhereInput | VisitRecordWhereInput[]
    id?: StringFilter<"VisitRecord"> | string
    userProfileId?: StringFilter<"VisitRecord"> | string
    visitDate?: DateTimeFilter<"VisitRecord"> | Date | string
    visitType?: StringFilter<"VisitRecord"> | string
    visitFrequency?: StringNullableFilter<"VisitRecord"> | string | null
    referred?: BoolFilter<"VisitRecord"> | boolean
    facilityName?: StringNullableFilter<"VisitRecord"> | string | null
    referralReason?: StringNullableFilter<"VisitRecord"> | string | null
    recordedBy?: StringFilter<"VisitRecord"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type VisitRecordOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    visitFrequency?: SortOrderInput | SortOrder
    referred?: SortOrder
    facilityName?: SortOrderInput | SortOrder
    referralReason?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: VisitRecordOrderByRelevanceInput
  }

  export type VisitRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VisitRecordWhereInput | VisitRecordWhereInput[]
    OR?: VisitRecordWhereInput[]
    NOT?: VisitRecordWhereInput | VisitRecordWhereInput[]
    userProfileId?: StringFilter<"VisitRecord"> | string
    visitDate?: DateTimeFilter<"VisitRecord"> | Date | string
    visitType?: StringFilter<"VisitRecord"> | string
    visitFrequency?: StringNullableFilter<"VisitRecord"> | string | null
    referred?: BoolFilter<"VisitRecord"> | boolean
    facilityName?: StringNullableFilter<"VisitRecord"> | string | null
    referralReason?: StringNullableFilter<"VisitRecord"> | string | null
    recordedBy?: StringFilter<"VisitRecord"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type VisitRecordOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    visitFrequency?: SortOrderInput | SortOrder
    referred?: SortOrder
    facilityName?: SortOrderInput | SortOrder
    referralReason?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    _count?: VisitRecordCountOrderByAggregateInput
    _max?: VisitRecordMaxOrderByAggregateInput
    _min?: VisitRecordMinOrderByAggregateInput
  }

  export type VisitRecordScalarWhereWithAggregatesInput = {
    AND?: VisitRecordScalarWhereWithAggregatesInput | VisitRecordScalarWhereWithAggregatesInput[]
    OR?: VisitRecordScalarWhereWithAggregatesInput[]
    NOT?: VisitRecordScalarWhereWithAggregatesInput | VisitRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VisitRecord"> | string
    userProfileId?: StringWithAggregatesFilter<"VisitRecord"> | string
    visitDate?: DateTimeWithAggregatesFilter<"VisitRecord"> | Date | string
    visitType?: StringWithAggregatesFilter<"VisitRecord"> | string
    visitFrequency?: StringNullableWithAggregatesFilter<"VisitRecord"> | string | null
    referred?: BoolWithAggregatesFilter<"VisitRecord"> | boolean
    facilityName?: StringNullableWithAggregatesFilter<"VisitRecord"> | string | null
    referralReason?: StringNullableWithAggregatesFilter<"VisitRecord"> | string | null
    recordedBy?: StringWithAggregatesFilter<"VisitRecord"> | string
  }

  export type HealthEducationWhereInput = {
    AND?: HealthEducationWhereInput | HealthEducationWhereInput[]
    OR?: HealthEducationWhereInput[]
    NOT?: HealthEducationWhereInput | HealthEducationWhereInput[]
    id?: StringFilter<"HealthEducation"> | string
    userProfileId?: StringFilter<"HealthEducation"> | string
    topicsCovered?: JsonFilter<"HealthEducation">
    dateProvided?: DateTimeFilter<"HealthEducation"> | Date | string
    providedBy?: StringFilter<"HealthEducation"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type HealthEducationOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    topicsCovered?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: HealthEducationOrderByRelevanceInput
  }

  export type HealthEducationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthEducationWhereInput | HealthEducationWhereInput[]
    OR?: HealthEducationWhereInput[]
    NOT?: HealthEducationWhereInput | HealthEducationWhereInput[]
    userProfileId?: StringFilter<"HealthEducation"> | string
    topicsCovered?: JsonFilter<"HealthEducation">
    dateProvided?: DateTimeFilter<"HealthEducation"> | Date | string
    providedBy?: StringFilter<"HealthEducation"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type HealthEducationOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    topicsCovered?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
    _count?: HealthEducationCountOrderByAggregateInput
    _max?: HealthEducationMaxOrderByAggregateInput
    _min?: HealthEducationMinOrderByAggregateInput
  }

  export type HealthEducationScalarWhereWithAggregatesInput = {
    AND?: HealthEducationScalarWhereWithAggregatesInput | HealthEducationScalarWhereWithAggregatesInput[]
    OR?: HealthEducationScalarWhereWithAggregatesInput[]
    NOT?: HealthEducationScalarWhereWithAggregatesInput | HealthEducationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthEducation"> | string
    userProfileId?: StringWithAggregatesFilter<"HealthEducation"> | string
    topicsCovered?: JsonWithAggregatesFilter<"HealthEducation">
    dateProvided?: DateTimeWithAggregatesFilter<"HealthEducation"> | Date | string
    providedBy?: StringWithAggregatesFilter<"HealthEducation"> | string
  }

  export type NutritionalCounselingWhereInput = {
    AND?: NutritionalCounselingWhereInput | NutritionalCounselingWhereInput[]
    OR?: NutritionalCounselingWhereInput[]
    NOT?: NutritionalCounselingWhereInput | NutritionalCounselingWhereInput[]
    id?: StringFilter<"NutritionalCounseling"> | string
    userProfileId?: StringFilter<"NutritionalCounseling"> | string
    recommendations?: StringFilter<"NutritionalCounseling"> | string
    dateProvided?: DateTimeFilter<"NutritionalCounseling"> | Date | string
    providedBy?: StringFilter<"NutritionalCounseling"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type NutritionalCounselingOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recommendations?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: NutritionalCounselingOrderByRelevanceInput
  }

  export type NutritionalCounselingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NutritionalCounselingWhereInput | NutritionalCounselingWhereInput[]
    OR?: NutritionalCounselingWhereInput[]
    NOT?: NutritionalCounselingWhereInput | NutritionalCounselingWhereInput[]
    userProfileId?: StringFilter<"NutritionalCounseling"> | string
    recommendations?: StringFilter<"NutritionalCounseling"> | string
    dateProvided?: DateTimeFilter<"NutritionalCounseling"> | Date | string
    providedBy?: StringFilter<"NutritionalCounseling"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type NutritionalCounselingOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recommendations?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
    _count?: NutritionalCounselingCountOrderByAggregateInput
    _max?: NutritionalCounselingMaxOrderByAggregateInput
    _min?: NutritionalCounselingMinOrderByAggregateInput
  }

  export type NutritionalCounselingScalarWhereWithAggregatesInput = {
    AND?: NutritionalCounselingScalarWhereWithAggregatesInput | NutritionalCounselingScalarWhereWithAggregatesInput[]
    OR?: NutritionalCounselingScalarWhereWithAggregatesInput[]
    NOT?: NutritionalCounselingScalarWhereWithAggregatesInput | NutritionalCounselingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NutritionalCounseling"> | string
    userProfileId?: StringWithAggregatesFilter<"NutritionalCounseling"> | string
    recommendations?: StringWithAggregatesFilter<"NutritionalCounseling"> | string
    dateProvided?: DateTimeWithAggregatesFilter<"NutritionalCounseling"> | Date | string
    providedBy?: StringWithAggregatesFilter<"NutritionalCounseling"> | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    userProfileId?: StringFilter<"Referral"> | string
    facilityName?: StringFilter<"Referral"> | string
    reason?: StringFilter<"Referral"> | string
    dateReferred?: DateTimeFilter<"Referral"> | Date | string
    status?: StringFilter<"Referral"> | string
    referredBy?: StringFilter<"Referral"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    facilityName?: SortOrder
    reason?: SortOrder
    dateReferred?: SortOrder
    status?: SortOrder
    referredBy?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: ReferralOrderByRelevanceInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    userProfileId?: StringFilter<"Referral"> | string
    facilityName?: StringFilter<"Referral"> | string
    reason?: StringFilter<"Referral"> | string
    dateReferred?: DateTimeFilter<"Referral"> | Date | string
    status?: StringFilter<"Referral"> | string
    referredBy?: StringFilter<"Referral"> | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    facilityName?: SortOrder
    reason?: SortOrder
    dateReferred?: SortOrder
    status?: SortOrder
    referredBy?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    userProfileId?: StringWithAggregatesFilter<"Referral"> | string
    facilityName?: StringWithAggregatesFilter<"Referral"> | string
    reason?: StringWithAggregatesFilter<"Referral"> | string
    dateReferred?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    status?: StringWithAggregatesFilter<"Referral"> | string
    referredBy?: StringWithAggregatesFilter<"Referral"> | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    userProfileId?: StringFilter<"Appointment"> | string
    nextVisitDate?: DateTimeFilter<"Appointment"> | Date | string
    visitType?: StringFilter<"Appointment"> | string
    appointmentStatus?: StringFilter<"Appointment"> | string
    scheduledBy?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    nextVisitDate?: SortOrder
    visitType?: SortOrder
    appointmentStatus?: SortOrder
    scheduledBy?: SortOrder
    createdAt?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: AppointmentOrderByRelevanceInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    userProfileId?: StringFilter<"Appointment"> | string
    nextVisitDate?: DateTimeFilter<"Appointment"> | Date | string
    visitType?: StringFilter<"Appointment"> | string
    appointmentStatus?: StringFilter<"Appointment"> | string
    scheduledBy?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    nextVisitDate?: SortOrder
    visitType?: SortOrder
    appointmentStatus?: SortOrder
    scheduledBy?: SortOrder
    createdAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    userProfileId?: StringWithAggregatesFilter<"Appointment"> | string
    nextVisitDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    visitType?: StringWithAggregatesFilter<"Appointment"> | string
    appointmentStatus?: StringWithAggregatesFilter<"Appointment"> | string
    scheduledBy?: StringWithAggregatesFilter<"Appointment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type ImmunizationReminderWhereInput = {
    AND?: ImmunizationReminderWhereInput | ImmunizationReminderWhereInput[]
    OR?: ImmunizationReminderWhereInput[]
    NOT?: ImmunizationReminderWhereInput | ImmunizationReminderWhereInput[]
    id?: StringFilter<"ImmunizationReminder"> | string
    userProfileId?: StringFilter<"ImmunizationReminder"> | string
    vaccineName?: StringFilter<"ImmunizationReminder"> | string
    dueDate?: DateTimeFilter<"ImmunizationReminder"> | Date | string
    reminderSent?: BoolFilter<"ImmunizationReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"ImmunizationReminder"> | Date | string | null
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type ImmunizationReminderOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    vaccineName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: ImmunizationReminderOrderByRelevanceInput
  }

  export type ImmunizationReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImmunizationReminderWhereInput | ImmunizationReminderWhereInput[]
    OR?: ImmunizationReminderWhereInput[]
    NOT?: ImmunizationReminderWhereInput | ImmunizationReminderWhereInput[]
    userProfileId?: StringFilter<"ImmunizationReminder"> | string
    vaccineName?: StringFilter<"ImmunizationReminder"> | string
    dueDate?: DateTimeFilter<"ImmunizationReminder"> | Date | string
    reminderSent?: BoolFilter<"ImmunizationReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"ImmunizationReminder"> | Date | string | null
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type ImmunizationReminderOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    vaccineName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    _count?: ImmunizationReminderCountOrderByAggregateInput
    _max?: ImmunizationReminderMaxOrderByAggregateInput
    _min?: ImmunizationReminderMinOrderByAggregateInput
  }

  export type ImmunizationReminderScalarWhereWithAggregatesInput = {
    AND?: ImmunizationReminderScalarWhereWithAggregatesInput | ImmunizationReminderScalarWhereWithAggregatesInput[]
    OR?: ImmunizationReminderScalarWhereWithAggregatesInput[]
    NOT?: ImmunizationReminderScalarWhereWithAggregatesInput | ImmunizationReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImmunizationReminder"> | string
    userProfileId?: StringWithAggregatesFilter<"ImmunizationReminder"> | string
    vaccineName?: StringWithAggregatesFilter<"ImmunizationReminder"> | string
    dueDate?: DateTimeWithAggregatesFilter<"ImmunizationReminder"> | Date | string
    reminderSent?: BoolWithAggregatesFilter<"ImmunizationReminder"> | boolean
    sentAt?: DateTimeNullableWithAggregatesFilter<"ImmunizationReminder"> | Date | string | null
  }

  export type TestReminderWhereInput = {
    AND?: TestReminderWhereInput | TestReminderWhereInput[]
    OR?: TestReminderWhereInput[]
    NOT?: TestReminderWhereInput | TestReminderWhereInput[]
    id?: StringFilter<"TestReminder"> | string
    userProfileId?: StringFilter<"TestReminder"> | string
    testName?: StringFilter<"TestReminder"> | string
    dueDate?: DateTimeFilter<"TestReminder"> | Date | string
    reminderSent?: BoolFilter<"TestReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"TestReminder"> | Date | string | null
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type TestReminderOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    testName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: TestReminderOrderByRelevanceInput
  }

  export type TestReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestReminderWhereInput | TestReminderWhereInput[]
    OR?: TestReminderWhereInput[]
    NOT?: TestReminderWhereInput | TestReminderWhereInput[]
    userProfileId?: StringFilter<"TestReminder"> | string
    testName?: StringFilter<"TestReminder"> | string
    dueDate?: DateTimeFilter<"TestReminder"> | Date | string
    reminderSent?: BoolFilter<"TestReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"TestReminder"> | Date | string | null
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type TestReminderOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    testName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    _count?: TestReminderCountOrderByAggregateInput
    _max?: TestReminderMaxOrderByAggregateInput
    _min?: TestReminderMinOrderByAggregateInput
  }

  export type TestReminderScalarWhereWithAggregatesInput = {
    AND?: TestReminderScalarWhereWithAggregatesInput | TestReminderScalarWhereWithAggregatesInput[]
    OR?: TestReminderScalarWhereWithAggregatesInput[]
    NOT?: TestReminderScalarWhereWithAggregatesInput | TestReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestReminder"> | string
    userProfileId?: StringWithAggregatesFilter<"TestReminder"> | string
    testName?: StringWithAggregatesFilter<"TestReminder"> | string
    dueDate?: DateTimeWithAggregatesFilter<"TestReminder"> | Date | string
    reminderSent?: BoolWithAggregatesFilter<"TestReminder"> | boolean
    sentAt?: DateTimeNullableWithAggregatesFilter<"TestReminder"> | Date | string | null
  }

  export type VirtualCheckupWhereInput = {
    AND?: VirtualCheckupWhereInput | VirtualCheckupWhereInput[]
    OR?: VirtualCheckupWhereInput[]
    NOT?: VirtualCheckupWhereInput | VirtualCheckupWhereInput[]
    id?: StringFilter<"VirtualCheckup"> | string
    userProfileId?: StringFilter<"VirtualCheckup"> | string
    healthWorkerId?: StringFilter<"VirtualCheckup"> | string
    scheduledDate?: DateTimeFilter<"VirtualCheckup"> | Date | string
    scheduledTime?: StringFilter<"VirtualCheckup"> | string
    meetingUrl?: StringNullableFilter<"VirtualCheckup"> | string | null
    status?: StringFilter<"VirtualCheckup"> | string
    consultationType?: StringNullableFilter<"VirtualCheckup"> | string | null
    chiefComplaint?: StringNullableFilter<"VirtualCheckup"> | string | null
    notes?: StringNullableFilter<"VirtualCheckup"> | string | null
    durationMinutes?: IntNullableFilter<"VirtualCheckup"> | number | null
    createdAt?: DateTimeFilter<"VirtualCheckup"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    healthWorker?: XOR<HealthWorkerScalarRelationFilter, HealthWorkerWhereInput>
    virtualCheckupNotes?: VirtualCheckupNoteListRelationFilter
  }

  export type VirtualCheckupOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    healthWorkerId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    consultationType?: SortOrderInput | SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    healthWorker?: HealthWorkerOrderByWithRelationInput
    virtualCheckupNotes?: VirtualCheckupNoteOrderByRelationAggregateInput
    _relevance?: VirtualCheckupOrderByRelevanceInput
  }

  export type VirtualCheckupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VirtualCheckupWhereInput | VirtualCheckupWhereInput[]
    OR?: VirtualCheckupWhereInput[]
    NOT?: VirtualCheckupWhereInput | VirtualCheckupWhereInput[]
    userProfileId?: StringFilter<"VirtualCheckup"> | string
    healthWorkerId?: StringFilter<"VirtualCheckup"> | string
    scheduledDate?: DateTimeFilter<"VirtualCheckup"> | Date | string
    scheduledTime?: StringFilter<"VirtualCheckup"> | string
    meetingUrl?: StringNullableFilter<"VirtualCheckup"> | string | null
    status?: StringFilter<"VirtualCheckup"> | string
    consultationType?: StringNullableFilter<"VirtualCheckup"> | string | null
    chiefComplaint?: StringNullableFilter<"VirtualCheckup"> | string | null
    notes?: StringNullableFilter<"VirtualCheckup"> | string | null
    durationMinutes?: IntNullableFilter<"VirtualCheckup"> | number | null
    createdAt?: DateTimeFilter<"VirtualCheckup"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    healthWorker?: XOR<HealthWorkerScalarRelationFilter, HealthWorkerWhereInput>
    virtualCheckupNotes?: VirtualCheckupNoteListRelationFilter
  }, "id">

  export type VirtualCheckupOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    healthWorkerId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    consultationType?: SortOrderInput | SortOrder
    chiefComplaint?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    durationMinutes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VirtualCheckupCountOrderByAggregateInput
    _avg?: VirtualCheckupAvgOrderByAggregateInput
    _max?: VirtualCheckupMaxOrderByAggregateInput
    _min?: VirtualCheckupMinOrderByAggregateInput
    _sum?: VirtualCheckupSumOrderByAggregateInput
  }

  export type VirtualCheckupScalarWhereWithAggregatesInput = {
    AND?: VirtualCheckupScalarWhereWithAggregatesInput | VirtualCheckupScalarWhereWithAggregatesInput[]
    OR?: VirtualCheckupScalarWhereWithAggregatesInput[]
    NOT?: VirtualCheckupScalarWhereWithAggregatesInput | VirtualCheckupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VirtualCheckup"> | string
    userProfileId?: StringWithAggregatesFilter<"VirtualCheckup"> | string
    healthWorkerId?: StringWithAggregatesFilter<"VirtualCheckup"> | string
    scheduledDate?: DateTimeWithAggregatesFilter<"VirtualCheckup"> | Date | string
    scheduledTime?: StringWithAggregatesFilter<"VirtualCheckup"> | string
    meetingUrl?: StringNullableWithAggregatesFilter<"VirtualCheckup"> | string | null
    status?: StringWithAggregatesFilter<"VirtualCheckup"> | string
    consultationType?: StringNullableWithAggregatesFilter<"VirtualCheckup"> | string | null
    chiefComplaint?: StringNullableWithAggregatesFilter<"VirtualCheckup"> | string | null
    notes?: StringNullableWithAggregatesFilter<"VirtualCheckup"> | string | null
    durationMinutes?: IntNullableWithAggregatesFilter<"VirtualCheckup"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"VirtualCheckup"> | Date | string
  }

  export type VirtualCheckupNoteWhereInput = {
    AND?: VirtualCheckupNoteWhereInput | VirtualCheckupNoteWhereInput[]
    OR?: VirtualCheckupNoteWhereInput[]
    NOT?: VirtualCheckupNoteWhereInput | VirtualCheckupNoteWhereInput[]
    id?: StringFilter<"VirtualCheckupNote"> | string
    virtualCheckupId?: StringFilter<"VirtualCheckupNote"> | string
    note?: StringFilter<"VirtualCheckupNote"> | string
    createdBy?: StringFilter<"VirtualCheckupNote"> | string
    virtualCheckup?: XOR<VirtualCheckupScalarRelationFilter, VirtualCheckupWhereInput>
  }

  export type VirtualCheckupNoteOrderByWithRelationInput = {
    id?: SortOrder
    virtualCheckupId?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    virtualCheckup?: VirtualCheckupOrderByWithRelationInput
    _relevance?: VirtualCheckupNoteOrderByRelevanceInput
  }

  export type VirtualCheckupNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VirtualCheckupNoteWhereInput | VirtualCheckupNoteWhereInput[]
    OR?: VirtualCheckupNoteWhereInput[]
    NOT?: VirtualCheckupNoteWhereInput | VirtualCheckupNoteWhereInput[]
    virtualCheckupId?: StringFilter<"VirtualCheckupNote"> | string
    note?: StringFilter<"VirtualCheckupNote"> | string
    createdBy?: StringFilter<"VirtualCheckupNote"> | string
    virtualCheckup?: XOR<VirtualCheckupScalarRelationFilter, VirtualCheckupWhereInput>
  }, "id">

  export type VirtualCheckupNoteOrderByWithAggregationInput = {
    id?: SortOrder
    virtualCheckupId?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
    _count?: VirtualCheckupNoteCountOrderByAggregateInput
    _max?: VirtualCheckupNoteMaxOrderByAggregateInput
    _min?: VirtualCheckupNoteMinOrderByAggregateInput
  }

  export type VirtualCheckupNoteScalarWhereWithAggregatesInput = {
    AND?: VirtualCheckupNoteScalarWhereWithAggregatesInput | VirtualCheckupNoteScalarWhereWithAggregatesInput[]
    OR?: VirtualCheckupNoteScalarWhereWithAggregatesInput[]
    NOT?: VirtualCheckupNoteScalarWhereWithAggregatesInput | VirtualCheckupNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VirtualCheckupNote"> | string
    virtualCheckupId?: StringWithAggregatesFilter<"VirtualCheckupNote"> | string
    note?: StringWithAggregatesFilter<"VirtualCheckupNote"> | string
    createdBy?: StringWithAggregatesFilter<"VirtualCheckupNote"> | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    eventDate?: DateTimeFilter<"Event"> | Date | string
    startTime?: StringFilter<"Event"> | string
    endTime?: StringFilter<"Event"> | string
    venue?: StringFilter<"Event"> | string
    targetAudience?: StringNullableFilter<"Event"> | string | null
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    status?: StringFilter<"Event"> | string
    bannerImageUrl?: StringNullableFilter<"Event"> | string | null
    createdBy?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    eventRegistrations?: EventRegistrationListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    creator?: AccountOrderByWithRelationInput
    eventRegistrations?: EventRegistrationOrderByRelationAggregateInput
    _relevance?: EventOrderByRelevanceInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    eventDate?: DateTimeFilter<"Event"> | Date | string
    startTime?: StringFilter<"Event"> | string
    endTime?: StringFilter<"Event"> | string
    venue?: StringFilter<"Event"> | string
    targetAudience?: StringNullableFilter<"Event"> | string | null
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    status?: StringFilter<"Event"> | string
    bannerImageUrl?: StringNullableFilter<"Event"> | string | null
    createdBy?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    eventRegistrations?: EventRegistrationListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    targetAudience?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringWithAggregatesFilter<"Event"> | string
    eventType?: StringWithAggregatesFilter<"Event"> | string
    eventDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    startTime?: StringWithAggregatesFilter<"Event"> | string
    endTime?: StringWithAggregatesFilter<"Event"> | string
    venue?: StringWithAggregatesFilter<"Event"> | string
    targetAudience?: StringNullableWithAggregatesFilter<"Event"> | string | null
    maxParticipants?: IntNullableWithAggregatesFilter<"Event"> | number | null
    status?: StringWithAggregatesFilter<"Event"> | string
    bannerImageUrl?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdBy?: StringWithAggregatesFilter<"Event"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventRegistrationWhereInput = {
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    id?: StringFilter<"EventRegistration"> | string
    eventId?: StringFilter<"EventRegistration"> | string
    userProfileId?: StringFilter<"EventRegistration"> | string
    registrationDate?: DateTimeFilter<"EventRegistration"> | Date | string
    status?: StringFilter<"EventRegistration"> | string
    notes?: StringNullableFilter<"EventRegistration"> | string | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type EventRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userProfileId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    event?: EventOrderByWithRelationInput
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: EventRegistrationOrderByRelevanceInput
  }

  export type EventRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    eventId?: StringFilter<"EventRegistration"> | string
    userProfileId?: StringFilter<"EventRegistration"> | string
    registrationDate?: DateTimeFilter<"EventRegistration"> | Date | string
    status?: StringFilter<"EventRegistration"> | string
    notes?: StringNullableFilter<"EventRegistration"> | string | null
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type EventRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userProfileId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: EventRegistrationCountOrderByAggregateInput
    _max?: EventRegistrationMaxOrderByAggregateInput
    _min?: EventRegistrationMinOrderByAggregateInput
  }

  export type EventRegistrationScalarWhereWithAggregatesInput = {
    AND?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    OR?: EventRegistrationScalarWhereWithAggregatesInput[]
    NOT?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventRegistration"> | string
    eventId?: StringWithAggregatesFilter<"EventRegistration"> | string
    userProfileId?: StringWithAggregatesFilter<"EventRegistration"> | string
    registrationDate?: DateTimeWithAggregatesFilter<"EventRegistration"> | Date | string
    status?: StringWithAggregatesFilter<"EventRegistration"> | string
    notes?: StringNullableWithAggregatesFilter<"EventRegistration"> | string | null
  }

  export type MedicalProgramWhereInput = {
    AND?: MedicalProgramWhereInput | MedicalProgramWhereInput[]
    OR?: MedicalProgramWhereInput[]
    NOT?: MedicalProgramWhereInput | MedicalProgramWhereInput[]
    id?: StringFilter<"MedicalProgram"> | string
    programName?: StringFilter<"MedicalProgram"> | string
    description?: StringFilter<"MedicalProgram"> | string
    programType?: StringFilter<"MedicalProgram"> | string
    startDate?: DateTimeFilter<"MedicalProgram"> | Date | string
    endDate?: DateTimeFilter<"MedicalProgram"> | Date | string
    venue?: StringFilter<"MedicalProgram"> | string
    targetDemographic?: StringNullableFilter<"MedicalProgram"> | string | null
    targetParticipants?: IntNullableFilter<"MedicalProgram"> | number | null
    status?: StringFilter<"MedicalProgram"> | string
    bannerImageUrl?: StringNullableFilter<"MedicalProgram"> | string | null
    createdBy?: StringFilter<"MedicalProgram"> | string
    createdAt?: DateTimeFilter<"MedicalProgram"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    programParticipations?: ProgramParticipationListRelationFilter
  }

  export type MedicalProgramOrderByWithRelationInput = {
    id?: SortOrder
    programName?: SortOrder
    description?: SortOrder
    programType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    venue?: SortOrder
    targetDemographic?: SortOrderInput | SortOrder
    targetParticipants?: SortOrderInput | SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    creator?: AccountOrderByWithRelationInput
    programParticipations?: ProgramParticipationOrderByRelationAggregateInput
    _relevance?: MedicalProgramOrderByRelevanceInput
  }

  export type MedicalProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalProgramWhereInput | MedicalProgramWhereInput[]
    OR?: MedicalProgramWhereInput[]
    NOT?: MedicalProgramWhereInput | MedicalProgramWhereInput[]
    programName?: StringFilter<"MedicalProgram"> | string
    description?: StringFilter<"MedicalProgram"> | string
    programType?: StringFilter<"MedicalProgram"> | string
    startDate?: DateTimeFilter<"MedicalProgram"> | Date | string
    endDate?: DateTimeFilter<"MedicalProgram"> | Date | string
    venue?: StringFilter<"MedicalProgram"> | string
    targetDemographic?: StringNullableFilter<"MedicalProgram"> | string | null
    targetParticipants?: IntNullableFilter<"MedicalProgram"> | number | null
    status?: StringFilter<"MedicalProgram"> | string
    bannerImageUrl?: StringNullableFilter<"MedicalProgram"> | string | null
    createdBy?: StringFilter<"MedicalProgram"> | string
    createdAt?: DateTimeFilter<"MedicalProgram"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    programParticipations?: ProgramParticipationListRelationFilter
  }, "id">

  export type MedicalProgramOrderByWithAggregationInput = {
    id?: SortOrder
    programName?: SortOrder
    description?: SortOrder
    programType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    venue?: SortOrder
    targetDemographic?: SortOrderInput | SortOrder
    targetParticipants?: SortOrderInput | SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: MedicalProgramCountOrderByAggregateInput
    _avg?: MedicalProgramAvgOrderByAggregateInput
    _max?: MedicalProgramMaxOrderByAggregateInput
    _min?: MedicalProgramMinOrderByAggregateInput
    _sum?: MedicalProgramSumOrderByAggregateInput
  }

  export type MedicalProgramScalarWhereWithAggregatesInput = {
    AND?: MedicalProgramScalarWhereWithAggregatesInput | MedicalProgramScalarWhereWithAggregatesInput[]
    OR?: MedicalProgramScalarWhereWithAggregatesInput[]
    NOT?: MedicalProgramScalarWhereWithAggregatesInput | MedicalProgramScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalProgram"> | string
    programName?: StringWithAggregatesFilter<"MedicalProgram"> | string
    description?: StringWithAggregatesFilter<"MedicalProgram"> | string
    programType?: StringWithAggregatesFilter<"MedicalProgram"> | string
    startDate?: DateTimeWithAggregatesFilter<"MedicalProgram"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"MedicalProgram"> | Date | string
    venue?: StringWithAggregatesFilter<"MedicalProgram"> | string
    targetDemographic?: StringNullableWithAggregatesFilter<"MedicalProgram"> | string | null
    targetParticipants?: IntNullableWithAggregatesFilter<"MedicalProgram"> | number | null
    status?: StringWithAggregatesFilter<"MedicalProgram"> | string
    bannerImageUrl?: StringNullableWithAggregatesFilter<"MedicalProgram"> | string | null
    createdBy?: StringWithAggregatesFilter<"MedicalProgram"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalProgram"> | Date | string
  }

  export type ProgramParticipationWhereInput = {
    AND?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    OR?: ProgramParticipationWhereInput[]
    NOT?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    id?: StringFilter<"ProgramParticipation"> | string
    medicalProgramId?: StringFilter<"ProgramParticipation"> | string
    userProfileId?: StringFilter<"ProgramParticipation"> | string
    participationDate?: DateTimeFilter<"ProgramParticipation"> | Date | string
    status?: StringFilter<"ProgramParticipation"> | string
    servicesReceived?: StringNullableFilter<"ProgramParticipation"> | string | null
    notes?: StringNullableFilter<"ProgramParticipation"> | string | null
    recordedBy?: StringFilter<"ProgramParticipation"> | string
    medicalProgram?: XOR<MedicalProgramScalarRelationFilter, MedicalProgramWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type ProgramParticipationOrderByWithRelationInput = {
    id?: SortOrder
    medicalProgramId?: SortOrder
    userProfileId?: SortOrder
    participationDate?: SortOrder
    status?: SortOrder
    servicesReceived?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    medicalProgram?: MedicalProgramOrderByWithRelationInput
    userProfile?: UserProfileOrderByWithRelationInput
    _relevance?: ProgramParticipationOrderByRelevanceInput
  }

  export type ProgramParticipationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    OR?: ProgramParticipationWhereInput[]
    NOT?: ProgramParticipationWhereInput | ProgramParticipationWhereInput[]
    medicalProgramId?: StringFilter<"ProgramParticipation"> | string
    userProfileId?: StringFilter<"ProgramParticipation"> | string
    participationDate?: DateTimeFilter<"ProgramParticipation"> | Date | string
    status?: StringFilter<"ProgramParticipation"> | string
    servicesReceived?: StringNullableFilter<"ProgramParticipation"> | string | null
    notes?: StringNullableFilter<"ProgramParticipation"> | string | null
    recordedBy?: StringFilter<"ProgramParticipation"> | string
    medicalProgram?: XOR<MedicalProgramScalarRelationFilter, MedicalProgramWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id">

  export type ProgramParticipationOrderByWithAggregationInput = {
    id?: SortOrder
    medicalProgramId?: SortOrder
    userProfileId?: SortOrder
    participationDate?: SortOrder
    status?: SortOrder
    servicesReceived?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    _count?: ProgramParticipationCountOrderByAggregateInput
    _max?: ProgramParticipationMaxOrderByAggregateInput
    _min?: ProgramParticipationMinOrderByAggregateInput
  }

  export type ProgramParticipationScalarWhereWithAggregatesInput = {
    AND?: ProgramParticipationScalarWhereWithAggregatesInput | ProgramParticipationScalarWhereWithAggregatesInput[]
    OR?: ProgramParticipationScalarWhereWithAggregatesInput[]
    NOT?: ProgramParticipationScalarWhereWithAggregatesInput | ProgramParticipationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProgramParticipation"> | string
    medicalProgramId?: StringWithAggregatesFilter<"ProgramParticipation"> | string
    userProfileId?: StringWithAggregatesFilter<"ProgramParticipation"> | string
    participationDate?: DateTimeWithAggregatesFilter<"ProgramParticipation"> | Date | string
    status?: StringWithAggregatesFilter<"ProgramParticipation"> | string
    servicesReceived?: StringNullableWithAggregatesFilter<"ProgramParticipation"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ProgramParticipation"> | string | null
    recordedBy?: StringWithAggregatesFilter<"ProgramParticipation"> | string
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: StringFilter<"Inquiry"> | string
    userProfileId?: StringFilter<"Inquiry"> | string
    subject?: StringFilter<"Inquiry"> | string
    message?: StringFilter<"Inquiry"> | string
    priority?: StringFilter<"Inquiry"> | string
    status?: StringFilter<"Inquiry"> | string
    category?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    inquiryResponses?: InquiryResponseListRelationFilter
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userProfile?: UserProfileOrderByWithRelationInput
    inquiryResponses?: InquiryResponseOrderByRelationAggregateInput
    _relevance?: InquiryOrderByRelevanceInput
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    userProfileId?: StringFilter<"Inquiry"> | string
    subject?: StringFilter<"Inquiry"> | string
    message?: StringFilter<"Inquiry"> | string
    priority?: StringFilter<"Inquiry"> | string
    status?: StringFilter<"Inquiry"> | string
    category?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    inquiryResponses?: InquiryResponseListRelationFilter
  }, "id">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inquiry"> | string
    userProfileId?: StringWithAggregatesFilter<"Inquiry"> | string
    subject?: StringWithAggregatesFilter<"Inquiry"> | string
    message?: StringWithAggregatesFilter<"Inquiry"> | string
    priority?: StringWithAggregatesFilter<"Inquiry"> | string
    status?: StringWithAggregatesFilter<"Inquiry"> | string
    category?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
  }

  export type InquiryResponseWhereInput = {
    AND?: InquiryResponseWhereInput | InquiryResponseWhereInput[]
    OR?: InquiryResponseWhereInput[]
    NOT?: InquiryResponseWhereInput | InquiryResponseWhereInput[]
    id?: StringFilter<"InquiryResponse"> | string
    inquiryId?: StringFilter<"InquiryResponse"> | string
    message?: StringFilter<"InquiryResponse"> | string
    respondedBy?: StringFilter<"InquiryResponse"> | string
    inquiry?: XOR<InquiryScalarRelationFilter, InquiryWhereInput>
    responder?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type InquiryResponseOrderByWithRelationInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    message?: SortOrder
    respondedBy?: SortOrder
    inquiry?: InquiryOrderByWithRelationInput
    responder?: AccountOrderByWithRelationInput
    _relevance?: InquiryResponseOrderByRelevanceInput
  }

  export type InquiryResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InquiryResponseWhereInput | InquiryResponseWhereInput[]
    OR?: InquiryResponseWhereInput[]
    NOT?: InquiryResponseWhereInput | InquiryResponseWhereInput[]
    inquiryId?: StringFilter<"InquiryResponse"> | string
    message?: StringFilter<"InquiryResponse"> | string
    respondedBy?: StringFilter<"InquiryResponse"> | string
    inquiry?: XOR<InquiryScalarRelationFilter, InquiryWhereInput>
    responder?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type InquiryResponseOrderByWithAggregationInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    message?: SortOrder
    respondedBy?: SortOrder
    _count?: InquiryResponseCountOrderByAggregateInput
    _max?: InquiryResponseMaxOrderByAggregateInput
    _min?: InquiryResponseMinOrderByAggregateInput
  }

  export type InquiryResponseScalarWhereWithAggregatesInput = {
    AND?: InquiryResponseScalarWhereWithAggregatesInput | InquiryResponseScalarWhereWithAggregatesInput[]
    OR?: InquiryResponseScalarWhereWithAggregatesInput[]
    NOT?: InquiryResponseScalarWhereWithAggregatesInput | InquiryResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InquiryResponse"> | string
    inquiryId?: StringWithAggregatesFilter<"InquiryResponse"> | string
    message?: StringWithAggregatesFilter<"InquiryResponse"> | string
    respondedBy?: StringWithAggregatesFilter<"InquiryResponse"> | string
  }

  export type SurveyWhereInput = {
    AND?: SurveyWhereInput | SurveyWhereInput[]
    OR?: SurveyWhereInput[]
    NOT?: SurveyWhereInput | SurveyWhereInput[]
    id?: StringFilter<"Survey"> | string
    title?: StringFilter<"Survey"> | string
    description?: StringFilter<"Survey"> | string
    surveyType?: StringFilter<"Survey"> | string
    isActive?: BoolFilter<"Survey"> | boolean
    startDate?: DateTimeFilter<"Survey"> | Date | string
    endDate?: DateTimeFilter<"Survey"> | Date | string
    qrCode?: StringNullableFilter<"Survey"> | string | null
    createdBy?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    surveyQuestions?: SurveyQuestionListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
  }

  export type SurveyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    surveyType?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    creator?: AccountOrderByWithRelationInput
    surveyQuestions?: SurveyQuestionOrderByRelationAggregateInput
    surveyResponses?: SurveyResponseOrderByRelationAggregateInput
    _relevance?: SurveyOrderByRelevanceInput
  }

  export type SurveyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyWhereInput | SurveyWhereInput[]
    OR?: SurveyWhereInput[]
    NOT?: SurveyWhereInput | SurveyWhereInput[]
    title?: StringFilter<"Survey"> | string
    description?: StringFilter<"Survey"> | string
    surveyType?: StringFilter<"Survey"> | string
    isActive?: BoolFilter<"Survey"> | boolean
    startDate?: DateTimeFilter<"Survey"> | Date | string
    endDate?: DateTimeFilter<"Survey"> | Date | string
    qrCode?: StringNullableFilter<"Survey"> | string | null
    createdBy?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    surveyQuestions?: SurveyQuestionListRelationFilter
    surveyResponses?: SurveyResponseListRelationFilter
  }, "id">

  export type SurveyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    surveyType?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: SurveyCountOrderByAggregateInput
    _max?: SurveyMaxOrderByAggregateInput
    _min?: SurveyMinOrderByAggregateInput
  }

  export type SurveyScalarWhereWithAggregatesInput = {
    AND?: SurveyScalarWhereWithAggregatesInput | SurveyScalarWhereWithAggregatesInput[]
    OR?: SurveyScalarWhereWithAggregatesInput[]
    NOT?: SurveyScalarWhereWithAggregatesInput | SurveyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Survey"> | string
    title?: StringWithAggregatesFilter<"Survey"> | string
    description?: StringWithAggregatesFilter<"Survey"> | string
    surveyType?: StringWithAggregatesFilter<"Survey"> | string
    isActive?: BoolWithAggregatesFilter<"Survey"> | boolean
    startDate?: DateTimeWithAggregatesFilter<"Survey"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Survey"> | Date | string
    qrCode?: StringNullableWithAggregatesFilter<"Survey"> | string | null
    createdBy?: StringWithAggregatesFilter<"Survey"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Survey"> | Date | string
  }

  export type SurveyQuestionWhereInput = {
    AND?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    OR?: SurveyQuestionWhereInput[]
    NOT?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    id?: StringFilter<"SurveyQuestion"> | string
    surveyId?: StringFilter<"SurveyQuestion"> | string
    questionText?: StringFilter<"SurveyQuestion"> | string
    questionType?: StringFilter<"SurveyQuestion"> | string
    options?: JsonFilter<"SurveyQuestion">
    isRequired?: BoolFilter<"SurveyQuestion"> | boolean
    orderIndex?: IntFilter<"SurveyQuestion"> | number
    survey?: XOR<SurveyScalarRelationFilter, SurveyWhereInput>
    surveyAnswers?: SurveyAnswerListRelationFilter
  }

  export type SurveyQuestionOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    options?: SortOrder
    isRequired?: SortOrder
    orderIndex?: SortOrder
    survey?: SurveyOrderByWithRelationInput
    surveyAnswers?: SurveyAnswerOrderByRelationAggregateInput
    _relevance?: SurveyQuestionOrderByRelevanceInput
  }

  export type SurveyQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    OR?: SurveyQuestionWhereInput[]
    NOT?: SurveyQuestionWhereInput | SurveyQuestionWhereInput[]
    surveyId?: StringFilter<"SurveyQuestion"> | string
    questionText?: StringFilter<"SurveyQuestion"> | string
    questionType?: StringFilter<"SurveyQuestion"> | string
    options?: JsonFilter<"SurveyQuestion">
    isRequired?: BoolFilter<"SurveyQuestion"> | boolean
    orderIndex?: IntFilter<"SurveyQuestion"> | number
    survey?: XOR<SurveyScalarRelationFilter, SurveyWhereInput>
    surveyAnswers?: SurveyAnswerListRelationFilter
  }, "id">

  export type SurveyQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    options?: SortOrder
    isRequired?: SortOrder
    orderIndex?: SortOrder
    _count?: SurveyQuestionCountOrderByAggregateInput
    _avg?: SurveyQuestionAvgOrderByAggregateInput
    _max?: SurveyQuestionMaxOrderByAggregateInput
    _min?: SurveyQuestionMinOrderByAggregateInput
    _sum?: SurveyQuestionSumOrderByAggregateInput
  }

  export type SurveyQuestionScalarWhereWithAggregatesInput = {
    AND?: SurveyQuestionScalarWhereWithAggregatesInput | SurveyQuestionScalarWhereWithAggregatesInput[]
    OR?: SurveyQuestionScalarWhereWithAggregatesInput[]
    NOT?: SurveyQuestionScalarWhereWithAggregatesInput | SurveyQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SurveyQuestion"> | string
    surveyId?: StringWithAggregatesFilter<"SurveyQuestion"> | string
    questionText?: StringWithAggregatesFilter<"SurveyQuestion"> | string
    questionType?: StringWithAggregatesFilter<"SurveyQuestion"> | string
    options?: JsonWithAggregatesFilter<"SurveyQuestion">
    isRequired?: BoolWithAggregatesFilter<"SurveyQuestion"> | boolean
    orderIndex?: IntWithAggregatesFilter<"SurveyQuestion"> | number
  }

  export type SurveyResponseWhereInput = {
    AND?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    OR?: SurveyResponseWhereInput[]
    NOT?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    id?: StringFilter<"SurveyResponse"> | string
    surveyId?: StringFilter<"SurveyResponse"> | string
    userProfileId?: StringFilter<"SurveyResponse"> | string
    ipAddress?: StringNullableFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    survey?: XOR<SurveyScalarRelationFilter, SurveyWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    surveyAnswers?: SurveyAnswerListRelationFilter
  }

  export type SurveyResponseOrderByWithRelationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userProfileId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    survey?: SurveyOrderByWithRelationInput
    userProfile?: UserProfileOrderByWithRelationInput
    surveyAnswers?: SurveyAnswerOrderByRelationAggregateInput
    _relevance?: SurveyResponseOrderByRelevanceInput
  }

  export type SurveyResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    OR?: SurveyResponseWhereInput[]
    NOT?: SurveyResponseWhereInput | SurveyResponseWhereInput[]
    surveyId?: StringFilter<"SurveyResponse"> | string
    userProfileId?: StringFilter<"SurveyResponse"> | string
    ipAddress?: StringNullableFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeFilter<"SurveyResponse"> | Date | string
    survey?: XOR<SurveyScalarRelationFilter, SurveyWhereInput>
    userProfile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    surveyAnswers?: SurveyAnswerListRelationFilter
  }, "id">

  export type SurveyResponseOrderByWithAggregationInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userProfileId?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    _count?: SurveyResponseCountOrderByAggregateInput
    _max?: SurveyResponseMaxOrderByAggregateInput
    _min?: SurveyResponseMinOrderByAggregateInput
  }

  export type SurveyResponseScalarWhereWithAggregatesInput = {
    AND?: SurveyResponseScalarWhereWithAggregatesInput | SurveyResponseScalarWhereWithAggregatesInput[]
    OR?: SurveyResponseScalarWhereWithAggregatesInput[]
    NOT?: SurveyResponseScalarWhereWithAggregatesInput | SurveyResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SurveyResponse"> | string
    surveyId?: StringWithAggregatesFilter<"SurveyResponse"> | string
    userProfileId?: StringWithAggregatesFilter<"SurveyResponse"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"SurveyResponse"> | Date | string
  }

  export type SurveyAnswerWhereInput = {
    AND?: SurveyAnswerWhereInput | SurveyAnswerWhereInput[]
    OR?: SurveyAnswerWhereInput[]
    NOT?: SurveyAnswerWhereInput | SurveyAnswerWhereInput[]
    id?: StringFilter<"SurveyAnswer"> | string
    surveyResponseId?: StringFilter<"SurveyAnswer"> | string
    surveyQuestionId?: StringFilter<"SurveyAnswer"> | string
    answer?: StringFilter<"SurveyAnswer"> | string
    surveyResponse?: XOR<SurveyResponseScalarRelationFilter, SurveyResponseWhereInput>
    surveyQuestion?: XOR<SurveyQuestionScalarRelationFilter, SurveyQuestionWhereInput>
  }

  export type SurveyAnswerOrderByWithRelationInput = {
    id?: SortOrder
    surveyResponseId?: SortOrder
    surveyQuestionId?: SortOrder
    answer?: SortOrder
    surveyResponse?: SurveyResponseOrderByWithRelationInput
    surveyQuestion?: SurveyQuestionOrderByWithRelationInput
    _relevance?: SurveyAnswerOrderByRelevanceInput
  }

  export type SurveyAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurveyAnswerWhereInput | SurveyAnswerWhereInput[]
    OR?: SurveyAnswerWhereInput[]
    NOT?: SurveyAnswerWhereInput | SurveyAnswerWhereInput[]
    surveyResponseId?: StringFilter<"SurveyAnswer"> | string
    surveyQuestionId?: StringFilter<"SurveyAnswer"> | string
    answer?: StringFilter<"SurveyAnswer"> | string
    surveyResponse?: XOR<SurveyResponseScalarRelationFilter, SurveyResponseWhereInput>
    surveyQuestion?: XOR<SurveyQuestionScalarRelationFilter, SurveyQuestionWhereInput>
  }, "id">

  export type SurveyAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    surveyResponseId?: SortOrder
    surveyQuestionId?: SortOrder
    answer?: SortOrder
    _count?: SurveyAnswerCountOrderByAggregateInput
    _max?: SurveyAnswerMaxOrderByAggregateInput
    _min?: SurveyAnswerMinOrderByAggregateInput
  }

  export type SurveyAnswerScalarWhereWithAggregatesInput = {
    AND?: SurveyAnswerScalarWhereWithAggregatesInput | SurveyAnswerScalarWhereWithAggregatesInput[]
    OR?: SurveyAnswerScalarWhereWithAggregatesInput[]
    NOT?: SurveyAnswerScalarWhereWithAggregatesInput | SurveyAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SurveyAnswer"> | string
    surveyResponseId?: StringWithAggregatesFilter<"SurveyAnswer"> | string
    surveyQuestionId?: StringWithAggregatesFilter<"SurveyAnswer"> | string
    answer?: StringWithAggregatesFilter<"SurveyAnswer"> | string
  }

  export type AnalyticsReportWhereInput = {
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    id?: StringFilter<"AnalyticsReport"> | string
    reportName?: StringFilter<"AnalyticsReport"> | string
    reportType?: StringFilter<"AnalyticsReport"> | string
    dataFilters?: JsonFilter<"AnalyticsReport">
    reportData?: JsonFilter<"AnalyticsReport">
    reportPeriodStart?: DateTimeFilter<"AnalyticsReport"> | Date | string
    reportPeriodEnd?: DateTimeFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringFilter<"AnalyticsReport"> | string
    generator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type AnalyticsReportOrderByWithRelationInput = {
    id?: SortOrder
    reportName?: SortOrder
    reportType?: SortOrder
    dataFilters?: SortOrder
    reportData?: SortOrder
    reportPeriodStart?: SortOrder
    reportPeriodEnd?: SortOrder
    generatedBy?: SortOrder
    generator?: AccountOrderByWithRelationInput
    _relevance?: AnalyticsReportOrderByRelevanceInput
  }

  export type AnalyticsReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    reportName?: StringFilter<"AnalyticsReport"> | string
    reportType?: StringFilter<"AnalyticsReport"> | string
    dataFilters?: JsonFilter<"AnalyticsReport">
    reportData?: JsonFilter<"AnalyticsReport">
    reportPeriodStart?: DateTimeFilter<"AnalyticsReport"> | Date | string
    reportPeriodEnd?: DateTimeFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringFilter<"AnalyticsReport"> | string
    generator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type AnalyticsReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportName?: SortOrder
    reportType?: SortOrder
    dataFilters?: SortOrder
    reportData?: SortOrder
    reportPeriodStart?: SortOrder
    reportPeriodEnd?: SortOrder
    generatedBy?: SortOrder
    _count?: AnalyticsReportCountOrderByAggregateInput
    _max?: AnalyticsReportMaxOrderByAggregateInput
    _min?: AnalyticsReportMinOrderByAggregateInput
  }

  export type AnalyticsReportScalarWhereWithAggregatesInput = {
    AND?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    OR?: AnalyticsReportScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    reportName?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    reportType?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    dataFilters?: JsonWithAggregatesFilter<"AnalyticsReport">
    reportData?: JsonWithAggregatesFilter<"AnalyticsReport">
    reportPeriodStart?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
    reportPeriodEnd?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringWithAggregatesFilter<"AnalyticsReport"> | string
  }

  export type PredictionModelWhereInput = {
    AND?: PredictionModelWhereInput | PredictionModelWhereInput[]
    OR?: PredictionModelWhereInput[]
    NOT?: PredictionModelWhereInput | PredictionModelWhereInput[]
    id?: StringFilter<"PredictionModel"> | string
    modelName?: StringFilter<"PredictionModel"> | string
    modelType?: StringFilter<"PredictionModel"> | string
    modelParameters?: JsonFilter<"PredictionModel">
    predictionResults?: JsonNullableFilter<"PredictionModel">
    accuracy?: FloatNullableFilter<"PredictionModel"> | number | null
    lastTrained?: DateTimeNullableFilter<"PredictionModel"> | Date | string | null
    isActive?: BoolFilter<"PredictionModel"> | boolean
    createdBy?: StringFilter<"PredictionModel"> | string
    createdAt?: DateTimeFilter<"PredictionModel"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type PredictionModelOrderByWithRelationInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelType?: SortOrder
    modelParameters?: SortOrder
    predictionResults?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    lastTrained?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    creator?: AccountOrderByWithRelationInput
    _relevance?: PredictionModelOrderByRelevanceInput
  }

  export type PredictionModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PredictionModelWhereInput | PredictionModelWhereInput[]
    OR?: PredictionModelWhereInput[]
    NOT?: PredictionModelWhereInput | PredictionModelWhereInput[]
    modelName?: StringFilter<"PredictionModel"> | string
    modelType?: StringFilter<"PredictionModel"> | string
    modelParameters?: JsonFilter<"PredictionModel">
    predictionResults?: JsonNullableFilter<"PredictionModel">
    accuracy?: FloatNullableFilter<"PredictionModel"> | number | null
    lastTrained?: DateTimeNullableFilter<"PredictionModel"> | Date | string | null
    isActive?: BoolFilter<"PredictionModel"> | boolean
    createdBy?: StringFilter<"PredictionModel"> | string
    createdAt?: DateTimeFilter<"PredictionModel"> | Date | string
    creator?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type PredictionModelOrderByWithAggregationInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelType?: SortOrder
    modelParameters?: SortOrder
    predictionResults?: SortOrderInput | SortOrder
    accuracy?: SortOrderInput | SortOrder
    lastTrained?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    _count?: PredictionModelCountOrderByAggregateInput
    _avg?: PredictionModelAvgOrderByAggregateInput
    _max?: PredictionModelMaxOrderByAggregateInput
    _min?: PredictionModelMinOrderByAggregateInput
    _sum?: PredictionModelSumOrderByAggregateInput
  }

  export type PredictionModelScalarWhereWithAggregatesInput = {
    AND?: PredictionModelScalarWhereWithAggregatesInput | PredictionModelScalarWhereWithAggregatesInput[]
    OR?: PredictionModelScalarWhereWithAggregatesInput[]
    NOT?: PredictionModelScalarWhereWithAggregatesInput | PredictionModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PredictionModel"> | string
    modelName?: StringWithAggregatesFilter<"PredictionModel"> | string
    modelType?: StringWithAggregatesFilter<"PredictionModel"> | string
    modelParameters?: JsonWithAggregatesFilter<"PredictionModel">
    predictionResults?: JsonNullableWithAggregatesFilter<"PredictionModel">
    accuracy?: FloatNullableWithAggregatesFilter<"PredictionModel"> | number | null
    lastTrained?: DateTimeNullableWithAggregatesFilter<"PredictionModel"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"PredictionModel"> | boolean
    createdBy?: StringWithAggregatesFilter<"PredictionModel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PredictionModel"> | Date | string
  }

  export type SystemLogWhereInput = {
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    userId?: StringFilter<"SystemLog"> | string
    action?: StringFilter<"SystemLog"> | string
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: StringFilter<"SystemLog"> | string
    oldData?: JsonNullableFilter<"SystemLog">
    newData?: JsonNullableFilter<"SystemLog">
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
    user?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type SystemLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    user?: AccountOrderByWithRelationInput
    _relevance?: SystemLogOrderByRelevanceInput
  }

  export type SystemLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemLogWhereInput | SystemLogWhereInput[]
    OR?: SystemLogWhereInput[]
    NOT?: SystemLogWhereInput | SystemLogWhereInput[]
    userId?: StringFilter<"SystemLog"> | string
    action?: StringFilter<"SystemLog"> | string
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: StringFilter<"SystemLog"> | string
    oldData?: JsonNullableFilter<"SystemLog">
    newData?: JsonNullableFilter<"SystemLog">
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
    user?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id">

  export type SystemLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrderInput | SortOrder
    newData?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: SystemLogCountOrderByAggregateInput
    _max?: SystemLogMaxOrderByAggregateInput
    _min?: SystemLogMinOrderByAggregateInput
  }

  export type SystemLogScalarWhereWithAggregatesInput = {
    AND?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    OR?: SystemLogScalarWhereWithAggregatesInput[]
    NOT?: SystemLogScalarWhereWithAggregatesInput | SystemLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemLog"> | string
    userId?: StringWithAggregatesFilter<"SystemLog"> | string
    action?: StringWithAggregatesFilter<"SystemLog"> | string
    entityType?: StringWithAggregatesFilter<"SystemLog"> | string
    entityId?: StringWithAggregatesFilter<"SystemLog"> | string
    oldData?: JsonNullableWithAggregatesFilter<"SystemLog">
    newData?: JsonNullableWithAggregatesFilter<"SystemLog">
    ipAddress?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SystemLog"> | string | null
  }

  export type AccountCreateInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserProfileCreateInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateManyInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthWorkerCreateInput = {
    id?: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
    account: AccountCreateNestedOneWithoutHealthWorkersInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutHealthWorkerInput
  }

  export type HealthWorkerUncheckedCreateInput = {
    id?: string
    accountId: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutHealthWorkerInput
  }

  export type HealthWorkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    account?: AccountUpdateOneRequiredWithoutHealthWorkersNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutHealthWorkerNestedInput
  }

  export type HealthWorkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutHealthWorkerNestedInput
  }

  export type HealthWorkerCreateManyInput = {
    id?: string
    accountId: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
  }

  export type HealthWorkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HealthWorkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FamilyRecordCreateInput = {
    id?: string
    familyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    headOfFamily: UserProfileCreateNestedOneWithoutFamilyRecordsHeadedInput
    members?: FamilyMemberCreateNestedManyWithoutFamilyRecordInput
    familyHealthHistory?: FamilyHealthHistoryCreateNestedOneWithoutFamilyRecordInput
  }

  export type FamilyRecordUncheckedCreateInput = {
    id?: string
    familyId: string
    headOfFamilyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyRecordInput
    familyHealthHistory?: FamilyHealthHistoryUncheckedCreateNestedOneWithoutFamilyRecordInput
  }

  export type FamilyRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headOfFamily?: UserProfileUpdateOneRequiredWithoutFamilyRecordsHeadedNestedInput
    members?: FamilyMemberUpdateManyWithoutFamilyRecordNestedInput
    familyHealthHistory?: FamilyHealthHistoryUpdateOneWithoutFamilyRecordNestedInput
  }

  export type FamilyRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyMemberUncheckedUpdateManyWithoutFamilyRecordNestedInput
    familyHealthHistory?: FamilyHealthHistoryUncheckedUpdateOneWithoutFamilyRecordNestedInput
  }

  export type FamilyRecordCreateManyInput = {
    id?: string
    familyId: string
    headOfFamilyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberCreateInput = {
    id?: string
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
    familyRecord: FamilyRecordCreateNestedOneWithoutMembersInput
    userProfile?: UserProfileCreateNestedOneWithoutFamilyMembersInput
  }

  export type FamilyMemberUncheckedCreateInput = {
    id?: string
    familyRecordId: string
    userProfileId?: string | null
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
  }

  export type FamilyMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    familyRecord?: FamilyRecordUpdateOneRequiredWithoutMembersNestedInput
    userProfile?: UserProfileUpdateOneWithoutFamilyMembersNestedInput
  }

  export type FamilyMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyRecordId?: StringFieldUpdateOperationsInput | string
    userProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyMemberCreateManyInput = {
    id?: string
    familyRecordId: string
    userProfileId?: string | null
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
  }

  export type FamilyMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyRecordId?: StringFieldUpdateOperationsInput | string
    userProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyHealthHistoryCreateInput = {
    id?: string
    geneticConditions: JsonNullValueInput | InputJsonValue
    chronicDiseases: JsonNullValueInput | InputJsonValue
    recordedDate?: Date | string
    recordedBy: string
    familyRecord: FamilyRecordCreateNestedOneWithoutFamilyHealthHistoryInput
  }

  export type FamilyHealthHistoryUncheckedCreateInput = {
    id?: string
    familyRecordId: string
    geneticConditions: JsonNullValueInput | InputJsonValue
    chronicDiseases: JsonNullValueInput | InputJsonValue
    recordedDate?: Date | string
    recordedBy: string
  }

  export type FamilyHealthHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    geneticConditions?: JsonNullValueInput | InputJsonValue
    chronicDiseases?: JsonNullValueInput | InputJsonValue
    recordedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    familyRecord?: FamilyRecordUpdateOneRequiredWithoutFamilyHealthHistoryNestedInput
  }

  export type FamilyHealthHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyRecordId?: StringFieldUpdateOperationsInput | string
    geneticConditions?: JsonNullValueInput | InputJsonValue
    chronicDiseases?: JsonNullValueInput | InputJsonValue
    recordedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyHealthHistoryCreateManyInput = {
    id?: string
    familyRecordId: string
    geneticConditions: JsonNullValueInput | InputJsonValue
    chronicDiseases: JsonNullValueInput | InputJsonValue
    recordedDate?: Date | string
    recordedBy: string
  }

  export type FamilyHealthHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    geneticConditions?: JsonNullValueInput | InputJsonValue
    chronicDiseases?: JsonNullValueInput | InputJsonValue
    recordedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyHealthHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyRecordId?: StringFieldUpdateOperationsInput | string
    geneticConditions?: JsonNullValueInput | InputJsonValue
    chronicDiseases?: JsonNullValueInput | InputJsonValue
    recordedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type MaternalHealthCreateInput = {
    id?: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutMaternalHealthRecordsInput
    prenatalVisits?: PrenatalVisitCreateNestedManyWithoutMaternalHealthInput
    birthInformation?: BirthInformationCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthUncheckedCreateInput = {
    id?: string
    userProfileId: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    prenatalVisits?: PrenatalVisitUncheckedCreateNestedManyWithoutMaternalHealthInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutMaternalHealthRecordsNestedInput
    prenatalVisits?: PrenatalVisitUpdateManyWithoutMaternalHealthNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutMaternalHealthNestedInput
  }

  export type MaternalHealthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenatalVisits?: PrenatalVisitUncheckedUpdateManyWithoutMaternalHealthNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutMaternalHealthNestedInput
  }

  export type MaternalHealthCreateManyInput = {
    id?: string
    userProfileId: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
  }

  export type MaternalHealthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaternalHealthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrenatalVisitCreateInput = {
    id?: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    maternalHealth: MaternalHealthCreateNestedOneWithoutPrenatalVisitsInput
    laboratoryTests?: LaboratoryTestCreateNestedManyWithoutPrenatalVisitInput
    interventions?: InterventionCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitUncheckedCreateInput = {
    id?: string
    maternalHealthId: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    laboratoryTests?: LaboratoryTestUncheckedCreateNestedManyWithoutPrenatalVisitInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    maternalHealth?: MaternalHealthUpdateOneRequiredWithoutPrenatalVisitsNestedInput
    laboratoryTests?: LaboratoryTestUpdateManyWithoutPrenatalVisitNestedInput
    interventions?: InterventionUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type PrenatalVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    laboratoryTests?: LaboratoryTestUncheckedUpdateManyWithoutPrenatalVisitNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type PrenatalVisitCreateManyInput = {
    id?: string
    maternalHealthId: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
  }

  export type PrenatalVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PrenatalVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryTestCreateInput = {
    id?: string
    userProfileId: string
    testDate: Date | string
    testType: string
    testCompleted?: boolean
    recordedBy: string
    prenatalVisit: PrenatalVisitCreateNestedOneWithoutLaboratoryTestsInput
  }

  export type LaboratoryTestUncheckedCreateInput = {
    id?: string
    prenatalVisitId: string
    userProfileId: string
    testDate: Date | string
    testType: string
    testCompleted?: boolean
    recordedBy: string
  }

  export type LaboratoryTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    testType?: StringFieldUpdateOperationsInput | string
    testCompleted?: BoolFieldUpdateOperationsInput | boolean
    recordedBy?: StringFieldUpdateOperationsInput | string
    prenatalVisit?: PrenatalVisitUpdateOneRequiredWithoutLaboratoryTestsNestedInput
  }

  export type LaboratoryTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prenatalVisitId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    testType?: StringFieldUpdateOperationsInput | string
    testCompleted?: BoolFieldUpdateOperationsInput | boolean
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryTestCreateManyInput = {
    id?: string
    prenatalVisitId: string
    userProfileId: string
    testDate: Date | string
    testType: string
    testCompleted?: boolean
    recordedBy: string
  }

  export type LaboratoryTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    testType?: StringFieldUpdateOperationsInput | string
    testCompleted?: BoolFieldUpdateOperationsInput | boolean
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prenatalVisitId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    testType?: StringFieldUpdateOperationsInput | string
    testCompleted?: BoolFieldUpdateOperationsInput | boolean
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type InterventionCreateInput = {
    id?: string
    tetanusToxoidDose?: string | null
    tetanusToxoidLocation?: string | null
    tetanusToxoidDate?: Date | string | null
    ironSupplementation?: boolean
    ironMedication?: string | null
    vitaminSupplementation?: boolean
    vitaminMedication?: string | null
    calciumSupplementation?: boolean
    calciumMedication?: string | null
    healthEducationTopics: JsonNullValueInput | InputJsonValue
    prenatalVisit: PrenatalVisitCreateNestedOneWithoutInterventionsInput
  }

  export type InterventionUncheckedCreateInput = {
    id?: string
    prenatalVisitId: string
    tetanusToxoidDose?: string | null
    tetanusToxoidLocation?: string | null
    tetanusToxoidDate?: Date | string | null
    ironSupplementation?: boolean
    ironMedication?: string | null
    vitaminSupplementation?: boolean
    vitaminMedication?: string | null
    calciumSupplementation?: boolean
    calciumMedication?: string | null
    healthEducationTopics: JsonNullValueInput | InputJsonValue
  }

  export type InterventionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetanusToxoidDose?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidLocation?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ironSupplementation?: BoolFieldUpdateOperationsInput | boolean
    ironMedication?: NullableStringFieldUpdateOperationsInput | string | null
    vitaminSupplementation?: BoolFieldUpdateOperationsInput | boolean
    vitaminMedication?: NullableStringFieldUpdateOperationsInput | string | null
    calciumSupplementation?: BoolFieldUpdateOperationsInput | boolean
    calciumMedication?: NullableStringFieldUpdateOperationsInput | string | null
    healthEducationTopics?: JsonNullValueInput | InputJsonValue
    prenatalVisit?: PrenatalVisitUpdateOneRequiredWithoutInterventionsNestedInput
  }

  export type InterventionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prenatalVisitId?: StringFieldUpdateOperationsInput | string
    tetanusToxoidDose?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidLocation?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ironSupplementation?: BoolFieldUpdateOperationsInput | boolean
    ironMedication?: NullableStringFieldUpdateOperationsInput | string | null
    vitaminSupplementation?: BoolFieldUpdateOperationsInput | boolean
    vitaminMedication?: NullableStringFieldUpdateOperationsInput | string | null
    calciumSupplementation?: BoolFieldUpdateOperationsInput | boolean
    calciumMedication?: NullableStringFieldUpdateOperationsInput | string | null
    healthEducationTopics?: JsonNullValueInput | InputJsonValue
  }

  export type InterventionCreateManyInput = {
    id?: string
    prenatalVisitId: string
    tetanusToxoidDose?: string | null
    tetanusToxoidLocation?: string | null
    tetanusToxoidDate?: Date | string | null
    ironSupplementation?: boolean
    ironMedication?: string | null
    vitaminSupplementation?: boolean
    vitaminMedication?: string | null
    calciumSupplementation?: boolean
    calciumMedication?: string | null
    healthEducationTopics: JsonNullValueInput | InputJsonValue
  }

  export type InterventionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetanusToxoidDose?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidLocation?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ironSupplementation?: BoolFieldUpdateOperationsInput | boolean
    ironMedication?: NullableStringFieldUpdateOperationsInput | string | null
    vitaminSupplementation?: BoolFieldUpdateOperationsInput | boolean
    vitaminMedication?: NullableStringFieldUpdateOperationsInput | string | null
    calciumSupplementation?: BoolFieldUpdateOperationsInput | boolean
    calciumMedication?: NullableStringFieldUpdateOperationsInput | string | null
    healthEducationTopics?: JsonNullValueInput | InputJsonValue
  }

  export type InterventionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prenatalVisitId?: StringFieldUpdateOperationsInput | string
    tetanusToxoidDose?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidLocation?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ironSupplementation?: BoolFieldUpdateOperationsInput | boolean
    ironMedication?: NullableStringFieldUpdateOperationsInput | string | null
    vitaminSupplementation?: BoolFieldUpdateOperationsInput | boolean
    vitaminMedication?: NullableStringFieldUpdateOperationsInput | string | null
    calciumSupplementation?: BoolFieldUpdateOperationsInput | boolean
    calciumMedication?: NullableStringFieldUpdateOperationsInput | string | null
    healthEducationTopics?: JsonNullValueInput | InputJsonValue
  }

  export type BirthInformationCreateInput = {
    id?: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutBirthInformationInput
    maternalHealth: MaternalHealthCreateNestedOneWithoutBirthInformationInput
  }

  export type BirthInformationUncheckedCreateInput = {
    id?: string
    userProfileId: string
    maternalHealthId: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
  }

  export type BirthInformationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutBirthInformationNestedInput
    maternalHealth?: MaternalHealthUpdateOneRequiredWithoutBirthInformationNestedInput
  }

  export type BirthInformationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type BirthInformationCreateManyInput = {
    id?: string
    userProfileId: string
    maternalHealthId: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
  }

  export type BirthInformationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type BirthInformationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ImmunizationEventCreateInput = {
    id?: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutImmunizationEventsInput
    vaccinesGiven?: VaccineGivenCreateNestedManyWithoutImmunizationEventInput
  }

  export type ImmunizationEventUncheckedCreateInput = {
    id?: string
    userProfileId: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
    vaccinesGiven?: VaccineGivenUncheckedCreateNestedManyWithoutImmunizationEventInput
  }

  export type ImmunizationEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutImmunizationEventsNestedInput
    vaccinesGiven?: VaccineGivenUpdateManyWithoutImmunizationEventNestedInput
  }

  export type ImmunizationEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    vaccinesGiven?: VaccineGivenUncheckedUpdateManyWithoutImmunizationEventNestedInput
  }

  export type ImmunizationEventCreateManyInput = {
    id?: string
    userProfileId: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
  }

  export type ImmunizationEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ImmunizationEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VaccineGivenCreateInput = {
    id?: string
    vaccineName: string
    doseNumber: string
    dateGiven: Date | string
    lotNumber?: string | null
    immunizationEvent: ImmunizationEventCreateNestedOneWithoutVaccinesGivenInput
  }

  export type VaccineGivenUncheckedCreateInput = {
    id?: string
    immunizationEventId: string
    vaccineName: string
    doseNumber: string
    dateGiven: Date | string
    lotNumber?: string | null
  }

  export type VaccineGivenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    doseNumber?: StringFieldUpdateOperationsInput | string
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
    immunizationEvent?: ImmunizationEventUpdateOneRequiredWithoutVaccinesGivenNestedInput
  }

  export type VaccineGivenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    immunizationEventId?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    doseNumber?: StringFieldUpdateOperationsInput | string
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VaccineGivenCreateManyInput = {
    id?: string
    immunizationEventId: string
    vaccineName: string
    doseNumber: string
    dateGiven: Date | string
    lotNumber?: string | null
  }

  export type VaccineGivenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    doseNumber?: StringFieldUpdateOperationsInput | string
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VaccineGivenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    immunizationEventId?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    doseNumber?: StringFieldUpdateOperationsInput | string
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VitalSignsCreateInput = {
    id?: string
    recordDate: Date | string
    bloodPressure?: string | null
    heartRate?: number | null
    respiratoryRate?: number | null
    temperatureCelsius?: number | null
    pulseRate?: number | null
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutVitalSignsInput
  }

  export type VitalSignsUncheckedCreateInput = {
    id?: string
    userProfileId: string
    recordDate: Date | string
    bloodPressure?: string | null
    heartRate?: number | null
    respiratoryRate?: number | null
    temperatureCelsius?: number | null
    pulseRate?: number | null
    recordedBy: string
  }

  export type VitalSignsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    pulseRate?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutVitalSignsNestedInput
  }

  export type VitalSignsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    pulseRate?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VitalSignsCreateManyInput = {
    id?: string
    userProfileId: string
    recordDate: Date | string
    bloodPressure?: string | null
    heartRate?: number | null
    respiratoryRate?: number | null
    temperatureCelsius?: number | null
    pulseRate?: number | null
    recordedBy: string
  }

  export type VitalSignsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    pulseRate?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VitalSignsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    pulseRate?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnthropometricMeasurementCreateInput = {
    id?: string
    measurementDate: Date | string
    weightKg?: number | null
    heightCm?: number | null
    headCircumferenceCm?: number | null
    waistCircumferenceCm?: number | null
    bmi?: number | null
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutAnthropometricMeasurementsInput
  }

  export type AnthropometricMeasurementUncheckedCreateInput = {
    id?: string
    userProfileId: string
    measurementDate: Date | string
    weightKg?: number | null
    heightCm?: number | null
    headCircumferenceCm?: number | null
    waistCircumferenceCm?: number | null
    bmi?: number | null
    recordedBy: string
  }

  export type AnthropometricMeasurementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    headCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    waistCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutAnthropometricMeasurementsNestedInput
  }

  export type AnthropometricMeasurementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    headCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    waistCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnthropometricMeasurementCreateManyInput = {
    id?: string
    userProfileId: string
    measurementDate: Date | string
    weightKg?: number | null
    heightCm?: number | null
    headCircumferenceCm?: number | null
    waistCircumferenceCm?: number | null
    bmi?: number | null
    recordedBy: string
  }

  export type AnthropometricMeasurementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    headCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    waistCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnthropometricMeasurementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    headCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    waistCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type GrowthTrackingCreateInput = {
    id?: string
    trackingDate: Date | string
    weightForAge?: string | null
    heightForAge?: string | null
    weightForHeight?: string | null
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutGrowthTrackingInput
  }

  export type GrowthTrackingUncheckedCreateInput = {
    id?: string
    userProfileId: string
    trackingDate: Date | string
    weightForAge?: string | null
    heightForAge?: string | null
    weightForHeight?: string | null
    recordedBy: string
  }

  export type GrowthTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    heightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    weightForHeight?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutGrowthTrackingNestedInput
  }

  export type GrowthTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    trackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    heightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    weightForHeight?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type GrowthTrackingCreateManyInput = {
    id?: string
    userProfileId: string
    trackingDate: Date | string
    weightForAge?: string | null
    heightForAge?: string | null
    weightForHeight?: string | null
    recordedBy: string
  }

  export type GrowthTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    heightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    weightForHeight?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type GrowthTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    trackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    heightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    weightForHeight?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NCDRiskAssessmentCreateInput = {
    id?: string
    assessmentDate: Date | string
    smokingStatus?: string | null
    alcoholIntake?: string | null
    physicalActivity?: string | null
    fruitVegetableIntake?: string | null
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications: JsonNullValueInput | InputJsonValue
    healthEducationReceived: JsonNullValueInput | InputJsonValue
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutNcdRiskAssessmentsInput
  }

  export type NCDRiskAssessmentUncheckedCreateInput = {
    id?: string
    userProfileId: string
    assessmentDate: Date | string
    smokingStatus?: string | null
    alcoholIntake?: string | null
    physicalActivity?: string | null
    fruitVegetableIntake?: string | null
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications: JsonNullValueInput | InputJsonValue
    healthEducationReceived: JsonNullValueInput | InputJsonValue
    recordedBy: string
  }

  export type NCDRiskAssessmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    smokingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    alcoholIntake?: NullableStringFieldUpdateOperationsInput | string | null
    physicalActivity?: NullableStringFieldUpdateOperationsInput | string | null
    fruitVegetableIntake?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistoryDiabetes?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHypertension?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHeartDisease?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryStroke?: BoolFieldUpdateOperationsInput | boolean
    screeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    followUpNeeded?: BoolFieldUpdateOperationsInput | boolean
    lifestyleModifications?: JsonNullValueInput | InputJsonValue
    healthEducationReceived?: JsonNullValueInput | InputJsonValue
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutNcdRiskAssessmentsNestedInput
  }

  export type NCDRiskAssessmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    smokingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    alcoholIntake?: NullableStringFieldUpdateOperationsInput | string | null
    physicalActivity?: NullableStringFieldUpdateOperationsInput | string | null
    fruitVegetableIntake?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistoryDiabetes?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHypertension?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHeartDisease?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryStroke?: BoolFieldUpdateOperationsInput | boolean
    screeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    followUpNeeded?: BoolFieldUpdateOperationsInput | boolean
    lifestyleModifications?: JsonNullValueInput | InputJsonValue
    healthEducationReceived?: JsonNullValueInput | InputJsonValue
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NCDRiskAssessmentCreateManyInput = {
    id?: string
    userProfileId: string
    assessmentDate: Date | string
    smokingStatus?: string | null
    alcoholIntake?: string | null
    physicalActivity?: string | null
    fruitVegetableIntake?: string | null
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications: JsonNullValueInput | InputJsonValue
    healthEducationReceived: JsonNullValueInput | InputJsonValue
    recordedBy: string
  }

  export type NCDRiskAssessmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    smokingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    alcoholIntake?: NullableStringFieldUpdateOperationsInput | string | null
    physicalActivity?: NullableStringFieldUpdateOperationsInput | string | null
    fruitVegetableIntake?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistoryDiabetes?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHypertension?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHeartDisease?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryStroke?: BoolFieldUpdateOperationsInput | boolean
    screeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    followUpNeeded?: BoolFieldUpdateOperationsInput | boolean
    lifestyleModifications?: JsonNullValueInput | InputJsonValue
    healthEducationReceived?: JsonNullValueInput | InputJsonValue
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NCDRiskAssessmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    smokingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    alcoholIntake?: NullableStringFieldUpdateOperationsInput | string | null
    physicalActivity?: NullableStringFieldUpdateOperationsInput | string | null
    fruitVegetableIntake?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistoryDiabetes?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHypertension?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHeartDisease?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryStroke?: BoolFieldUpdateOperationsInput | boolean
    screeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    followUpNeeded?: BoolFieldUpdateOperationsInput | boolean
    lifestyleModifications?: JsonNullValueInput | InputJsonValue
    healthEducationReceived?: JsonNullValueInput | InputJsonValue
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VisitRecordCreateInput = {
    id?: string
    visitDate: Date | string
    visitType: string
    visitFrequency?: string | null
    referred?: boolean
    facilityName?: string | null
    referralReason?: string | null
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutVisitRecordsInput
  }

  export type VisitRecordUncheckedCreateInput = {
    id?: string
    userProfileId: string
    visitDate: Date | string
    visitType: string
    visitFrequency?: string | null
    referred?: boolean
    facilityName?: string | null
    referralReason?: string | null
    recordedBy: string
  }

  export type VisitRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    visitFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    facilityName?: NullableStringFieldUpdateOperationsInput | string | null
    referralReason?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutVisitRecordsNestedInput
  }

  export type VisitRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    visitFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    facilityName?: NullableStringFieldUpdateOperationsInput | string | null
    referralReason?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VisitRecordCreateManyInput = {
    id?: string
    userProfileId: string
    visitDate: Date | string
    visitType: string
    visitFrequency?: string | null
    referred?: boolean
    facilityName?: string | null
    referralReason?: string | null
    recordedBy: string
  }

  export type VisitRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    visitFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    facilityName?: NullableStringFieldUpdateOperationsInput | string | null
    referralReason?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VisitRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    visitFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    facilityName?: NullableStringFieldUpdateOperationsInput | string | null
    referralReason?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type HealthEducationCreateInput = {
    id?: string
    topicsCovered: JsonNullValueInput | InputJsonValue
    dateProvided: Date | string
    providedBy: string
    userProfile: UserProfileCreateNestedOneWithoutHealthEducationInput
  }

  export type HealthEducationUncheckedCreateInput = {
    id?: string
    userProfileId: string
    topicsCovered: JsonNullValueInput | InputJsonValue
    dateProvided: Date | string
    providedBy: string
  }

  export type HealthEducationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicsCovered?: JsonNullValueInput | InputJsonValue
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutHealthEducationNestedInput
  }

  export type HealthEducationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    topicsCovered?: JsonNullValueInput | InputJsonValue
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type HealthEducationCreateManyInput = {
    id?: string
    userProfileId: string
    topicsCovered: JsonNullValueInput | InputJsonValue
    dateProvided: Date | string
    providedBy: string
  }

  export type HealthEducationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicsCovered?: JsonNullValueInput | InputJsonValue
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type HealthEducationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    topicsCovered?: JsonNullValueInput | InputJsonValue
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalCounselingCreateInput = {
    id?: string
    recommendations: string
    dateProvided: Date | string
    providedBy: string
    userProfile: UserProfileCreateNestedOneWithoutNutritionalCounselingInput
  }

  export type NutritionalCounselingUncheckedCreateInput = {
    id?: string
    userProfileId: string
    recommendations: string
    dateProvided: Date | string
    providedBy: string
  }

  export type NutritionalCounselingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutNutritionalCounselingNestedInput
  }

  export type NutritionalCounselingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalCounselingCreateManyInput = {
    id?: string
    userProfileId: string
    recommendations: string
    dateProvided: Date | string
    providedBy: string
  }

  export type NutritionalCounselingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalCounselingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralCreateInput = {
    id?: string
    facilityName: string
    reason: string
    dateReferred: Date | string
    status: string
    referredBy: string
    userProfile: UserProfileCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    userProfileId: string
    facilityName: string
    reason: string
    dateReferred: Date | string
    status: string
    referredBy: string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    dateReferred?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    referredBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    dateReferred?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    referredBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    userProfileId: string
    facilityName: string
    reason: string
    dateReferred: Date | string
    status: string
    referredBy: string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    dateReferred?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    referredBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    dateReferred?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    referredBy?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentCreateInput = {
    id?: string
    nextVisitDate: Date | string
    visitType: string
    appointmentStatus: string
    scheduledBy: string
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    userProfileId: string
    nextVisitDate: Date | string
    visitType: string
    appointmentStatus: string
    scheduledBy: string
    createdAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    appointmentStatus?: StringFieldUpdateOperationsInput | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    appointmentStatus?: StringFieldUpdateOperationsInput | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: string
    userProfileId: string
    nextVisitDate: Date | string
    visitType: string
    appointmentStatus: string
    scheduledBy: string
    createdAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    appointmentStatus?: StringFieldUpdateOperationsInput | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    appointmentStatus?: StringFieldUpdateOperationsInput | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImmunizationReminderCreateInput = {
    id?: string
    vaccineName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
    userProfile: UserProfileCreateNestedOneWithoutImmunizationRemindersInput
  }

  export type ImmunizationReminderUncheckedCreateInput = {
    id?: string
    userProfileId: string
    vaccineName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type ImmunizationReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProfile?: UserProfileUpdateOneRequiredWithoutImmunizationRemindersNestedInput
  }

  export type ImmunizationReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImmunizationReminderCreateManyInput = {
    id?: string
    userProfileId: string
    vaccineName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type ImmunizationReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImmunizationReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestReminderCreateInput = {
    id?: string
    testName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
    userProfile: UserProfileCreateNestedOneWithoutTestRemindersInput
  }

  export type TestReminderUncheckedCreateInput = {
    id?: string
    userProfileId: string
    testName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type TestReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userProfile?: UserProfileUpdateOneRequiredWithoutTestRemindersNestedInput
  }

  export type TestReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestReminderCreateManyInput = {
    id?: string
    userProfileId: string
    testName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type TestReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VirtualCheckupCreateInput = {
    id?: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutVirtualCheckupsInput
    healthWorker: HealthWorkerCreateNestedOneWithoutVirtualCheckupsInput
    virtualCheckupNotes?: VirtualCheckupNoteCreateNestedManyWithoutVirtualCheckupInput
  }

  export type VirtualCheckupUncheckedCreateInput = {
    id?: string
    userProfileId: string
    healthWorkerId: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
    virtualCheckupNotes?: VirtualCheckupNoteUncheckedCreateNestedManyWithoutVirtualCheckupInput
  }

  export type VirtualCheckupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutVirtualCheckupsNestedInput
    healthWorker?: HealthWorkerUpdateOneRequiredWithoutVirtualCheckupsNestedInput
    virtualCheckupNotes?: VirtualCheckupNoteUpdateManyWithoutVirtualCheckupNestedInput
  }

  export type VirtualCheckupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    healthWorkerId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualCheckupNotes?: VirtualCheckupNoteUncheckedUpdateManyWithoutVirtualCheckupNestedInput
  }

  export type VirtualCheckupCreateManyInput = {
    id?: string
    userProfileId: string
    healthWorkerId: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
  }

  export type VirtualCheckupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualCheckupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    healthWorkerId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualCheckupNoteCreateInput = {
    id?: string
    note: string
    createdBy: string
    virtualCheckup: VirtualCheckupCreateNestedOneWithoutVirtualCheckupNotesInput
  }

  export type VirtualCheckupNoteUncheckedCreateInput = {
    id?: string
    virtualCheckupId: string
    note: string
    createdBy: string
  }

  export type VirtualCheckupNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    virtualCheckup?: VirtualCheckupUpdateOneRequiredWithoutVirtualCheckupNotesNestedInput
  }

  export type VirtualCheckupNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualCheckupId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualCheckupNoteCreateManyInput = {
    id?: string
    virtualCheckupId: string
    note: string
    createdBy: string
  }

  export type VirtualCheckupNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualCheckupNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualCheckupId?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutEventsInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdBy: string
    createdAt?: Date | string
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutEventsNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateInput = {
    id?: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
    event: EventCreateNestedOneWithoutEventRegistrationsInput
    userProfile: UserProfileCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateInput = {
    id?: string
    eventId: string
    userProfileId: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
  }

  export type EventRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneRequiredWithoutEventRegistrationsNestedInput
    userProfile?: UserProfileUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventRegistrationCreateManyInput = {
    id?: string
    eventId: string
    userProfileId: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
  }

  export type EventRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalProgramCreateInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutMedicalProgramsInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutMedicalProgramInput
  }

  export type MedicalProgramUncheckedCreateInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdBy: string
    createdAt?: Date | string
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutMedicalProgramInput
  }

  export type MedicalProgramUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutMedicalProgramsNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutMedicalProgramNestedInput
  }

  export type MedicalProgramUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutMedicalProgramNestedInput
  }

  export type MedicalProgramCreateManyInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type MedicalProgramUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalProgramUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramParticipationCreateInput = {
    id?: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
    medicalProgram: MedicalProgramCreateNestedOneWithoutProgramParticipationsInput
    userProfile: UserProfileCreateNestedOneWithoutProgramParticipationsInput
  }

  export type ProgramParticipationUncheckedCreateInput = {
    id?: string
    medicalProgramId: string
    userProfileId: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
  }

  export type ProgramParticipationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    medicalProgram?: MedicalProgramUpdateOneRequiredWithoutProgramParticipationsNestedInput
    userProfile?: UserProfileUpdateOneRequiredWithoutProgramParticipationsNestedInput
  }

  export type ProgramParticipationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalProgramId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramParticipationCreateManyInput = {
    id?: string
    medicalProgramId: string
    userProfileId: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
  }

  export type ProgramParticipationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramParticipationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalProgramId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryCreateInput = {
    id?: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutInquiriesInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateInput = {
    id?: string
    userProfileId: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutInquiriesNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryCreateManyInput = {
    id?: string
    userProfileId: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
  }

  export type InquiryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryResponseCreateInput = {
    id?: string
    message: string
    inquiry: InquiryCreateNestedOneWithoutInquiryResponsesInput
    responder: AccountCreateNestedOneWithoutInquiryResponsesInput
  }

  export type InquiryResponseUncheckedCreateInput = {
    id?: string
    inquiryId: string
    message: string
    respondedBy: string
  }

  export type InquiryResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    inquiry?: InquiryUpdateOneRequiredWithoutInquiryResponsesNestedInput
    responder?: AccountUpdateOneRequiredWithoutInquiryResponsesNestedInput
  }

  export type InquiryResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    respondedBy?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryResponseCreateManyInput = {
    id?: string
    inquiryId: string
    message: string
    respondedBy: string
  }

  export type InquiryResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    respondedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyCreateInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutSurveysInput
    surveyQuestions?: SurveyQuestionCreateNestedManyWithoutSurveyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdBy: string
    createdAt?: Date | string
    surveyQuestions?: SurveyQuestionUncheckedCreateNestedManyWithoutSurveyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutSurveysNestedInput
    surveyQuestions?: SurveyQuestionUpdateManyWithoutSurveyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUncheckedUpdateManyWithoutSurveyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyCreateManyInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type SurveyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionCreateInput = {
    id?: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
    survey: SurveyCreateNestedOneWithoutSurveyQuestionsInput
    surveyAnswers?: SurveyAnswerCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateInput = {
    id?: string
    surveyId: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
    surveyAnswers?: SurveyAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    survey?: SurveyUpdateOneRequiredWithoutSurveyQuestionsNestedInput
    surveyAnswers?: SurveyAnswerUpdateManyWithoutSurveyQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    surveyAnswers?: SurveyAnswerUncheckedUpdateManyWithoutSurveyQuestionNestedInput
  }

  export type SurveyQuestionCreateManyInput = {
    id?: string
    surveyId: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
  }

  export type SurveyQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type SurveyQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type SurveyResponseCreateInput = {
    id?: string
    ipAddress?: string | null
    submittedAt?: Date | string
    survey: SurveyCreateNestedOneWithoutSurveyResponsesInput
    userProfile: UserProfileCreateNestedOneWithoutSurveyResponsesInput
    surveyAnswers?: SurveyAnswerCreateNestedManyWithoutSurveyResponseInput
  }

  export type SurveyResponseUncheckedCreateInput = {
    id?: string
    surveyId: string
    userProfileId: string
    ipAddress?: string | null
    submittedAt?: Date | string
    surveyAnswers?: SurveyAnswerUncheckedCreateNestedManyWithoutSurveyResponseInput
  }

  export type SurveyResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutSurveyResponsesNestedInput
    userProfile?: UserProfileUpdateOneRequiredWithoutSurveyResponsesNestedInput
    surveyAnswers?: SurveyAnswerUpdateManyWithoutSurveyResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyAnswers?: SurveyAnswerUncheckedUpdateManyWithoutSurveyResponseNestedInput
  }

  export type SurveyResponseCreateManyInput = {
    id?: string
    surveyId: string
    userProfileId: string
    ipAddress?: string | null
    submittedAt?: Date | string
  }

  export type SurveyResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyAnswerCreateInput = {
    id?: string
    answer: string
    surveyResponse: SurveyResponseCreateNestedOneWithoutSurveyAnswersInput
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyAnswersInput
  }

  export type SurveyAnswerUncheckedCreateInput = {
    id?: string
    surveyResponseId: string
    surveyQuestionId: string
    answer: string
  }

  export type SurveyAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    surveyResponse?: SurveyResponseUpdateOneRequiredWithoutSurveyAnswersNestedInput
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyAnswersNestedInput
  }

  export type SurveyAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyResponseId?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyAnswerCreateManyInput = {
    id?: string
    surveyResponseId: string
    surveyQuestionId: string
    answer: string
  }

  export type SurveyAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyResponseId?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsReportCreateInput = {
    id?: string
    reportName: string
    reportType: string
    dataFilters: JsonNullValueInput | InputJsonValue
    reportData: JsonNullValueInput | InputJsonValue
    reportPeriodStart: Date | string
    reportPeriodEnd: Date | string
    generator: AccountCreateNestedOneWithoutAnalyticsReportsInput
  }

  export type AnalyticsReportUncheckedCreateInput = {
    id?: string
    reportName: string
    reportType: string
    dataFilters: JsonNullValueInput | InputJsonValue
    reportData: JsonNullValueInput | InputJsonValue
    reportPeriodStart: Date | string
    reportPeriodEnd: Date | string
    generatedBy: string
  }

  export type AnalyticsReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    dataFilters?: JsonNullValueInput | InputJsonValue
    reportData?: JsonNullValueInput | InputJsonValue
    reportPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reportPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    generator?: AccountUpdateOneRequiredWithoutAnalyticsReportsNestedInput
  }

  export type AnalyticsReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    dataFilters?: JsonNullValueInput | InputJsonValue
    reportData?: JsonNullValueInput | InputJsonValue
    reportPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reportPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsReportCreateManyInput = {
    id?: string
    reportName: string
    reportType: string
    dataFilters: JsonNullValueInput | InputJsonValue
    reportData: JsonNullValueInput | InputJsonValue
    reportPeriodStart: Date | string
    reportPeriodEnd: Date | string
    generatedBy: string
  }

  export type AnalyticsReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    dataFilters?: JsonNullValueInput | InputJsonValue
    reportData?: JsonNullValueInput | InputJsonValue
    reportPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reportPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    dataFilters?: JsonNullValueInput | InputJsonValue
    reportData?: JsonNullValueInput | InputJsonValue
    reportPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reportPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
  }

  export type PredictionModelCreateInput = {
    id?: string
    modelName: string
    modelType: string
    modelParameters: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    lastTrained?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutPredictionModelsInput
  }

  export type PredictionModelUncheckedCreateInput = {
    id?: string
    modelName: string
    modelType: string
    modelParameters: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    lastTrained?: Date | string | null
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
  }

  export type PredictionModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    modelParameters?: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTrained?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutPredictionModelsNestedInput
  }

  export type PredictionModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    modelParameters?: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTrained?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionModelCreateManyInput = {
    id?: string
    modelName: string
    modelType: string
    modelParameters: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    lastTrained?: Date | string | null
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
  }

  export type PredictionModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    modelParameters?: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTrained?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    modelParameters?: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTrained?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    user: AccountCreateNestedOneWithoutSystemLogsInput
  }

  export type SystemLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SystemLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: AccountUpdateOneRequiredWithoutSystemLogsNestedInput
  }

  export type SystemLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SystemLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type HealthWorkerListRelationFilter = {
    every?: HealthWorkerWhereInput
    some?: HealthWorkerWhereInput
    none?: HealthWorkerWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type SurveyListRelationFilter = {
    every?: SurveyWhereInput
    some?: SurveyWhereInput
    none?: SurveyWhereInput
  }

  export type InquiryResponseListRelationFilter = {
    every?: InquiryResponseWhereInput
    some?: InquiryResponseWhereInput
    none?: InquiryResponseWhereInput
  }

  export type AnalyticsReportListRelationFilter = {
    every?: AnalyticsReportWhereInput
    some?: AnalyticsReportWhereInput
    none?: AnalyticsReportWhereInput
  }

  export type PredictionModelListRelationFilter = {
    every?: PredictionModelWhereInput
    some?: PredictionModelWhereInput
    none?: PredictionModelWhereInput
  }

  export type SystemLogListRelationFilter = {
    every?: SystemLogWhereInput
    some?: SystemLogWhereInput
    none?: SystemLogWhereInput
  }

  export type MedicalProgramListRelationFilter = {
    every?: MedicalProgramWhereInput
    some?: MedicalProgramWhereInput
    none?: MedicalProgramWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type HealthWorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PredictionModelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalProgramOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelevanceInput = {
    fields: AccountOrderByRelevanceFieldEnum | AccountOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePictureUrl?: SortOrder
    emailVerified?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePictureUrl?: SortOrder
    emailVerified?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profilePictureUrl?: SortOrder
    emailVerified?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type FamilyRecordListRelationFilter = {
    every?: FamilyRecordWhereInput
    some?: FamilyRecordWhereInput
    none?: FamilyRecordWhereInput
  }

  export type FamilyMemberListRelationFilter = {
    every?: FamilyMemberWhereInput
    some?: FamilyMemberWhereInput
    none?: FamilyMemberWhereInput
  }

  export type MaternalHealthListRelationFilter = {
    every?: MaternalHealthWhereInput
    some?: MaternalHealthWhereInput
    none?: MaternalHealthWhereInput
  }

  export type BirthInformationListRelationFilter = {
    every?: BirthInformationWhereInput
    some?: BirthInformationWhereInput
    none?: BirthInformationWhereInput
  }

  export type ImmunizationEventListRelationFilter = {
    every?: ImmunizationEventWhereInput
    some?: ImmunizationEventWhereInput
    none?: ImmunizationEventWhereInput
  }

  export type VitalSignsListRelationFilter = {
    every?: VitalSignsWhereInput
    some?: VitalSignsWhereInput
    none?: VitalSignsWhereInput
  }

  export type AnthropometricMeasurementListRelationFilter = {
    every?: AnthropometricMeasurementWhereInput
    some?: AnthropometricMeasurementWhereInput
    none?: AnthropometricMeasurementWhereInput
  }

  export type GrowthTrackingListRelationFilter = {
    every?: GrowthTrackingWhereInput
    some?: GrowthTrackingWhereInput
    none?: GrowthTrackingWhereInput
  }

  export type NCDRiskAssessmentListRelationFilter = {
    every?: NCDRiskAssessmentWhereInput
    some?: NCDRiskAssessmentWhereInput
    none?: NCDRiskAssessmentWhereInput
  }

  export type VisitRecordListRelationFilter = {
    every?: VisitRecordWhereInput
    some?: VisitRecordWhereInput
    none?: VisitRecordWhereInput
  }

  export type HealthEducationListRelationFilter = {
    every?: HealthEducationWhereInput
    some?: HealthEducationWhereInput
    none?: HealthEducationWhereInput
  }

  export type NutritionalCounselingListRelationFilter = {
    every?: NutritionalCounselingWhereInput
    some?: NutritionalCounselingWhereInput
    none?: NutritionalCounselingWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type ImmunizationReminderListRelationFilter = {
    every?: ImmunizationReminderWhereInput
    some?: ImmunizationReminderWhereInput
    none?: ImmunizationReminderWhereInput
  }

  export type TestReminderListRelationFilter = {
    every?: TestReminderWhereInput
    some?: TestReminderWhereInput
    none?: TestReminderWhereInput
  }

  export type VirtualCheckupListRelationFilter = {
    every?: VirtualCheckupWhereInput
    some?: VirtualCheckupWhereInput
    none?: VirtualCheckupWhereInput
  }

  export type EventRegistrationListRelationFilter = {
    every?: EventRegistrationWhereInput
    some?: EventRegistrationWhereInput
    none?: EventRegistrationWhereInput
  }

  export type ProgramParticipationListRelationFilter = {
    every?: ProgramParticipationWhereInput
    some?: ProgramParticipationWhereInput
    none?: ProgramParticipationWhereInput
  }

  export type InquiryListRelationFilter = {
    every?: InquiryWhereInput
    some?: InquiryWhereInput
    none?: InquiryWhereInput
  }

  export type SurveyResponseListRelationFilter = {
    every?: SurveyResponseWhereInput
    some?: SurveyResponseWhereInput
    none?: SurveyResponseWhereInput
  }

  export type FamilyRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FamilyMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaternalHealthOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BirthInformationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImmunizationEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitalSignsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnthropometricMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GrowthTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NCDRiskAssessmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VisitRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthEducationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NutritionalCounselingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImmunizationReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VirtualCheckupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramParticipationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileOrderByRelevanceInput = {
    fields: UserProfileOrderByRelevanceFieldEnum | UserProfileOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    religion?: SortOrder
    civilStatus?: SortOrder
    occupation?: SortOrder
    educationLevel?: SortOrder
    philhealthNumber?: SortOrder
    nhtsStatus?: SortOrder
    personWithDisability?: SortOrder
    indigenousPeople?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    religion?: SortOrder
    civilStatus?: SortOrder
    occupation?: SortOrder
    educationLevel?: SortOrder
    philhealthNumber?: SortOrder
    nhtsStatus?: SortOrder
    personWithDisability?: SortOrder
    indigenousPeople?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    fullName?: SortOrder
    dateOfBirth?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    religion?: SortOrder
    civilStatus?: SortOrder
    occupation?: SortOrder
    educationLevel?: SortOrder
    philhealthNumber?: SortOrder
    nhtsStatus?: SortOrder
    personWithDisability?: SortOrder
    indigenousPeople?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type HealthWorkerOrderByRelevanceInput = {
    fields: HealthWorkerOrderByRelevanceFieldEnum | HealthWorkerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HealthWorkerCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    signature?: SortOrder
    isActive?: SortOrder
  }

  export type HealthWorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    signature?: SortOrder
    isActive?: SortOrder
  }

  export type HealthWorkerMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    role?: SortOrder
    contactNumber?: SortOrder
    signature?: SortOrder
    isActive?: SortOrder
  }

  export type UserProfileScalarRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type FamilyHealthHistoryNullableScalarRelationFilter = {
    is?: FamilyHealthHistoryWhereInput | null
    isNot?: FamilyHealthHistoryWhereInput | null
  }

  export type FamilyRecordOrderByRelevanceInput = {
    fields: FamilyRecordOrderByRelevanceFieldEnum | FamilyRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FamilyRecordCountOrderByAggregateInput = {
    id?: SortOrder
    familyId?: SortOrder
    headOfFamilyId?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    smsConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    familyId?: SortOrder
    headOfFamilyId?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    smsConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyRecordMinOrderByAggregateInput = {
    id?: SortOrder
    familyId?: SortOrder
    headOfFamilyId?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    smsConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamilyRecordScalarRelationFilter = {
    is?: FamilyRecordWhereInput
    isNot?: FamilyRecordWhereInput
  }

  export type FamilyMemberOrderByRelevanceInput = {
    fields: FamilyMemberOrderByRelevanceFieldEnum | FamilyMemberOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FamilyMemberCountOrderByAggregateInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    userProfileId?: SortOrder
    memberName?: SortOrder
    relationship?: SortOrder
    gender?: SortOrder
    age?: SortOrder
    occupation?: SortOrder
    civilStatus?: SortOrder
  }

  export type FamilyMemberAvgOrderByAggregateInput = {
    age?: SortOrder
  }

  export type FamilyMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    userProfileId?: SortOrder
    memberName?: SortOrder
    relationship?: SortOrder
    gender?: SortOrder
    age?: SortOrder
    occupation?: SortOrder
    civilStatus?: SortOrder
  }

  export type FamilyMemberMinOrderByAggregateInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    userProfileId?: SortOrder
    memberName?: SortOrder
    relationship?: SortOrder
    gender?: SortOrder
    age?: SortOrder
    occupation?: SortOrder
    civilStatus?: SortOrder
  }

  export type FamilyMemberSumOrderByAggregateInput = {
    age?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FamilyHealthHistoryOrderByRelevanceInput = {
    fields: FamilyHealthHistoryOrderByRelevanceFieldEnum | FamilyHealthHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FamilyHealthHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    geneticConditions?: SortOrder
    chronicDiseases?: SortOrder
    recordedDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type FamilyHealthHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    recordedDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type FamilyHealthHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    familyRecordId?: SortOrder
    recordedDate?: SortOrder
    recordedBy?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PrenatalVisitListRelationFilter = {
    every?: PrenatalVisitWhereInput
    some?: PrenatalVisitWhereInput
    none?: PrenatalVisitWhereInput
  }

  export type PrenatalVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaternalHealthOrderByRelevanceInput = {
    fields: MaternalHealthOrderByRelevanceFieldEnum | MaternalHealthOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MaternalHealthCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    mothersName?: SortOrder
    mothersAge?: SortOrder
    mothersBirthday?: SortOrder
    mothersMaidenName?: SortOrder
    mothersReligion?: SortOrder
    mothersEducation?: SortOrder
    mothersOccupation?: SortOrder
    numberOfChildren?: SortOrder
    gravidaPara?: SortOrder
    menarcheAge?: SortOrder
    lastMenstrualPeriod?: SortOrder
    expectedDeliveryDate?: SortOrder
    tetanusToxoidStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type MaternalHealthAvgOrderByAggregateInput = {
    mothersAge?: SortOrder
    numberOfChildren?: SortOrder
    menarcheAge?: SortOrder
  }

  export type MaternalHealthMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    mothersName?: SortOrder
    mothersAge?: SortOrder
    mothersBirthday?: SortOrder
    mothersMaidenName?: SortOrder
    mothersReligion?: SortOrder
    mothersEducation?: SortOrder
    mothersOccupation?: SortOrder
    numberOfChildren?: SortOrder
    gravidaPara?: SortOrder
    menarcheAge?: SortOrder
    lastMenstrualPeriod?: SortOrder
    expectedDeliveryDate?: SortOrder
    tetanusToxoidStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type MaternalHealthMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    mothersName?: SortOrder
    mothersAge?: SortOrder
    mothersBirthday?: SortOrder
    mothersMaidenName?: SortOrder
    mothersReligion?: SortOrder
    mothersEducation?: SortOrder
    mothersOccupation?: SortOrder
    numberOfChildren?: SortOrder
    gravidaPara?: SortOrder
    menarcheAge?: SortOrder
    lastMenstrualPeriod?: SortOrder
    expectedDeliveryDate?: SortOrder
    tetanusToxoidStatus?: SortOrder
    createdAt?: SortOrder
  }

  export type MaternalHealthSumOrderByAggregateInput = {
    mothersAge?: SortOrder
    numberOfChildren?: SortOrder
    menarcheAge?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MaternalHealthScalarRelationFilter = {
    is?: MaternalHealthWhereInput
    isNot?: MaternalHealthWhereInput
  }

  export type LaboratoryTestListRelationFilter = {
    every?: LaboratoryTestWhereInput
    some?: LaboratoryTestWhereInput
    none?: LaboratoryTestWhereInput
  }

  export type InterventionListRelationFilter = {
    every?: InterventionWhereInput
    some?: InterventionWhereInput
    none?: InterventionWhereInput
  }

  export type LaboratoryTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterventionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrenatalVisitOrderByRelevanceInput = {
    fields: PrenatalVisitOrderByRelevanceFieldEnum | PrenatalVisitOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PrenatalVisitCountOrderByAggregateInput = {
    id?: SortOrder
    maternalHealthId?: SortOrder
    visitDate?: SortOrder
    gestationalAgeWeeks?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bloodPressure?: SortOrder
    fundalHeightCm?: SortOrder
    fetalHeartTone?: SortOrder
    nextVisitDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type PrenatalVisitAvgOrderByAggregateInput = {
    gestationalAgeWeeks?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    fundalHeightCm?: SortOrder
  }

  export type PrenatalVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    maternalHealthId?: SortOrder
    visitDate?: SortOrder
    gestationalAgeWeeks?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bloodPressure?: SortOrder
    fundalHeightCm?: SortOrder
    fetalHeartTone?: SortOrder
    nextVisitDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type PrenatalVisitMinOrderByAggregateInput = {
    id?: SortOrder
    maternalHealthId?: SortOrder
    visitDate?: SortOrder
    gestationalAgeWeeks?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    bloodPressure?: SortOrder
    fundalHeightCm?: SortOrder
    fetalHeartTone?: SortOrder
    nextVisitDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type PrenatalVisitSumOrderByAggregateInput = {
    gestationalAgeWeeks?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    fundalHeightCm?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PrenatalVisitScalarRelationFilter = {
    is?: PrenatalVisitWhereInput
    isNot?: PrenatalVisitWhereInput
  }

  export type LaboratoryTestOrderByRelevanceInput = {
    fields: LaboratoryTestOrderByRelevanceFieldEnum | LaboratoryTestOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LaboratoryTestCountOrderByAggregateInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    userProfileId?: SortOrder
    testDate?: SortOrder
    testType?: SortOrder
    testCompleted?: SortOrder
    recordedBy?: SortOrder
  }

  export type LaboratoryTestMaxOrderByAggregateInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    userProfileId?: SortOrder
    testDate?: SortOrder
    testType?: SortOrder
    testCompleted?: SortOrder
    recordedBy?: SortOrder
  }

  export type LaboratoryTestMinOrderByAggregateInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    userProfileId?: SortOrder
    testDate?: SortOrder
    testType?: SortOrder
    testCompleted?: SortOrder
    recordedBy?: SortOrder
  }

  export type InterventionOrderByRelevanceInput = {
    fields: InterventionOrderByRelevanceFieldEnum | InterventionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InterventionCountOrderByAggregateInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    tetanusToxoidDose?: SortOrder
    tetanusToxoidLocation?: SortOrder
    tetanusToxoidDate?: SortOrder
    ironSupplementation?: SortOrder
    ironMedication?: SortOrder
    vitaminSupplementation?: SortOrder
    vitaminMedication?: SortOrder
    calciumSupplementation?: SortOrder
    calciumMedication?: SortOrder
    healthEducationTopics?: SortOrder
  }

  export type InterventionMaxOrderByAggregateInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    tetanusToxoidDose?: SortOrder
    tetanusToxoidLocation?: SortOrder
    tetanusToxoidDate?: SortOrder
    ironSupplementation?: SortOrder
    ironMedication?: SortOrder
    vitaminSupplementation?: SortOrder
    vitaminMedication?: SortOrder
    calciumSupplementation?: SortOrder
    calciumMedication?: SortOrder
  }

  export type InterventionMinOrderByAggregateInput = {
    id?: SortOrder
    prenatalVisitId?: SortOrder
    tetanusToxoidDose?: SortOrder
    tetanusToxoidLocation?: SortOrder
    tetanusToxoidDate?: SortOrder
    ironSupplementation?: SortOrder
    ironMedication?: SortOrder
    vitaminSupplementation?: SortOrder
    vitaminMedication?: SortOrder
    calciumSupplementation?: SortOrder
    calciumMedication?: SortOrder
  }

  export type BirthInformationOrderByRelevanceInput = {
    fields: BirthInformationOrderByRelevanceFieldEnum | BirthInformationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BirthInformationCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    maternalHealthId?: SortOrder
    placeOfDelivery?: SortOrder
    timeOfDelivery?: SortOrder
    deliveryType?: SortOrder
    birthWeightKg?: SortOrder
    birthHeightCm?: SortOrder
    newbornScreeningDate?: SortOrder
    newbornScreeningCompleted?: SortOrder
    feedingType?: SortOrder
    createdAt?: SortOrder
    recordedBy?: SortOrder
  }

  export type BirthInformationAvgOrderByAggregateInput = {
    birthWeightKg?: SortOrder
    birthHeightCm?: SortOrder
  }

  export type BirthInformationMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    maternalHealthId?: SortOrder
    placeOfDelivery?: SortOrder
    timeOfDelivery?: SortOrder
    deliveryType?: SortOrder
    birthWeightKg?: SortOrder
    birthHeightCm?: SortOrder
    newbornScreeningDate?: SortOrder
    newbornScreeningCompleted?: SortOrder
    feedingType?: SortOrder
    createdAt?: SortOrder
    recordedBy?: SortOrder
  }

  export type BirthInformationMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    maternalHealthId?: SortOrder
    placeOfDelivery?: SortOrder
    timeOfDelivery?: SortOrder
    deliveryType?: SortOrder
    birthWeightKg?: SortOrder
    birthHeightCm?: SortOrder
    newbornScreeningDate?: SortOrder
    newbornScreeningCompleted?: SortOrder
    feedingType?: SortOrder
    createdAt?: SortOrder
    recordedBy?: SortOrder
  }

  export type BirthInformationSumOrderByAggregateInput = {
    birthWeightKg?: SortOrder
    birthHeightCm?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VaccineGivenListRelationFilter = {
    every?: VaccineGivenWhereInput
    some?: VaccineGivenWhereInput
    none?: VaccineGivenWhereInput
  }

  export type VaccineGivenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImmunizationEventOrderByRelevanceInput = {
    fields: ImmunizationEventOrderByRelevanceFieldEnum | ImmunizationEventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImmunizationEventCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    temperatureCelsius?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    adverseReactions?: SortOrder
    healthWorkerName?: SortOrder
    healthWorkerSignature?: SortOrder
    nextFollowupDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type ImmunizationEventAvgOrderByAggregateInput = {
    temperatureCelsius?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
  }

  export type ImmunizationEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    temperatureCelsius?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    adverseReactions?: SortOrder
    healthWorkerName?: SortOrder
    healthWorkerSignature?: SortOrder
    nextFollowupDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type ImmunizationEventMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    temperatureCelsius?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    adverseReactions?: SortOrder
    healthWorkerName?: SortOrder
    healthWorkerSignature?: SortOrder
    nextFollowupDate?: SortOrder
    recordedBy?: SortOrder
  }

  export type ImmunizationEventSumOrderByAggregateInput = {
    temperatureCelsius?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ImmunizationEventScalarRelationFilter = {
    is?: ImmunizationEventWhereInput
    isNot?: ImmunizationEventWhereInput
  }

  export type VaccineGivenOrderByRelevanceInput = {
    fields: VaccineGivenOrderByRelevanceFieldEnum | VaccineGivenOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VaccineGivenCountOrderByAggregateInput = {
    id?: SortOrder
    immunizationEventId?: SortOrder
    vaccineName?: SortOrder
    doseNumber?: SortOrder
    dateGiven?: SortOrder
    lotNumber?: SortOrder
  }

  export type VaccineGivenMaxOrderByAggregateInput = {
    id?: SortOrder
    immunizationEventId?: SortOrder
    vaccineName?: SortOrder
    doseNumber?: SortOrder
    dateGiven?: SortOrder
    lotNumber?: SortOrder
  }

  export type VaccineGivenMinOrderByAggregateInput = {
    id?: SortOrder
    immunizationEventId?: SortOrder
    vaccineName?: SortOrder
    doseNumber?: SortOrder
    dateGiven?: SortOrder
    lotNumber?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type VitalSignsOrderByRelevanceInput = {
    fields: VitalSignsOrderByRelevanceFieldEnum | VitalSignsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VitalSignsCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recordDate?: SortOrder
    bloodPressure?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    temperatureCelsius?: SortOrder
    pulseRate?: SortOrder
    recordedBy?: SortOrder
  }

  export type VitalSignsAvgOrderByAggregateInput = {
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    temperatureCelsius?: SortOrder
    pulseRate?: SortOrder
  }

  export type VitalSignsMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recordDate?: SortOrder
    bloodPressure?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    temperatureCelsius?: SortOrder
    pulseRate?: SortOrder
    recordedBy?: SortOrder
  }

  export type VitalSignsMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recordDate?: SortOrder
    bloodPressure?: SortOrder
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    temperatureCelsius?: SortOrder
    pulseRate?: SortOrder
    recordedBy?: SortOrder
  }

  export type VitalSignsSumOrderByAggregateInput = {
    heartRate?: SortOrder
    respiratoryRate?: SortOrder
    temperatureCelsius?: SortOrder
    pulseRate?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AnthropometricMeasurementOrderByRelevanceInput = {
    fields: AnthropometricMeasurementOrderByRelevanceFieldEnum | AnthropometricMeasurementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnthropometricMeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    measurementDate?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    headCircumferenceCm?: SortOrder
    waistCircumferenceCm?: SortOrder
    bmi?: SortOrder
    recordedBy?: SortOrder
  }

  export type AnthropometricMeasurementAvgOrderByAggregateInput = {
    weightKg?: SortOrder
    heightCm?: SortOrder
    headCircumferenceCm?: SortOrder
    waistCircumferenceCm?: SortOrder
    bmi?: SortOrder
  }

  export type AnthropometricMeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    measurementDate?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    headCircumferenceCm?: SortOrder
    waistCircumferenceCm?: SortOrder
    bmi?: SortOrder
    recordedBy?: SortOrder
  }

  export type AnthropometricMeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    measurementDate?: SortOrder
    weightKg?: SortOrder
    heightCm?: SortOrder
    headCircumferenceCm?: SortOrder
    waistCircumferenceCm?: SortOrder
    bmi?: SortOrder
    recordedBy?: SortOrder
  }

  export type AnthropometricMeasurementSumOrderByAggregateInput = {
    weightKg?: SortOrder
    heightCm?: SortOrder
    headCircumferenceCm?: SortOrder
    waistCircumferenceCm?: SortOrder
    bmi?: SortOrder
  }

  export type GrowthTrackingOrderByRelevanceInput = {
    fields: GrowthTrackingOrderByRelevanceFieldEnum | GrowthTrackingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type GrowthTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    trackingDate?: SortOrder
    weightForAge?: SortOrder
    heightForAge?: SortOrder
    weightForHeight?: SortOrder
    recordedBy?: SortOrder
  }

  export type GrowthTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    trackingDate?: SortOrder
    weightForAge?: SortOrder
    heightForAge?: SortOrder
    weightForHeight?: SortOrder
    recordedBy?: SortOrder
  }

  export type GrowthTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    trackingDate?: SortOrder
    weightForAge?: SortOrder
    heightForAge?: SortOrder
    weightForHeight?: SortOrder
    recordedBy?: SortOrder
  }

  export type NCDRiskAssessmentOrderByRelevanceInput = {
    fields: NCDRiskAssessmentOrderByRelevanceFieldEnum | NCDRiskAssessmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NCDRiskAssessmentCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    assessmentDate?: SortOrder
    smokingStatus?: SortOrder
    alcoholIntake?: SortOrder
    physicalActivity?: SortOrder
    fruitVegetableIntake?: SortOrder
    familyHistoryDiabetes?: SortOrder
    familyHistoryHypertension?: SortOrder
    familyHistoryHeartDisease?: SortOrder
    familyHistoryStroke?: SortOrder
    screeningCompleted?: SortOrder
    followUpNeeded?: SortOrder
    lifestyleModifications?: SortOrder
    healthEducationReceived?: SortOrder
    recordedBy?: SortOrder
  }

  export type NCDRiskAssessmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    assessmentDate?: SortOrder
    smokingStatus?: SortOrder
    alcoholIntake?: SortOrder
    physicalActivity?: SortOrder
    fruitVegetableIntake?: SortOrder
    familyHistoryDiabetes?: SortOrder
    familyHistoryHypertension?: SortOrder
    familyHistoryHeartDisease?: SortOrder
    familyHistoryStroke?: SortOrder
    screeningCompleted?: SortOrder
    followUpNeeded?: SortOrder
    recordedBy?: SortOrder
  }

  export type NCDRiskAssessmentMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    assessmentDate?: SortOrder
    smokingStatus?: SortOrder
    alcoholIntake?: SortOrder
    physicalActivity?: SortOrder
    fruitVegetableIntake?: SortOrder
    familyHistoryDiabetes?: SortOrder
    familyHistoryHypertension?: SortOrder
    familyHistoryHeartDisease?: SortOrder
    familyHistoryStroke?: SortOrder
    screeningCompleted?: SortOrder
    followUpNeeded?: SortOrder
    recordedBy?: SortOrder
  }

  export type VisitRecordOrderByRelevanceInput = {
    fields: VisitRecordOrderByRelevanceFieldEnum | VisitRecordOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VisitRecordCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    visitFrequency?: SortOrder
    referred?: SortOrder
    facilityName?: SortOrder
    referralReason?: SortOrder
    recordedBy?: SortOrder
  }

  export type VisitRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    visitFrequency?: SortOrder
    referred?: SortOrder
    facilityName?: SortOrder
    referralReason?: SortOrder
    recordedBy?: SortOrder
  }

  export type VisitRecordMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    visitFrequency?: SortOrder
    referred?: SortOrder
    facilityName?: SortOrder
    referralReason?: SortOrder
    recordedBy?: SortOrder
  }

  export type HealthEducationOrderByRelevanceInput = {
    fields: HealthEducationOrderByRelevanceFieldEnum | HealthEducationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type HealthEducationCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    topicsCovered?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
  }

  export type HealthEducationMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
  }

  export type HealthEducationMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
  }

  export type NutritionalCounselingOrderByRelevanceInput = {
    fields: NutritionalCounselingOrderByRelevanceFieldEnum | NutritionalCounselingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type NutritionalCounselingCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recommendations?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
  }

  export type NutritionalCounselingMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recommendations?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
  }

  export type NutritionalCounselingMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    recommendations?: SortOrder
    dateProvided?: SortOrder
    providedBy?: SortOrder
  }

  export type ReferralOrderByRelevanceInput = {
    fields: ReferralOrderByRelevanceFieldEnum | ReferralOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    facilityName?: SortOrder
    reason?: SortOrder
    dateReferred?: SortOrder
    status?: SortOrder
    referredBy?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    facilityName?: SortOrder
    reason?: SortOrder
    dateReferred?: SortOrder
    status?: SortOrder
    referredBy?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    facilityName?: SortOrder
    reason?: SortOrder
    dateReferred?: SortOrder
    status?: SortOrder
    referredBy?: SortOrder
  }

  export type AppointmentOrderByRelevanceInput = {
    fields: AppointmentOrderByRelevanceFieldEnum | AppointmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    nextVisitDate?: SortOrder
    visitType?: SortOrder
    appointmentStatus?: SortOrder
    scheduledBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    nextVisitDate?: SortOrder
    visitType?: SortOrder
    appointmentStatus?: SortOrder
    scheduledBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    nextVisitDate?: SortOrder
    visitType?: SortOrder
    appointmentStatus?: SortOrder
    scheduledBy?: SortOrder
    createdAt?: SortOrder
  }

  export type ImmunizationReminderOrderByRelevanceInput = {
    fields: ImmunizationReminderOrderByRelevanceFieldEnum | ImmunizationReminderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ImmunizationReminderCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    vaccineName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrder
  }

  export type ImmunizationReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    vaccineName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrder
  }

  export type ImmunizationReminderMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    vaccineName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrder
  }

  export type TestReminderOrderByRelevanceInput = {
    fields: TestReminderOrderByRelevanceFieldEnum | TestReminderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type TestReminderCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    testName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrder
  }

  export type TestReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    testName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrder
  }

  export type TestReminderMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    testName?: SortOrder
    dueDate?: SortOrder
    reminderSent?: SortOrder
    sentAt?: SortOrder
  }

  export type HealthWorkerScalarRelationFilter = {
    is?: HealthWorkerWhereInput
    isNot?: HealthWorkerWhereInput
  }

  export type VirtualCheckupNoteListRelationFilter = {
    every?: VirtualCheckupNoteWhereInput
    some?: VirtualCheckupNoteWhereInput
    none?: VirtualCheckupNoteWhereInput
  }

  export type VirtualCheckupNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VirtualCheckupOrderByRelevanceInput = {
    fields: VirtualCheckupOrderByRelevanceFieldEnum | VirtualCheckupOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VirtualCheckupCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    healthWorkerId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    consultationType?: SortOrder
    chiefComplaint?: SortOrder
    notes?: SortOrder
    durationMinutes?: SortOrder
    createdAt?: SortOrder
  }

  export type VirtualCheckupAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type VirtualCheckupMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    healthWorkerId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    consultationType?: SortOrder
    chiefComplaint?: SortOrder
    notes?: SortOrder
    durationMinutes?: SortOrder
    createdAt?: SortOrder
  }

  export type VirtualCheckupMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    healthWorkerId?: SortOrder
    scheduledDate?: SortOrder
    scheduledTime?: SortOrder
    meetingUrl?: SortOrder
    status?: SortOrder
    consultationType?: SortOrder
    chiefComplaint?: SortOrder
    notes?: SortOrder
    durationMinutes?: SortOrder
    createdAt?: SortOrder
  }

  export type VirtualCheckupSumOrderByAggregateInput = {
    durationMinutes?: SortOrder
  }

  export type VirtualCheckupScalarRelationFilter = {
    is?: VirtualCheckupWhereInput
    isNot?: VirtualCheckupWhereInput
  }

  export type VirtualCheckupNoteOrderByRelevanceInput = {
    fields: VirtualCheckupNoteOrderByRelevanceFieldEnum | VirtualCheckupNoteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VirtualCheckupNoteCountOrderByAggregateInput = {
    id?: SortOrder
    virtualCheckupId?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
  }

  export type VirtualCheckupNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    virtualCheckupId?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
  }

  export type VirtualCheckupNoteMinOrderByAggregateInput = {
    id?: SortOrder
    virtualCheckupId?: SortOrder
    note?: SortOrder
    createdBy?: SortOrder
  }

  export type EventOrderByRelevanceInput = {
    fields: EventOrderByRelevanceFieldEnum | EventOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    targetAudience?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    targetAudience?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    eventType?: SortOrder
    eventDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    venue?: SortOrder
    targetAudience?: SortOrder
    maxParticipants?: SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type EventRegistrationOrderByRelevanceInput = {
    fields: EventRegistrationOrderByRelevanceFieldEnum | EventRegistrationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EventRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userProfileId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type EventRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userProfileId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type EventRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userProfileId?: SortOrder
    registrationDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type MedicalProgramOrderByRelevanceInput = {
    fields: MedicalProgramOrderByRelevanceFieldEnum | MedicalProgramOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type MedicalProgramCountOrderByAggregateInput = {
    id?: SortOrder
    programName?: SortOrder
    description?: SortOrder
    programType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    venue?: SortOrder
    targetDemographic?: SortOrder
    targetParticipants?: SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalProgramAvgOrderByAggregateInput = {
    targetParticipants?: SortOrder
  }

  export type MedicalProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    programName?: SortOrder
    description?: SortOrder
    programType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    venue?: SortOrder
    targetDemographic?: SortOrder
    targetParticipants?: SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalProgramMinOrderByAggregateInput = {
    id?: SortOrder
    programName?: SortOrder
    description?: SortOrder
    programType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    venue?: SortOrder
    targetDemographic?: SortOrder
    targetParticipants?: SortOrder
    status?: SortOrder
    bannerImageUrl?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalProgramSumOrderByAggregateInput = {
    targetParticipants?: SortOrder
  }

  export type MedicalProgramScalarRelationFilter = {
    is?: MedicalProgramWhereInput
    isNot?: MedicalProgramWhereInput
  }

  export type ProgramParticipationOrderByRelevanceInput = {
    fields: ProgramParticipationOrderByRelevanceFieldEnum | ProgramParticipationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ProgramParticipationCountOrderByAggregateInput = {
    id?: SortOrder
    medicalProgramId?: SortOrder
    userProfileId?: SortOrder
    participationDate?: SortOrder
    status?: SortOrder
    servicesReceived?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
  }

  export type ProgramParticipationMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalProgramId?: SortOrder
    userProfileId?: SortOrder
    participationDate?: SortOrder
    status?: SortOrder
    servicesReceived?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
  }

  export type ProgramParticipationMinOrderByAggregateInput = {
    id?: SortOrder
    medicalProgramId?: SortOrder
    userProfileId?: SortOrder
    participationDate?: SortOrder
    status?: SortOrder
    servicesReceived?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
  }

  export type InquiryOrderByRelevanceInput = {
    fields: InquiryOrderByRelevanceFieldEnum | InquiryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    userProfileId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type InquiryScalarRelationFilter = {
    is?: InquiryWhereInput
    isNot?: InquiryWhereInput
  }

  export type InquiryResponseOrderByRelevanceInput = {
    fields: InquiryResponseOrderByRelevanceFieldEnum | InquiryResponseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type InquiryResponseCountOrderByAggregateInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    message?: SortOrder
    respondedBy?: SortOrder
  }

  export type InquiryResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    message?: SortOrder
    respondedBy?: SortOrder
  }

  export type InquiryResponseMinOrderByAggregateInput = {
    id?: SortOrder
    inquiryId?: SortOrder
    message?: SortOrder
    respondedBy?: SortOrder
  }

  export type SurveyQuestionListRelationFilter = {
    every?: SurveyQuestionWhereInput
    some?: SurveyQuestionWhereInput
    none?: SurveyQuestionWhereInput
  }

  export type SurveyQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyOrderByRelevanceInput = {
    fields: SurveyOrderByRelevanceFieldEnum | SurveyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SurveyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    surveyType?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    qrCode?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    surveyType?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    qrCode?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    surveyType?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    qrCode?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SurveyScalarRelationFilter = {
    is?: SurveyWhereInput
    isNot?: SurveyWhereInput
  }

  export type SurveyAnswerListRelationFilter = {
    every?: SurveyAnswerWhereInput
    some?: SurveyAnswerWhereInput
    none?: SurveyAnswerWhereInput
  }

  export type SurveyAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurveyQuestionOrderByRelevanceInput = {
    fields: SurveyQuestionOrderByRelevanceFieldEnum | SurveyQuestionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SurveyQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    options?: SortOrder
    isRequired?: SortOrder
    orderIndex?: SortOrder
  }

  export type SurveyQuestionAvgOrderByAggregateInput = {
    orderIndex?: SortOrder
  }

  export type SurveyQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    isRequired?: SortOrder
    orderIndex?: SortOrder
  }

  export type SurveyQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    isRequired?: SortOrder
    orderIndex?: SortOrder
  }

  export type SurveyQuestionSumOrderByAggregateInput = {
    orderIndex?: SortOrder
  }

  export type SurveyResponseOrderByRelevanceInput = {
    fields: SurveyResponseOrderByRelevanceFieldEnum | SurveyResponseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SurveyResponseCountOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userProfileId?: SortOrder
    ipAddress?: SortOrder
    submittedAt?: SortOrder
  }

  export type SurveyResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userProfileId?: SortOrder
    ipAddress?: SortOrder
    submittedAt?: SortOrder
  }

  export type SurveyResponseMinOrderByAggregateInput = {
    id?: SortOrder
    surveyId?: SortOrder
    userProfileId?: SortOrder
    ipAddress?: SortOrder
    submittedAt?: SortOrder
  }

  export type SurveyResponseScalarRelationFilter = {
    is?: SurveyResponseWhereInput
    isNot?: SurveyResponseWhereInput
  }

  export type SurveyQuestionScalarRelationFilter = {
    is?: SurveyQuestionWhereInput
    isNot?: SurveyQuestionWhereInput
  }

  export type SurveyAnswerOrderByRelevanceInput = {
    fields: SurveyAnswerOrderByRelevanceFieldEnum | SurveyAnswerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SurveyAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    surveyResponseId?: SortOrder
    surveyQuestionId?: SortOrder
    answer?: SortOrder
  }

  export type SurveyAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    surveyResponseId?: SortOrder
    surveyQuestionId?: SortOrder
    answer?: SortOrder
  }

  export type SurveyAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    surveyResponseId?: SortOrder
    surveyQuestionId?: SortOrder
    answer?: SortOrder
  }

  export type AnalyticsReportOrderByRelevanceInput = {
    fields: AnalyticsReportOrderByRelevanceFieldEnum | AnalyticsReportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type AnalyticsReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportName?: SortOrder
    reportType?: SortOrder
    dataFilters?: SortOrder
    reportData?: SortOrder
    reportPeriodStart?: SortOrder
    reportPeriodEnd?: SortOrder
    generatedBy?: SortOrder
  }

  export type AnalyticsReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportName?: SortOrder
    reportType?: SortOrder
    reportPeriodStart?: SortOrder
    reportPeriodEnd?: SortOrder
    generatedBy?: SortOrder
  }

  export type AnalyticsReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportName?: SortOrder
    reportType?: SortOrder
    reportPeriodStart?: SortOrder
    reportPeriodEnd?: SortOrder
    generatedBy?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PredictionModelOrderByRelevanceInput = {
    fields: PredictionModelOrderByRelevanceFieldEnum | PredictionModelOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PredictionModelCountOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelType?: SortOrder
    modelParameters?: SortOrder
    predictionResults?: SortOrder
    accuracy?: SortOrder
    lastTrained?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PredictionModelAvgOrderByAggregateInput = {
    accuracy?: SortOrder
  }

  export type PredictionModelMaxOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelType?: SortOrder
    accuracy?: SortOrder
    lastTrained?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PredictionModelMinOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    modelType?: SortOrder
    accuracy?: SortOrder
    lastTrained?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PredictionModelSumOrderByAggregateInput = {
    accuracy?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SystemLogOrderByRelevanceInput = {
    fields: SystemLogOrderByRelevanceFieldEnum | SystemLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldData?: SortOrder
    newData?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SystemLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type SystemLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type UserProfileCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserProfileCreateWithoutAccountInput, UserProfileUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAccountInput
    connect?: UserProfileWhereUniqueInput
  }

  export type HealthWorkerCreateNestedManyWithoutAccountInput = {
    create?: XOR<HealthWorkerCreateWithoutAccountInput, HealthWorkerUncheckedCreateWithoutAccountInput> | HealthWorkerCreateWithoutAccountInput[] | HealthWorkerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutAccountInput | HealthWorkerCreateOrConnectWithoutAccountInput[]
    createMany?: HealthWorkerCreateManyAccountInputEnvelope
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type SurveyCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SurveyCreateWithoutCreatorInput, SurveyUncheckedCreateWithoutCreatorInput> | SurveyCreateWithoutCreatorInput[] | SurveyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutCreatorInput | SurveyCreateOrConnectWithoutCreatorInput[]
    createMany?: SurveyCreateManyCreatorInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type InquiryResponseCreateNestedManyWithoutResponderInput = {
    create?: XOR<InquiryResponseCreateWithoutResponderInput, InquiryResponseUncheckedCreateWithoutResponderInput> | InquiryResponseCreateWithoutResponderInput[] | InquiryResponseUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutResponderInput | InquiryResponseCreateOrConnectWithoutResponderInput[]
    createMany?: InquiryResponseCreateManyResponderInputEnvelope
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
  }

  export type AnalyticsReportCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<AnalyticsReportCreateWithoutGeneratorInput, AnalyticsReportUncheckedCreateWithoutGeneratorInput> | AnalyticsReportCreateWithoutGeneratorInput[] | AnalyticsReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutGeneratorInput | AnalyticsReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: AnalyticsReportCreateManyGeneratorInputEnvelope
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
  }

  export type PredictionModelCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PredictionModelCreateWithoutCreatorInput, PredictionModelUncheckedCreateWithoutCreatorInput> | PredictionModelCreateWithoutCreatorInput[] | PredictionModelUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PredictionModelCreateOrConnectWithoutCreatorInput | PredictionModelCreateOrConnectWithoutCreatorInput[]
    createMany?: PredictionModelCreateManyCreatorInputEnvelope
    connect?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
  }

  export type SystemLogCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type MedicalProgramCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MedicalProgramCreateWithoutCreatorInput, MedicalProgramUncheckedCreateWithoutCreatorInput> | MedicalProgramCreateWithoutCreatorInput[] | MedicalProgramUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MedicalProgramCreateOrConnectWithoutCreatorInput | MedicalProgramCreateOrConnectWithoutCreatorInput[]
    createMany?: MedicalProgramCreateManyCreatorInputEnvelope
    connect?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserProfileCreateWithoutAccountInput, UserProfileUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAccountInput
    connect?: UserProfileWhereUniqueInput
  }

  export type HealthWorkerUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<HealthWorkerCreateWithoutAccountInput, HealthWorkerUncheckedCreateWithoutAccountInput> | HealthWorkerCreateWithoutAccountInput[] | HealthWorkerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutAccountInput | HealthWorkerCreateOrConnectWithoutAccountInput[]
    createMany?: HealthWorkerCreateManyAccountInputEnvelope
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type SurveyUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SurveyCreateWithoutCreatorInput, SurveyUncheckedCreateWithoutCreatorInput> | SurveyCreateWithoutCreatorInput[] | SurveyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutCreatorInput | SurveyCreateOrConnectWithoutCreatorInput[]
    createMany?: SurveyCreateManyCreatorInputEnvelope
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
  }

  export type InquiryResponseUncheckedCreateNestedManyWithoutResponderInput = {
    create?: XOR<InquiryResponseCreateWithoutResponderInput, InquiryResponseUncheckedCreateWithoutResponderInput> | InquiryResponseCreateWithoutResponderInput[] | InquiryResponseUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutResponderInput | InquiryResponseCreateOrConnectWithoutResponderInput[]
    createMany?: InquiryResponseCreateManyResponderInputEnvelope
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
  }

  export type AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<AnalyticsReportCreateWithoutGeneratorInput, AnalyticsReportUncheckedCreateWithoutGeneratorInput> | AnalyticsReportCreateWithoutGeneratorInput[] | AnalyticsReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutGeneratorInput | AnalyticsReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: AnalyticsReportCreateManyGeneratorInputEnvelope
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
  }

  export type PredictionModelUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PredictionModelCreateWithoutCreatorInput, PredictionModelUncheckedCreateWithoutCreatorInput> | PredictionModelCreateWithoutCreatorInput[] | PredictionModelUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PredictionModelCreateOrConnectWithoutCreatorInput | PredictionModelCreateOrConnectWithoutCreatorInput[]
    createMany?: PredictionModelCreateManyCreatorInputEnvelope
    connect?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
  }

  export type SystemLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
  }

  export type MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MedicalProgramCreateWithoutCreatorInput, MedicalProgramUncheckedCreateWithoutCreatorInput> | MedicalProgramCreateWithoutCreatorInput[] | MedicalProgramUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MedicalProgramCreateOrConnectWithoutCreatorInput | MedicalProgramCreateOrConnectWithoutCreatorInput[]
    createMany?: MedicalProgramCreateManyCreatorInputEnvelope
    connect?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserProfileUpdateOneWithoutAccountNestedInput = {
    create?: XOR<UserProfileCreateWithoutAccountInput, UserProfileUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAccountInput
    upsert?: UserProfileUpsertWithoutAccountInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutAccountInput, UserProfileUpdateWithoutAccountInput>, UserProfileUncheckedUpdateWithoutAccountInput>
  }

  export type HealthWorkerUpdateManyWithoutAccountNestedInput = {
    create?: XOR<HealthWorkerCreateWithoutAccountInput, HealthWorkerUncheckedCreateWithoutAccountInput> | HealthWorkerCreateWithoutAccountInput[] | HealthWorkerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutAccountInput | HealthWorkerCreateOrConnectWithoutAccountInput[]
    upsert?: HealthWorkerUpsertWithWhereUniqueWithoutAccountInput | HealthWorkerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: HealthWorkerCreateManyAccountInputEnvelope
    set?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    disconnect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    delete?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    update?: HealthWorkerUpdateWithWhereUniqueWithoutAccountInput | HealthWorkerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: HealthWorkerUpdateManyWithWhereWithoutAccountInput | HealthWorkerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type SurveyUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SurveyCreateWithoutCreatorInput, SurveyUncheckedCreateWithoutCreatorInput> | SurveyCreateWithoutCreatorInput[] | SurveyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutCreatorInput | SurveyCreateOrConnectWithoutCreatorInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutCreatorInput | SurveyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SurveyCreateManyCreatorInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutCreatorInput | SurveyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutCreatorInput | SurveyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type InquiryResponseUpdateManyWithoutResponderNestedInput = {
    create?: XOR<InquiryResponseCreateWithoutResponderInput, InquiryResponseUncheckedCreateWithoutResponderInput> | InquiryResponseCreateWithoutResponderInput[] | InquiryResponseUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutResponderInput | InquiryResponseCreateOrConnectWithoutResponderInput[]
    upsert?: InquiryResponseUpsertWithWhereUniqueWithoutResponderInput | InquiryResponseUpsertWithWhereUniqueWithoutResponderInput[]
    createMany?: InquiryResponseCreateManyResponderInputEnvelope
    set?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    disconnect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    delete?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    update?: InquiryResponseUpdateWithWhereUniqueWithoutResponderInput | InquiryResponseUpdateWithWhereUniqueWithoutResponderInput[]
    updateMany?: InquiryResponseUpdateManyWithWhereWithoutResponderInput | InquiryResponseUpdateManyWithWhereWithoutResponderInput[]
    deleteMany?: InquiryResponseScalarWhereInput | InquiryResponseScalarWhereInput[]
  }

  export type AnalyticsReportUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<AnalyticsReportCreateWithoutGeneratorInput, AnalyticsReportUncheckedCreateWithoutGeneratorInput> | AnalyticsReportCreateWithoutGeneratorInput[] | AnalyticsReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutGeneratorInput | AnalyticsReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: AnalyticsReportUpsertWithWhereUniqueWithoutGeneratorInput | AnalyticsReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: AnalyticsReportCreateManyGeneratorInputEnvelope
    set?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    disconnect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    delete?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    update?: AnalyticsReportUpdateWithWhereUniqueWithoutGeneratorInput | AnalyticsReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: AnalyticsReportUpdateManyWithWhereWithoutGeneratorInput | AnalyticsReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
  }

  export type PredictionModelUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PredictionModelCreateWithoutCreatorInput, PredictionModelUncheckedCreateWithoutCreatorInput> | PredictionModelCreateWithoutCreatorInput[] | PredictionModelUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PredictionModelCreateOrConnectWithoutCreatorInput | PredictionModelCreateOrConnectWithoutCreatorInput[]
    upsert?: PredictionModelUpsertWithWhereUniqueWithoutCreatorInput | PredictionModelUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PredictionModelCreateManyCreatorInputEnvelope
    set?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    disconnect?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    delete?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    connect?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    update?: PredictionModelUpdateWithWhereUniqueWithoutCreatorInput | PredictionModelUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PredictionModelUpdateManyWithWhereWithoutCreatorInput | PredictionModelUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PredictionModelScalarWhereInput | PredictionModelScalarWhereInput[]
  }

  export type SystemLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type MedicalProgramUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MedicalProgramCreateWithoutCreatorInput, MedicalProgramUncheckedCreateWithoutCreatorInput> | MedicalProgramCreateWithoutCreatorInput[] | MedicalProgramUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MedicalProgramCreateOrConnectWithoutCreatorInput | MedicalProgramCreateOrConnectWithoutCreatorInput[]
    upsert?: MedicalProgramUpsertWithWhereUniqueWithoutCreatorInput | MedicalProgramUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MedicalProgramCreateManyCreatorInputEnvelope
    set?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    disconnect?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    delete?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    connect?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    update?: MedicalProgramUpdateWithWhereUniqueWithoutCreatorInput | MedicalProgramUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MedicalProgramUpdateManyWithWhereWithoutCreatorInput | MedicalProgramUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MedicalProgramScalarWhereInput | MedicalProgramScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<UserProfileCreateWithoutAccountInput, UserProfileUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAccountInput
    upsert?: UserProfileUpsertWithoutAccountInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutAccountInput, UserProfileUpdateWithoutAccountInput>, UserProfileUncheckedUpdateWithoutAccountInput>
  }

  export type HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<HealthWorkerCreateWithoutAccountInput, HealthWorkerUncheckedCreateWithoutAccountInput> | HealthWorkerCreateWithoutAccountInput[] | HealthWorkerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutAccountInput | HealthWorkerCreateOrConnectWithoutAccountInput[]
    upsert?: HealthWorkerUpsertWithWhereUniqueWithoutAccountInput | HealthWorkerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: HealthWorkerCreateManyAccountInputEnvelope
    set?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    disconnect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    delete?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    connect?: HealthWorkerWhereUniqueInput | HealthWorkerWhereUniqueInput[]
    update?: HealthWorkerUpdateWithWhereUniqueWithoutAccountInput | HealthWorkerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: HealthWorkerUpdateManyWithWhereWithoutAccountInput | HealthWorkerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type SurveyUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SurveyCreateWithoutCreatorInput, SurveyUncheckedCreateWithoutCreatorInput> | SurveyCreateWithoutCreatorInput[] | SurveyUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SurveyCreateOrConnectWithoutCreatorInput | SurveyCreateOrConnectWithoutCreatorInput[]
    upsert?: SurveyUpsertWithWhereUniqueWithoutCreatorInput | SurveyUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SurveyCreateManyCreatorInputEnvelope
    set?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    disconnect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    delete?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    connect?: SurveyWhereUniqueInput | SurveyWhereUniqueInput[]
    update?: SurveyUpdateWithWhereUniqueWithoutCreatorInput | SurveyUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SurveyUpdateManyWithWhereWithoutCreatorInput | SurveyUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
  }

  export type InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput = {
    create?: XOR<InquiryResponseCreateWithoutResponderInput, InquiryResponseUncheckedCreateWithoutResponderInput> | InquiryResponseCreateWithoutResponderInput[] | InquiryResponseUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutResponderInput | InquiryResponseCreateOrConnectWithoutResponderInput[]
    upsert?: InquiryResponseUpsertWithWhereUniqueWithoutResponderInput | InquiryResponseUpsertWithWhereUniqueWithoutResponderInput[]
    createMany?: InquiryResponseCreateManyResponderInputEnvelope
    set?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    disconnect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    delete?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    update?: InquiryResponseUpdateWithWhereUniqueWithoutResponderInput | InquiryResponseUpdateWithWhereUniqueWithoutResponderInput[]
    updateMany?: InquiryResponseUpdateManyWithWhereWithoutResponderInput | InquiryResponseUpdateManyWithWhereWithoutResponderInput[]
    deleteMany?: InquiryResponseScalarWhereInput | InquiryResponseScalarWhereInput[]
  }

  export type AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<AnalyticsReportCreateWithoutGeneratorInput, AnalyticsReportUncheckedCreateWithoutGeneratorInput> | AnalyticsReportCreateWithoutGeneratorInput[] | AnalyticsReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutGeneratorInput | AnalyticsReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: AnalyticsReportUpsertWithWhereUniqueWithoutGeneratorInput | AnalyticsReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: AnalyticsReportCreateManyGeneratorInputEnvelope
    set?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    disconnect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    delete?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    update?: AnalyticsReportUpdateWithWhereUniqueWithoutGeneratorInput | AnalyticsReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: AnalyticsReportUpdateManyWithWhereWithoutGeneratorInput | AnalyticsReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
  }

  export type PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PredictionModelCreateWithoutCreatorInput, PredictionModelUncheckedCreateWithoutCreatorInput> | PredictionModelCreateWithoutCreatorInput[] | PredictionModelUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PredictionModelCreateOrConnectWithoutCreatorInput | PredictionModelCreateOrConnectWithoutCreatorInput[]
    upsert?: PredictionModelUpsertWithWhereUniqueWithoutCreatorInput | PredictionModelUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PredictionModelCreateManyCreatorInputEnvelope
    set?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    disconnect?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    delete?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    connect?: PredictionModelWhereUniqueInput | PredictionModelWhereUniqueInput[]
    update?: PredictionModelUpdateWithWhereUniqueWithoutCreatorInput | PredictionModelUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PredictionModelUpdateManyWithWhereWithoutCreatorInput | PredictionModelUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PredictionModelScalarWhereInput | PredictionModelScalarWhereInput[]
  }

  export type SystemLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput> | SystemLogCreateWithoutUserInput[] | SystemLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SystemLogCreateOrConnectWithoutUserInput | SystemLogCreateOrConnectWithoutUserInput[]
    upsert?: SystemLogUpsertWithWhereUniqueWithoutUserInput | SystemLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SystemLogCreateManyUserInputEnvelope
    set?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    disconnect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    delete?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    connect?: SystemLogWhereUniqueInput | SystemLogWhereUniqueInput[]
    update?: SystemLogUpdateWithWhereUniqueWithoutUserInput | SystemLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SystemLogUpdateManyWithWhereWithoutUserInput | SystemLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
  }

  export type MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MedicalProgramCreateWithoutCreatorInput, MedicalProgramUncheckedCreateWithoutCreatorInput> | MedicalProgramCreateWithoutCreatorInput[] | MedicalProgramUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MedicalProgramCreateOrConnectWithoutCreatorInput | MedicalProgramCreateOrConnectWithoutCreatorInput[]
    upsert?: MedicalProgramUpsertWithWhereUniqueWithoutCreatorInput | MedicalProgramUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MedicalProgramCreateManyCreatorInputEnvelope
    set?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    disconnect?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    delete?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    connect?: MedicalProgramWhereUniqueInput | MedicalProgramWhereUniqueInput[]
    update?: MedicalProgramUpdateWithWhereUniqueWithoutCreatorInput | MedicalProgramUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MedicalProgramUpdateManyWithWhereWithoutCreatorInput | MedicalProgramUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MedicalProgramScalarWhereInput | MedicalProgramScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutUserProfileInput = {
    create?: XOR<AccountCreateWithoutUserProfileInput, AccountUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserProfileInput
    connect?: AccountWhereUniqueInput
  }

  export type FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput = {
    create?: XOR<FamilyRecordCreateWithoutHeadOfFamilyInput, FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput> | FamilyRecordCreateWithoutHeadOfFamilyInput[] | FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput | FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput[]
    createMany?: FamilyRecordCreateManyHeadOfFamilyInputEnvelope
    connect?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
  }

  export type FamilyMemberCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<FamilyMemberCreateWithoutUserProfileInput, FamilyMemberUncheckedCreateWithoutUserProfileInput> | FamilyMemberCreateWithoutUserProfileInput[] | FamilyMemberUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserProfileInput | FamilyMemberCreateOrConnectWithoutUserProfileInput[]
    createMany?: FamilyMemberCreateManyUserProfileInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type MaternalHealthCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<MaternalHealthCreateWithoutUserProfileInput, MaternalHealthUncheckedCreateWithoutUserProfileInput> | MaternalHealthCreateWithoutUserProfileInput[] | MaternalHealthUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutUserProfileInput | MaternalHealthCreateOrConnectWithoutUserProfileInput[]
    createMany?: MaternalHealthCreateManyUserProfileInputEnvelope
    connect?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
  }

  export type BirthInformationCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<BirthInformationCreateWithoutUserProfileInput, BirthInformationUncheckedCreateWithoutUserProfileInput> | BirthInformationCreateWithoutUserProfileInput[] | BirthInformationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutUserProfileInput | BirthInformationCreateOrConnectWithoutUserProfileInput[]
    createMany?: BirthInformationCreateManyUserProfileInputEnvelope
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
  }

  export type ImmunizationEventCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ImmunizationEventCreateWithoutUserProfileInput, ImmunizationEventUncheckedCreateWithoutUserProfileInput> | ImmunizationEventCreateWithoutUserProfileInput[] | ImmunizationEventUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationEventCreateOrConnectWithoutUserProfileInput | ImmunizationEventCreateOrConnectWithoutUserProfileInput[]
    createMany?: ImmunizationEventCreateManyUserProfileInputEnvelope
    connect?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
  }

  export type VitalSignsCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<VitalSignsCreateWithoutUserProfileInput, VitalSignsUncheckedCreateWithoutUserProfileInput> | VitalSignsCreateWithoutUserProfileInput[] | VitalSignsUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutUserProfileInput | VitalSignsCreateOrConnectWithoutUserProfileInput[]
    createMany?: VitalSignsCreateManyUserProfileInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<AnthropometricMeasurementCreateWithoutUserProfileInput, AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput> | AnthropometricMeasurementCreateWithoutUserProfileInput[] | AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput | AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput[]
    createMany?: AnthropometricMeasurementCreateManyUserProfileInputEnvelope
    connect?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
  }

  export type GrowthTrackingCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<GrowthTrackingCreateWithoutUserProfileInput, GrowthTrackingUncheckedCreateWithoutUserProfileInput> | GrowthTrackingCreateWithoutUserProfileInput[] | GrowthTrackingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: GrowthTrackingCreateOrConnectWithoutUserProfileInput | GrowthTrackingCreateOrConnectWithoutUserProfileInput[]
    createMany?: GrowthTrackingCreateManyUserProfileInputEnvelope
    connect?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
  }

  export type NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<NCDRiskAssessmentCreateWithoutUserProfileInput, NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput> | NCDRiskAssessmentCreateWithoutUserProfileInput[] | NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput | NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput[]
    createMany?: NCDRiskAssessmentCreateManyUserProfileInputEnvelope
    connect?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
  }

  export type VisitRecordCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<VisitRecordCreateWithoutUserProfileInput, VisitRecordUncheckedCreateWithoutUserProfileInput> | VisitRecordCreateWithoutUserProfileInput[] | VisitRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VisitRecordCreateOrConnectWithoutUserProfileInput | VisitRecordCreateOrConnectWithoutUserProfileInput[]
    createMany?: VisitRecordCreateManyUserProfileInputEnvelope
    connect?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
  }

  export type HealthEducationCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<HealthEducationCreateWithoutUserProfileInput, HealthEducationUncheckedCreateWithoutUserProfileInput> | HealthEducationCreateWithoutUserProfileInput[] | HealthEducationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: HealthEducationCreateOrConnectWithoutUserProfileInput | HealthEducationCreateOrConnectWithoutUserProfileInput[]
    createMany?: HealthEducationCreateManyUserProfileInputEnvelope
    connect?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
  }

  export type NutritionalCounselingCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<NutritionalCounselingCreateWithoutUserProfileInput, NutritionalCounselingUncheckedCreateWithoutUserProfileInput> | NutritionalCounselingCreateWithoutUserProfileInput[] | NutritionalCounselingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NutritionalCounselingCreateOrConnectWithoutUserProfileInput | NutritionalCounselingCreateOrConnectWithoutUserProfileInput[]
    createMany?: NutritionalCounselingCreateManyUserProfileInputEnvelope
    connect?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ReferralCreateWithoutUserProfileInput, ReferralUncheckedCreateWithoutUserProfileInput> | ReferralCreateWithoutUserProfileInput[] | ReferralUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserProfileInput | ReferralCreateOrConnectWithoutUserProfileInput[]
    createMany?: ReferralCreateManyUserProfileInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<AppointmentCreateWithoutUserProfileInput, AppointmentUncheckedCreateWithoutUserProfileInput> | AppointmentCreateWithoutUserProfileInput[] | AppointmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserProfileInput | AppointmentCreateOrConnectWithoutUserProfileInput[]
    createMany?: AppointmentCreateManyUserProfileInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ImmunizationReminderCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ImmunizationReminderCreateWithoutUserProfileInput, ImmunizationReminderUncheckedCreateWithoutUserProfileInput> | ImmunizationReminderCreateWithoutUserProfileInput[] | ImmunizationReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationReminderCreateOrConnectWithoutUserProfileInput | ImmunizationReminderCreateOrConnectWithoutUserProfileInput[]
    createMany?: ImmunizationReminderCreateManyUserProfileInputEnvelope
    connect?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
  }

  export type TestReminderCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<TestReminderCreateWithoutUserProfileInput, TestReminderUncheckedCreateWithoutUserProfileInput> | TestReminderCreateWithoutUserProfileInput[] | TestReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: TestReminderCreateOrConnectWithoutUserProfileInput | TestReminderCreateOrConnectWithoutUserProfileInput[]
    createMany?: TestReminderCreateManyUserProfileInputEnvelope
    connect?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
  }

  export type VirtualCheckupCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<VirtualCheckupCreateWithoutUserProfileInput, VirtualCheckupUncheckedCreateWithoutUserProfileInput> | VirtualCheckupCreateWithoutUserProfileInput[] | VirtualCheckupUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutUserProfileInput | VirtualCheckupCreateOrConnectWithoutUserProfileInput[]
    createMany?: VirtualCheckupCreateManyUserProfileInputEnvelope
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
  }

  export type EventRegistrationCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<EventRegistrationCreateWithoutUserProfileInput, EventRegistrationUncheckedCreateWithoutUserProfileInput> | EventRegistrationCreateWithoutUserProfileInput[] | EventRegistrationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserProfileInput | EventRegistrationCreateOrConnectWithoutUserProfileInput[]
    createMany?: EventRegistrationCreateManyUserProfileInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type ProgramParticipationCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ProgramParticipationCreateWithoutUserProfileInput, ProgramParticipationUncheckedCreateWithoutUserProfileInput> | ProgramParticipationCreateWithoutUserProfileInput[] | ProgramParticipationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutUserProfileInput | ProgramParticipationCreateOrConnectWithoutUserProfileInput[]
    createMany?: ProgramParticipationCreateManyUserProfileInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<InquiryCreateWithoutUserProfileInput, InquiryUncheckedCreateWithoutUserProfileInput> | InquiryCreateWithoutUserProfileInput[] | InquiryUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserProfileInput | InquiryCreateOrConnectWithoutUserProfileInput[]
    createMany?: InquiryCreateManyUserProfileInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type SurveyResponseCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<SurveyResponseCreateWithoutUserProfileInput, SurveyResponseUncheckedCreateWithoutUserProfileInput> | SurveyResponseCreateWithoutUserProfileInput[] | SurveyResponseUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserProfileInput | SurveyResponseCreateOrConnectWithoutUserProfileInput[]
    createMany?: SurveyResponseCreateManyUserProfileInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput = {
    create?: XOR<FamilyRecordCreateWithoutHeadOfFamilyInput, FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput> | FamilyRecordCreateWithoutHeadOfFamilyInput[] | FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput | FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput[]
    createMany?: FamilyRecordCreateManyHeadOfFamilyInputEnvelope
    connect?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
  }

  export type FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<FamilyMemberCreateWithoutUserProfileInput, FamilyMemberUncheckedCreateWithoutUserProfileInput> | FamilyMemberCreateWithoutUserProfileInput[] | FamilyMemberUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserProfileInput | FamilyMemberCreateOrConnectWithoutUserProfileInput[]
    createMany?: FamilyMemberCreateManyUserProfileInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<MaternalHealthCreateWithoutUserProfileInput, MaternalHealthUncheckedCreateWithoutUserProfileInput> | MaternalHealthCreateWithoutUserProfileInput[] | MaternalHealthUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutUserProfileInput | MaternalHealthCreateOrConnectWithoutUserProfileInput[]
    createMany?: MaternalHealthCreateManyUserProfileInputEnvelope
    connect?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
  }

  export type BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<BirthInformationCreateWithoutUserProfileInput, BirthInformationUncheckedCreateWithoutUserProfileInput> | BirthInformationCreateWithoutUserProfileInput[] | BirthInformationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutUserProfileInput | BirthInformationCreateOrConnectWithoutUserProfileInput[]
    createMany?: BirthInformationCreateManyUserProfileInputEnvelope
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
  }

  export type ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ImmunizationEventCreateWithoutUserProfileInput, ImmunizationEventUncheckedCreateWithoutUserProfileInput> | ImmunizationEventCreateWithoutUserProfileInput[] | ImmunizationEventUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationEventCreateOrConnectWithoutUserProfileInput | ImmunizationEventCreateOrConnectWithoutUserProfileInput[]
    createMany?: ImmunizationEventCreateManyUserProfileInputEnvelope
    connect?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
  }

  export type VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<VitalSignsCreateWithoutUserProfileInput, VitalSignsUncheckedCreateWithoutUserProfileInput> | VitalSignsCreateWithoutUserProfileInput[] | VitalSignsUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutUserProfileInput | VitalSignsCreateOrConnectWithoutUserProfileInput[]
    createMany?: VitalSignsCreateManyUserProfileInputEnvelope
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
  }

  export type AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<AnthropometricMeasurementCreateWithoutUserProfileInput, AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput> | AnthropometricMeasurementCreateWithoutUserProfileInput[] | AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput | AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput[]
    createMany?: AnthropometricMeasurementCreateManyUserProfileInputEnvelope
    connect?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
  }

  export type GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<GrowthTrackingCreateWithoutUserProfileInput, GrowthTrackingUncheckedCreateWithoutUserProfileInput> | GrowthTrackingCreateWithoutUserProfileInput[] | GrowthTrackingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: GrowthTrackingCreateOrConnectWithoutUserProfileInput | GrowthTrackingCreateOrConnectWithoutUserProfileInput[]
    createMany?: GrowthTrackingCreateManyUserProfileInputEnvelope
    connect?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
  }

  export type NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<NCDRiskAssessmentCreateWithoutUserProfileInput, NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput> | NCDRiskAssessmentCreateWithoutUserProfileInput[] | NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput | NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput[]
    createMany?: NCDRiskAssessmentCreateManyUserProfileInputEnvelope
    connect?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
  }

  export type VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<VisitRecordCreateWithoutUserProfileInput, VisitRecordUncheckedCreateWithoutUserProfileInput> | VisitRecordCreateWithoutUserProfileInput[] | VisitRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VisitRecordCreateOrConnectWithoutUserProfileInput | VisitRecordCreateOrConnectWithoutUserProfileInput[]
    createMany?: VisitRecordCreateManyUserProfileInputEnvelope
    connect?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
  }

  export type HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<HealthEducationCreateWithoutUserProfileInput, HealthEducationUncheckedCreateWithoutUserProfileInput> | HealthEducationCreateWithoutUserProfileInput[] | HealthEducationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: HealthEducationCreateOrConnectWithoutUserProfileInput | HealthEducationCreateOrConnectWithoutUserProfileInput[]
    createMany?: HealthEducationCreateManyUserProfileInputEnvelope
    connect?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
  }

  export type NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<NutritionalCounselingCreateWithoutUserProfileInput, NutritionalCounselingUncheckedCreateWithoutUserProfileInput> | NutritionalCounselingCreateWithoutUserProfileInput[] | NutritionalCounselingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NutritionalCounselingCreateOrConnectWithoutUserProfileInput | NutritionalCounselingCreateOrConnectWithoutUserProfileInput[]
    createMany?: NutritionalCounselingCreateManyUserProfileInputEnvelope
    connect?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ReferralCreateWithoutUserProfileInput, ReferralUncheckedCreateWithoutUserProfileInput> | ReferralCreateWithoutUserProfileInput[] | ReferralUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserProfileInput | ReferralCreateOrConnectWithoutUserProfileInput[]
    createMany?: ReferralCreateManyUserProfileInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<AppointmentCreateWithoutUserProfileInput, AppointmentUncheckedCreateWithoutUserProfileInput> | AppointmentCreateWithoutUserProfileInput[] | AppointmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserProfileInput | AppointmentCreateOrConnectWithoutUserProfileInput[]
    createMany?: AppointmentCreateManyUserProfileInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ImmunizationReminderCreateWithoutUserProfileInput, ImmunizationReminderUncheckedCreateWithoutUserProfileInput> | ImmunizationReminderCreateWithoutUserProfileInput[] | ImmunizationReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationReminderCreateOrConnectWithoutUserProfileInput | ImmunizationReminderCreateOrConnectWithoutUserProfileInput[]
    createMany?: ImmunizationReminderCreateManyUserProfileInputEnvelope
    connect?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
  }

  export type TestReminderUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<TestReminderCreateWithoutUserProfileInput, TestReminderUncheckedCreateWithoutUserProfileInput> | TestReminderCreateWithoutUserProfileInput[] | TestReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: TestReminderCreateOrConnectWithoutUserProfileInput | TestReminderCreateOrConnectWithoutUserProfileInput[]
    createMany?: TestReminderCreateManyUserProfileInputEnvelope
    connect?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
  }

  export type VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<VirtualCheckupCreateWithoutUserProfileInput, VirtualCheckupUncheckedCreateWithoutUserProfileInput> | VirtualCheckupCreateWithoutUserProfileInput[] | VirtualCheckupUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutUserProfileInput | VirtualCheckupCreateOrConnectWithoutUserProfileInput[]
    createMany?: VirtualCheckupCreateManyUserProfileInputEnvelope
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<EventRegistrationCreateWithoutUserProfileInput, EventRegistrationUncheckedCreateWithoutUserProfileInput> | EventRegistrationCreateWithoutUserProfileInput[] | EventRegistrationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserProfileInput | EventRegistrationCreateOrConnectWithoutUserProfileInput[]
    createMany?: EventRegistrationCreateManyUserProfileInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<ProgramParticipationCreateWithoutUserProfileInput, ProgramParticipationUncheckedCreateWithoutUserProfileInput> | ProgramParticipationCreateWithoutUserProfileInput[] | ProgramParticipationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutUserProfileInput | ProgramParticipationCreateOrConnectWithoutUserProfileInput[]
    createMany?: ProgramParticipationCreateManyUserProfileInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<InquiryCreateWithoutUserProfileInput, InquiryUncheckedCreateWithoutUserProfileInput> | InquiryCreateWithoutUserProfileInput[] | InquiryUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserProfileInput | InquiryCreateOrConnectWithoutUserProfileInput[]
    createMany?: InquiryCreateManyUserProfileInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput = {
    create?: XOR<SurveyResponseCreateWithoutUserProfileInput, SurveyResponseUncheckedCreateWithoutUserProfileInput> | SurveyResponseCreateWithoutUserProfileInput[] | SurveyResponseUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserProfileInput | SurveyResponseCreateOrConnectWithoutUserProfileInput[]
    createMany?: SurveyResponseCreateManyUserProfileInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AccountUpdateOneRequiredWithoutUserProfileNestedInput = {
    create?: XOR<AccountCreateWithoutUserProfileInput, AccountUncheckedCreateWithoutUserProfileInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserProfileInput
    upsert?: AccountUpsertWithoutUserProfileInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserProfileInput, AccountUpdateWithoutUserProfileInput>, AccountUncheckedUpdateWithoutUserProfileInput>
  }

  export type FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput = {
    create?: XOR<FamilyRecordCreateWithoutHeadOfFamilyInput, FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput> | FamilyRecordCreateWithoutHeadOfFamilyInput[] | FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput | FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput[]
    upsert?: FamilyRecordUpsertWithWhereUniqueWithoutHeadOfFamilyInput | FamilyRecordUpsertWithWhereUniqueWithoutHeadOfFamilyInput[]
    createMany?: FamilyRecordCreateManyHeadOfFamilyInputEnvelope
    set?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    disconnect?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    delete?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    connect?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    update?: FamilyRecordUpdateWithWhereUniqueWithoutHeadOfFamilyInput | FamilyRecordUpdateWithWhereUniqueWithoutHeadOfFamilyInput[]
    updateMany?: FamilyRecordUpdateManyWithWhereWithoutHeadOfFamilyInput | FamilyRecordUpdateManyWithWhereWithoutHeadOfFamilyInput[]
    deleteMany?: FamilyRecordScalarWhereInput | FamilyRecordScalarWhereInput[]
  }

  export type FamilyMemberUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutUserProfileInput, FamilyMemberUncheckedCreateWithoutUserProfileInput> | FamilyMemberCreateWithoutUserProfileInput[] | FamilyMemberUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserProfileInput | FamilyMemberCreateOrConnectWithoutUserProfileInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutUserProfileInput | FamilyMemberUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: FamilyMemberCreateManyUserProfileInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutUserProfileInput | FamilyMemberUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutUserProfileInput | FamilyMemberUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type MaternalHealthUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<MaternalHealthCreateWithoutUserProfileInput, MaternalHealthUncheckedCreateWithoutUserProfileInput> | MaternalHealthCreateWithoutUserProfileInput[] | MaternalHealthUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutUserProfileInput | MaternalHealthCreateOrConnectWithoutUserProfileInput[]
    upsert?: MaternalHealthUpsertWithWhereUniqueWithoutUserProfileInput | MaternalHealthUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: MaternalHealthCreateManyUserProfileInputEnvelope
    set?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    disconnect?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    delete?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    connect?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    update?: MaternalHealthUpdateWithWhereUniqueWithoutUserProfileInput | MaternalHealthUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: MaternalHealthUpdateManyWithWhereWithoutUserProfileInput | MaternalHealthUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: MaternalHealthScalarWhereInput | MaternalHealthScalarWhereInput[]
  }

  export type BirthInformationUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<BirthInformationCreateWithoutUserProfileInput, BirthInformationUncheckedCreateWithoutUserProfileInput> | BirthInformationCreateWithoutUserProfileInput[] | BirthInformationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutUserProfileInput | BirthInformationCreateOrConnectWithoutUserProfileInput[]
    upsert?: BirthInformationUpsertWithWhereUniqueWithoutUserProfileInput | BirthInformationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: BirthInformationCreateManyUserProfileInputEnvelope
    set?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    disconnect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    delete?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    update?: BirthInformationUpdateWithWhereUniqueWithoutUserProfileInput | BirthInformationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: BirthInformationUpdateManyWithWhereWithoutUserProfileInput | BirthInformationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: BirthInformationScalarWhereInput | BirthInformationScalarWhereInput[]
  }

  export type ImmunizationEventUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ImmunizationEventCreateWithoutUserProfileInput, ImmunizationEventUncheckedCreateWithoutUserProfileInput> | ImmunizationEventCreateWithoutUserProfileInput[] | ImmunizationEventUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationEventCreateOrConnectWithoutUserProfileInput | ImmunizationEventCreateOrConnectWithoutUserProfileInput[]
    upsert?: ImmunizationEventUpsertWithWhereUniqueWithoutUserProfileInput | ImmunizationEventUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ImmunizationEventCreateManyUserProfileInputEnvelope
    set?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    disconnect?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    delete?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    connect?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    update?: ImmunizationEventUpdateWithWhereUniqueWithoutUserProfileInput | ImmunizationEventUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ImmunizationEventUpdateManyWithWhereWithoutUserProfileInput | ImmunizationEventUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ImmunizationEventScalarWhereInput | ImmunizationEventScalarWhereInput[]
  }

  export type VitalSignsUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<VitalSignsCreateWithoutUserProfileInput, VitalSignsUncheckedCreateWithoutUserProfileInput> | VitalSignsCreateWithoutUserProfileInput[] | VitalSignsUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutUserProfileInput | VitalSignsCreateOrConnectWithoutUserProfileInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutUserProfileInput | VitalSignsUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: VitalSignsCreateManyUserProfileInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutUserProfileInput | VitalSignsUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutUserProfileInput | VitalSignsUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<AnthropometricMeasurementCreateWithoutUserProfileInput, AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput> | AnthropometricMeasurementCreateWithoutUserProfileInput[] | AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput | AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput[]
    upsert?: AnthropometricMeasurementUpsertWithWhereUniqueWithoutUserProfileInput | AnthropometricMeasurementUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: AnthropometricMeasurementCreateManyUserProfileInputEnvelope
    set?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    disconnect?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    delete?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    connect?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    update?: AnthropometricMeasurementUpdateWithWhereUniqueWithoutUserProfileInput | AnthropometricMeasurementUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: AnthropometricMeasurementUpdateManyWithWhereWithoutUserProfileInput | AnthropometricMeasurementUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: AnthropometricMeasurementScalarWhereInput | AnthropometricMeasurementScalarWhereInput[]
  }

  export type GrowthTrackingUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<GrowthTrackingCreateWithoutUserProfileInput, GrowthTrackingUncheckedCreateWithoutUserProfileInput> | GrowthTrackingCreateWithoutUserProfileInput[] | GrowthTrackingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: GrowthTrackingCreateOrConnectWithoutUserProfileInput | GrowthTrackingCreateOrConnectWithoutUserProfileInput[]
    upsert?: GrowthTrackingUpsertWithWhereUniqueWithoutUserProfileInput | GrowthTrackingUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: GrowthTrackingCreateManyUserProfileInputEnvelope
    set?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    disconnect?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    delete?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    connect?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    update?: GrowthTrackingUpdateWithWhereUniqueWithoutUserProfileInput | GrowthTrackingUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: GrowthTrackingUpdateManyWithWhereWithoutUserProfileInput | GrowthTrackingUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: GrowthTrackingScalarWhereInput | GrowthTrackingScalarWhereInput[]
  }

  export type NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<NCDRiskAssessmentCreateWithoutUserProfileInput, NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput> | NCDRiskAssessmentCreateWithoutUserProfileInput[] | NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput | NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput[]
    upsert?: NCDRiskAssessmentUpsertWithWhereUniqueWithoutUserProfileInput | NCDRiskAssessmentUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: NCDRiskAssessmentCreateManyUserProfileInputEnvelope
    set?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    disconnect?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    delete?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    connect?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    update?: NCDRiskAssessmentUpdateWithWhereUniqueWithoutUserProfileInput | NCDRiskAssessmentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: NCDRiskAssessmentUpdateManyWithWhereWithoutUserProfileInput | NCDRiskAssessmentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: NCDRiskAssessmentScalarWhereInput | NCDRiskAssessmentScalarWhereInput[]
  }

  export type VisitRecordUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<VisitRecordCreateWithoutUserProfileInput, VisitRecordUncheckedCreateWithoutUserProfileInput> | VisitRecordCreateWithoutUserProfileInput[] | VisitRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VisitRecordCreateOrConnectWithoutUserProfileInput | VisitRecordCreateOrConnectWithoutUserProfileInput[]
    upsert?: VisitRecordUpsertWithWhereUniqueWithoutUserProfileInput | VisitRecordUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: VisitRecordCreateManyUserProfileInputEnvelope
    set?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    disconnect?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    delete?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    connect?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    update?: VisitRecordUpdateWithWhereUniqueWithoutUserProfileInput | VisitRecordUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: VisitRecordUpdateManyWithWhereWithoutUserProfileInput | VisitRecordUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: VisitRecordScalarWhereInput | VisitRecordScalarWhereInput[]
  }

  export type HealthEducationUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<HealthEducationCreateWithoutUserProfileInput, HealthEducationUncheckedCreateWithoutUserProfileInput> | HealthEducationCreateWithoutUserProfileInput[] | HealthEducationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: HealthEducationCreateOrConnectWithoutUserProfileInput | HealthEducationCreateOrConnectWithoutUserProfileInput[]
    upsert?: HealthEducationUpsertWithWhereUniqueWithoutUserProfileInput | HealthEducationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: HealthEducationCreateManyUserProfileInputEnvelope
    set?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    disconnect?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    delete?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    connect?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    update?: HealthEducationUpdateWithWhereUniqueWithoutUserProfileInput | HealthEducationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: HealthEducationUpdateManyWithWhereWithoutUserProfileInput | HealthEducationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: HealthEducationScalarWhereInput | HealthEducationScalarWhereInput[]
  }

  export type NutritionalCounselingUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<NutritionalCounselingCreateWithoutUserProfileInput, NutritionalCounselingUncheckedCreateWithoutUserProfileInput> | NutritionalCounselingCreateWithoutUserProfileInput[] | NutritionalCounselingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NutritionalCounselingCreateOrConnectWithoutUserProfileInput | NutritionalCounselingCreateOrConnectWithoutUserProfileInput[]
    upsert?: NutritionalCounselingUpsertWithWhereUniqueWithoutUserProfileInput | NutritionalCounselingUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: NutritionalCounselingCreateManyUserProfileInputEnvelope
    set?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    disconnect?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    delete?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    connect?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    update?: NutritionalCounselingUpdateWithWhereUniqueWithoutUserProfileInput | NutritionalCounselingUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: NutritionalCounselingUpdateManyWithWhereWithoutUserProfileInput | NutritionalCounselingUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: NutritionalCounselingScalarWhereInput | NutritionalCounselingScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ReferralCreateWithoutUserProfileInput, ReferralUncheckedCreateWithoutUserProfileInput> | ReferralCreateWithoutUserProfileInput[] | ReferralUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserProfileInput | ReferralCreateOrConnectWithoutUserProfileInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutUserProfileInput | ReferralUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ReferralCreateManyUserProfileInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutUserProfileInput | ReferralUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutUserProfileInput | ReferralUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserProfileInput, AppointmentUncheckedCreateWithoutUserProfileInput> | AppointmentCreateWithoutUserProfileInput[] | AppointmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserProfileInput | AppointmentCreateOrConnectWithoutUserProfileInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserProfileInput | AppointmentUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: AppointmentCreateManyUserProfileInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserProfileInput | AppointmentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserProfileInput | AppointmentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ImmunizationReminderUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ImmunizationReminderCreateWithoutUserProfileInput, ImmunizationReminderUncheckedCreateWithoutUserProfileInput> | ImmunizationReminderCreateWithoutUserProfileInput[] | ImmunizationReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationReminderCreateOrConnectWithoutUserProfileInput | ImmunizationReminderCreateOrConnectWithoutUserProfileInput[]
    upsert?: ImmunizationReminderUpsertWithWhereUniqueWithoutUserProfileInput | ImmunizationReminderUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ImmunizationReminderCreateManyUserProfileInputEnvelope
    set?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    disconnect?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    delete?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    connect?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    update?: ImmunizationReminderUpdateWithWhereUniqueWithoutUserProfileInput | ImmunizationReminderUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ImmunizationReminderUpdateManyWithWhereWithoutUserProfileInput | ImmunizationReminderUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ImmunizationReminderScalarWhereInput | ImmunizationReminderScalarWhereInput[]
  }

  export type TestReminderUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<TestReminderCreateWithoutUserProfileInput, TestReminderUncheckedCreateWithoutUserProfileInput> | TestReminderCreateWithoutUserProfileInput[] | TestReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: TestReminderCreateOrConnectWithoutUserProfileInput | TestReminderCreateOrConnectWithoutUserProfileInput[]
    upsert?: TestReminderUpsertWithWhereUniqueWithoutUserProfileInput | TestReminderUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: TestReminderCreateManyUserProfileInputEnvelope
    set?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    disconnect?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    delete?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    connect?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    update?: TestReminderUpdateWithWhereUniqueWithoutUserProfileInput | TestReminderUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: TestReminderUpdateManyWithWhereWithoutUserProfileInput | TestReminderUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: TestReminderScalarWhereInput | TestReminderScalarWhereInput[]
  }

  export type VirtualCheckupUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<VirtualCheckupCreateWithoutUserProfileInput, VirtualCheckupUncheckedCreateWithoutUserProfileInput> | VirtualCheckupCreateWithoutUserProfileInput[] | VirtualCheckupUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutUserProfileInput | VirtualCheckupCreateOrConnectWithoutUserProfileInput[]
    upsert?: VirtualCheckupUpsertWithWhereUniqueWithoutUserProfileInput | VirtualCheckupUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: VirtualCheckupCreateManyUserProfileInputEnvelope
    set?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    disconnect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    delete?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    update?: VirtualCheckupUpdateWithWhereUniqueWithoutUserProfileInput | VirtualCheckupUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: VirtualCheckupUpdateManyWithWhereWithoutUserProfileInput | VirtualCheckupUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: VirtualCheckupScalarWhereInput | VirtualCheckupScalarWhereInput[]
  }

  export type EventRegistrationUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutUserProfileInput, EventRegistrationUncheckedCreateWithoutUserProfileInput> | EventRegistrationCreateWithoutUserProfileInput[] | EventRegistrationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserProfileInput | EventRegistrationCreateOrConnectWithoutUserProfileInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutUserProfileInput | EventRegistrationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: EventRegistrationCreateManyUserProfileInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutUserProfileInput | EventRegistrationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutUserProfileInput | EventRegistrationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type ProgramParticipationUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutUserProfileInput, ProgramParticipationUncheckedCreateWithoutUserProfileInput> | ProgramParticipationCreateWithoutUserProfileInput[] | ProgramParticipationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutUserProfileInput | ProgramParticipationCreateOrConnectWithoutUserProfileInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutUserProfileInput | ProgramParticipationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ProgramParticipationCreateManyUserProfileInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutUserProfileInput | ProgramParticipationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutUserProfileInput | ProgramParticipationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<InquiryCreateWithoutUserProfileInput, InquiryUncheckedCreateWithoutUserProfileInput> | InquiryCreateWithoutUserProfileInput[] | InquiryUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserProfileInput | InquiryCreateOrConnectWithoutUserProfileInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserProfileInput | InquiryUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: InquiryCreateManyUserProfileInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserProfileInput | InquiryUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserProfileInput | InquiryUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type SurveyResponseUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutUserProfileInput, SurveyResponseUncheckedCreateWithoutUserProfileInput> | SurveyResponseCreateWithoutUserProfileInput[] | SurveyResponseUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserProfileInput | SurveyResponseCreateOrConnectWithoutUserProfileInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutUserProfileInput | SurveyResponseUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: SurveyResponseCreateManyUserProfileInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutUserProfileInput | SurveyResponseUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutUserProfileInput | SurveyResponseUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput = {
    create?: XOR<FamilyRecordCreateWithoutHeadOfFamilyInput, FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput> | FamilyRecordCreateWithoutHeadOfFamilyInput[] | FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput[]
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput | FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput[]
    upsert?: FamilyRecordUpsertWithWhereUniqueWithoutHeadOfFamilyInput | FamilyRecordUpsertWithWhereUniqueWithoutHeadOfFamilyInput[]
    createMany?: FamilyRecordCreateManyHeadOfFamilyInputEnvelope
    set?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    disconnect?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    delete?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    connect?: FamilyRecordWhereUniqueInput | FamilyRecordWhereUniqueInput[]
    update?: FamilyRecordUpdateWithWhereUniqueWithoutHeadOfFamilyInput | FamilyRecordUpdateWithWhereUniqueWithoutHeadOfFamilyInput[]
    updateMany?: FamilyRecordUpdateManyWithWhereWithoutHeadOfFamilyInput | FamilyRecordUpdateManyWithWhereWithoutHeadOfFamilyInput[]
    deleteMany?: FamilyRecordScalarWhereInput | FamilyRecordScalarWhereInput[]
  }

  export type FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutUserProfileInput, FamilyMemberUncheckedCreateWithoutUserProfileInput> | FamilyMemberCreateWithoutUserProfileInput[] | FamilyMemberUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutUserProfileInput | FamilyMemberCreateOrConnectWithoutUserProfileInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutUserProfileInput | FamilyMemberUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: FamilyMemberCreateManyUserProfileInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutUserProfileInput | FamilyMemberUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutUserProfileInput | FamilyMemberUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<MaternalHealthCreateWithoutUserProfileInput, MaternalHealthUncheckedCreateWithoutUserProfileInput> | MaternalHealthCreateWithoutUserProfileInput[] | MaternalHealthUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutUserProfileInput | MaternalHealthCreateOrConnectWithoutUserProfileInput[]
    upsert?: MaternalHealthUpsertWithWhereUniqueWithoutUserProfileInput | MaternalHealthUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: MaternalHealthCreateManyUserProfileInputEnvelope
    set?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    disconnect?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    delete?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    connect?: MaternalHealthWhereUniqueInput | MaternalHealthWhereUniqueInput[]
    update?: MaternalHealthUpdateWithWhereUniqueWithoutUserProfileInput | MaternalHealthUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: MaternalHealthUpdateManyWithWhereWithoutUserProfileInput | MaternalHealthUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: MaternalHealthScalarWhereInput | MaternalHealthScalarWhereInput[]
  }

  export type BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<BirthInformationCreateWithoutUserProfileInput, BirthInformationUncheckedCreateWithoutUserProfileInput> | BirthInformationCreateWithoutUserProfileInput[] | BirthInformationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutUserProfileInput | BirthInformationCreateOrConnectWithoutUserProfileInput[]
    upsert?: BirthInformationUpsertWithWhereUniqueWithoutUserProfileInput | BirthInformationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: BirthInformationCreateManyUserProfileInputEnvelope
    set?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    disconnect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    delete?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    update?: BirthInformationUpdateWithWhereUniqueWithoutUserProfileInput | BirthInformationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: BirthInformationUpdateManyWithWhereWithoutUserProfileInput | BirthInformationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: BirthInformationScalarWhereInput | BirthInformationScalarWhereInput[]
  }

  export type ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ImmunizationEventCreateWithoutUserProfileInput, ImmunizationEventUncheckedCreateWithoutUserProfileInput> | ImmunizationEventCreateWithoutUserProfileInput[] | ImmunizationEventUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationEventCreateOrConnectWithoutUserProfileInput | ImmunizationEventCreateOrConnectWithoutUserProfileInput[]
    upsert?: ImmunizationEventUpsertWithWhereUniqueWithoutUserProfileInput | ImmunizationEventUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ImmunizationEventCreateManyUserProfileInputEnvelope
    set?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    disconnect?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    delete?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    connect?: ImmunizationEventWhereUniqueInput | ImmunizationEventWhereUniqueInput[]
    update?: ImmunizationEventUpdateWithWhereUniqueWithoutUserProfileInput | ImmunizationEventUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ImmunizationEventUpdateManyWithWhereWithoutUserProfileInput | ImmunizationEventUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ImmunizationEventScalarWhereInput | ImmunizationEventScalarWhereInput[]
  }

  export type VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<VitalSignsCreateWithoutUserProfileInput, VitalSignsUncheckedCreateWithoutUserProfileInput> | VitalSignsCreateWithoutUserProfileInput[] | VitalSignsUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VitalSignsCreateOrConnectWithoutUserProfileInput | VitalSignsCreateOrConnectWithoutUserProfileInput[]
    upsert?: VitalSignsUpsertWithWhereUniqueWithoutUserProfileInput | VitalSignsUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: VitalSignsCreateManyUserProfileInputEnvelope
    set?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    disconnect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    delete?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    connect?: VitalSignsWhereUniqueInput | VitalSignsWhereUniqueInput[]
    update?: VitalSignsUpdateWithWhereUniqueWithoutUserProfileInput | VitalSignsUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: VitalSignsUpdateManyWithWhereWithoutUserProfileInput | VitalSignsUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
  }

  export type AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<AnthropometricMeasurementCreateWithoutUserProfileInput, AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput> | AnthropometricMeasurementCreateWithoutUserProfileInput[] | AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput | AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput[]
    upsert?: AnthropometricMeasurementUpsertWithWhereUniqueWithoutUserProfileInput | AnthropometricMeasurementUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: AnthropometricMeasurementCreateManyUserProfileInputEnvelope
    set?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    disconnect?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    delete?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    connect?: AnthropometricMeasurementWhereUniqueInput | AnthropometricMeasurementWhereUniqueInput[]
    update?: AnthropometricMeasurementUpdateWithWhereUniqueWithoutUserProfileInput | AnthropometricMeasurementUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: AnthropometricMeasurementUpdateManyWithWhereWithoutUserProfileInput | AnthropometricMeasurementUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: AnthropometricMeasurementScalarWhereInput | AnthropometricMeasurementScalarWhereInput[]
  }

  export type GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<GrowthTrackingCreateWithoutUserProfileInput, GrowthTrackingUncheckedCreateWithoutUserProfileInput> | GrowthTrackingCreateWithoutUserProfileInput[] | GrowthTrackingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: GrowthTrackingCreateOrConnectWithoutUserProfileInput | GrowthTrackingCreateOrConnectWithoutUserProfileInput[]
    upsert?: GrowthTrackingUpsertWithWhereUniqueWithoutUserProfileInput | GrowthTrackingUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: GrowthTrackingCreateManyUserProfileInputEnvelope
    set?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    disconnect?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    delete?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    connect?: GrowthTrackingWhereUniqueInput | GrowthTrackingWhereUniqueInput[]
    update?: GrowthTrackingUpdateWithWhereUniqueWithoutUserProfileInput | GrowthTrackingUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: GrowthTrackingUpdateManyWithWhereWithoutUserProfileInput | GrowthTrackingUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: GrowthTrackingScalarWhereInput | GrowthTrackingScalarWhereInput[]
  }

  export type NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<NCDRiskAssessmentCreateWithoutUserProfileInput, NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput> | NCDRiskAssessmentCreateWithoutUserProfileInput[] | NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput | NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput[]
    upsert?: NCDRiskAssessmentUpsertWithWhereUniqueWithoutUserProfileInput | NCDRiskAssessmentUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: NCDRiskAssessmentCreateManyUserProfileInputEnvelope
    set?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    disconnect?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    delete?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    connect?: NCDRiskAssessmentWhereUniqueInput | NCDRiskAssessmentWhereUniqueInput[]
    update?: NCDRiskAssessmentUpdateWithWhereUniqueWithoutUserProfileInput | NCDRiskAssessmentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: NCDRiskAssessmentUpdateManyWithWhereWithoutUserProfileInput | NCDRiskAssessmentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: NCDRiskAssessmentScalarWhereInput | NCDRiskAssessmentScalarWhereInput[]
  }

  export type VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<VisitRecordCreateWithoutUserProfileInput, VisitRecordUncheckedCreateWithoutUserProfileInput> | VisitRecordCreateWithoutUserProfileInput[] | VisitRecordUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VisitRecordCreateOrConnectWithoutUserProfileInput | VisitRecordCreateOrConnectWithoutUserProfileInput[]
    upsert?: VisitRecordUpsertWithWhereUniqueWithoutUserProfileInput | VisitRecordUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: VisitRecordCreateManyUserProfileInputEnvelope
    set?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    disconnect?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    delete?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    connect?: VisitRecordWhereUniqueInput | VisitRecordWhereUniqueInput[]
    update?: VisitRecordUpdateWithWhereUniqueWithoutUserProfileInput | VisitRecordUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: VisitRecordUpdateManyWithWhereWithoutUserProfileInput | VisitRecordUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: VisitRecordScalarWhereInput | VisitRecordScalarWhereInput[]
  }

  export type HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<HealthEducationCreateWithoutUserProfileInput, HealthEducationUncheckedCreateWithoutUserProfileInput> | HealthEducationCreateWithoutUserProfileInput[] | HealthEducationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: HealthEducationCreateOrConnectWithoutUserProfileInput | HealthEducationCreateOrConnectWithoutUserProfileInput[]
    upsert?: HealthEducationUpsertWithWhereUniqueWithoutUserProfileInput | HealthEducationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: HealthEducationCreateManyUserProfileInputEnvelope
    set?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    disconnect?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    delete?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    connect?: HealthEducationWhereUniqueInput | HealthEducationWhereUniqueInput[]
    update?: HealthEducationUpdateWithWhereUniqueWithoutUserProfileInput | HealthEducationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: HealthEducationUpdateManyWithWhereWithoutUserProfileInput | HealthEducationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: HealthEducationScalarWhereInput | HealthEducationScalarWhereInput[]
  }

  export type NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<NutritionalCounselingCreateWithoutUserProfileInput, NutritionalCounselingUncheckedCreateWithoutUserProfileInput> | NutritionalCounselingCreateWithoutUserProfileInput[] | NutritionalCounselingUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: NutritionalCounselingCreateOrConnectWithoutUserProfileInput | NutritionalCounselingCreateOrConnectWithoutUserProfileInput[]
    upsert?: NutritionalCounselingUpsertWithWhereUniqueWithoutUserProfileInput | NutritionalCounselingUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: NutritionalCounselingCreateManyUserProfileInputEnvelope
    set?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    disconnect?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    delete?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    connect?: NutritionalCounselingWhereUniqueInput | NutritionalCounselingWhereUniqueInput[]
    update?: NutritionalCounselingUpdateWithWhereUniqueWithoutUserProfileInput | NutritionalCounselingUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: NutritionalCounselingUpdateManyWithWhereWithoutUserProfileInput | NutritionalCounselingUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: NutritionalCounselingScalarWhereInput | NutritionalCounselingScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ReferralCreateWithoutUserProfileInput, ReferralUncheckedCreateWithoutUserProfileInput> | ReferralCreateWithoutUserProfileInput[] | ReferralUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutUserProfileInput | ReferralCreateOrConnectWithoutUserProfileInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutUserProfileInput | ReferralUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ReferralCreateManyUserProfileInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutUserProfileInput | ReferralUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutUserProfileInput | ReferralUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserProfileInput, AppointmentUncheckedCreateWithoutUserProfileInput> | AppointmentCreateWithoutUserProfileInput[] | AppointmentUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserProfileInput | AppointmentCreateOrConnectWithoutUserProfileInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserProfileInput | AppointmentUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: AppointmentCreateManyUserProfileInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserProfileInput | AppointmentUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserProfileInput | AppointmentUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ImmunizationReminderCreateWithoutUserProfileInput, ImmunizationReminderUncheckedCreateWithoutUserProfileInput> | ImmunizationReminderCreateWithoutUserProfileInput[] | ImmunizationReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ImmunizationReminderCreateOrConnectWithoutUserProfileInput | ImmunizationReminderCreateOrConnectWithoutUserProfileInput[]
    upsert?: ImmunizationReminderUpsertWithWhereUniqueWithoutUserProfileInput | ImmunizationReminderUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ImmunizationReminderCreateManyUserProfileInputEnvelope
    set?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    disconnect?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    delete?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    connect?: ImmunizationReminderWhereUniqueInput | ImmunizationReminderWhereUniqueInput[]
    update?: ImmunizationReminderUpdateWithWhereUniqueWithoutUserProfileInput | ImmunizationReminderUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ImmunizationReminderUpdateManyWithWhereWithoutUserProfileInput | ImmunizationReminderUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ImmunizationReminderScalarWhereInput | ImmunizationReminderScalarWhereInput[]
  }

  export type TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<TestReminderCreateWithoutUserProfileInput, TestReminderUncheckedCreateWithoutUserProfileInput> | TestReminderCreateWithoutUserProfileInput[] | TestReminderUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: TestReminderCreateOrConnectWithoutUserProfileInput | TestReminderCreateOrConnectWithoutUserProfileInput[]
    upsert?: TestReminderUpsertWithWhereUniqueWithoutUserProfileInput | TestReminderUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: TestReminderCreateManyUserProfileInputEnvelope
    set?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    disconnect?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    delete?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    connect?: TestReminderWhereUniqueInput | TestReminderWhereUniqueInput[]
    update?: TestReminderUpdateWithWhereUniqueWithoutUserProfileInput | TestReminderUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: TestReminderUpdateManyWithWhereWithoutUserProfileInput | TestReminderUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: TestReminderScalarWhereInput | TestReminderScalarWhereInput[]
  }

  export type VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<VirtualCheckupCreateWithoutUserProfileInput, VirtualCheckupUncheckedCreateWithoutUserProfileInput> | VirtualCheckupCreateWithoutUserProfileInput[] | VirtualCheckupUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutUserProfileInput | VirtualCheckupCreateOrConnectWithoutUserProfileInput[]
    upsert?: VirtualCheckupUpsertWithWhereUniqueWithoutUserProfileInput | VirtualCheckupUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: VirtualCheckupCreateManyUserProfileInputEnvelope
    set?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    disconnect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    delete?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    update?: VirtualCheckupUpdateWithWhereUniqueWithoutUserProfileInput | VirtualCheckupUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: VirtualCheckupUpdateManyWithWhereWithoutUserProfileInput | VirtualCheckupUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: VirtualCheckupScalarWhereInput | VirtualCheckupScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutUserProfileInput, EventRegistrationUncheckedCreateWithoutUserProfileInput> | EventRegistrationCreateWithoutUserProfileInput[] | EventRegistrationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserProfileInput | EventRegistrationCreateOrConnectWithoutUserProfileInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutUserProfileInput | EventRegistrationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: EventRegistrationCreateManyUserProfileInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutUserProfileInput | EventRegistrationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutUserProfileInput | EventRegistrationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutUserProfileInput, ProgramParticipationUncheckedCreateWithoutUserProfileInput> | ProgramParticipationCreateWithoutUserProfileInput[] | ProgramParticipationUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutUserProfileInput | ProgramParticipationCreateOrConnectWithoutUserProfileInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutUserProfileInput | ProgramParticipationUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: ProgramParticipationCreateManyUserProfileInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutUserProfileInput | ProgramParticipationUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutUserProfileInput | ProgramParticipationUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<InquiryCreateWithoutUserProfileInput, InquiryUncheckedCreateWithoutUserProfileInput> | InquiryCreateWithoutUserProfileInput[] | InquiryUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutUserProfileInput | InquiryCreateOrConnectWithoutUserProfileInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutUserProfileInput | InquiryUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: InquiryCreateManyUserProfileInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutUserProfileInput | InquiryUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutUserProfileInput | InquiryUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutUserProfileInput, SurveyResponseUncheckedCreateWithoutUserProfileInput> | SurveyResponseCreateWithoutUserProfileInput[] | SurveyResponseUncheckedCreateWithoutUserProfileInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutUserProfileInput | SurveyResponseCreateOrConnectWithoutUserProfileInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutUserProfileInput | SurveyResponseUpsertWithWhereUniqueWithoutUserProfileInput[]
    createMany?: SurveyResponseCreateManyUserProfileInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutUserProfileInput | SurveyResponseUpdateWithWhereUniqueWithoutUserProfileInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutUserProfileInput | SurveyResponseUpdateManyWithWhereWithoutUserProfileInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutHealthWorkersInput = {
    create?: XOR<AccountCreateWithoutHealthWorkersInput, AccountUncheckedCreateWithoutHealthWorkersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutHealthWorkersInput
    connect?: AccountWhereUniqueInput
  }

  export type VirtualCheckupCreateNestedManyWithoutHealthWorkerInput = {
    create?: XOR<VirtualCheckupCreateWithoutHealthWorkerInput, VirtualCheckupUncheckedCreateWithoutHealthWorkerInput> | VirtualCheckupCreateWithoutHealthWorkerInput[] | VirtualCheckupUncheckedCreateWithoutHealthWorkerInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutHealthWorkerInput | VirtualCheckupCreateOrConnectWithoutHealthWorkerInput[]
    createMany?: VirtualCheckupCreateManyHealthWorkerInputEnvelope
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
  }

  export type VirtualCheckupUncheckedCreateNestedManyWithoutHealthWorkerInput = {
    create?: XOR<VirtualCheckupCreateWithoutHealthWorkerInput, VirtualCheckupUncheckedCreateWithoutHealthWorkerInput> | VirtualCheckupCreateWithoutHealthWorkerInput[] | VirtualCheckupUncheckedCreateWithoutHealthWorkerInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutHealthWorkerInput | VirtualCheckupCreateOrConnectWithoutHealthWorkerInput[]
    createMany?: VirtualCheckupCreateManyHealthWorkerInputEnvelope
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutHealthWorkersNestedInput = {
    create?: XOR<AccountCreateWithoutHealthWorkersInput, AccountUncheckedCreateWithoutHealthWorkersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutHealthWorkersInput
    upsert?: AccountUpsertWithoutHealthWorkersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutHealthWorkersInput, AccountUpdateWithoutHealthWorkersInput>, AccountUncheckedUpdateWithoutHealthWorkersInput>
  }

  export type VirtualCheckupUpdateManyWithoutHealthWorkerNestedInput = {
    create?: XOR<VirtualCheckupCreateWithoutHealthWorkerInput, VirtualCheckupUncheckedCreateWithoutHealthWorkerInput> | VirtualCheckupCreateWithoutHealthWorkerInput[] | VirtualCheckupUncheckedCreateWithoutHealthWorkerInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutHealthWorkerInput | VirtualCheckupCreateOrConnectWithoutHealthWorkerInput[]
    upsert?: VirtualCheckupUpsertWithWhereUniqueWithoutHealthWorkerInput | VirtualCheckupUpsertWithWhereUniqueWithoutHealthWorkerInput[]
    createMany?: VirtualCheckupCreateManyHealthWorkerInputEnvelope
    set?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    disconnect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    delete?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    update?: VirtualCheckupUpdateWithWhereUniqueWithoutHealthWorkerInput | VirtualCheckupUpdateWithWhereUniqueWithoutHealthWorkerInput[]
    updateMany?: VirtualCheckupUpdateManyWithWhereWithoutHealthWorkerInput | VirtualCheckupUpdateManyWithWhereWithoutHealthWorkerInput[]
    deleteMany?: VirtualCheckupScalarWhereInput | VirtualCheckupScalarWhereInput[]
  }

  export type VirtualCheckupUncheckedUpdateManyWithoutHealthWorkerNestedInput = {
    create?: XOR<VirtualCheckupCreateWithoutHealthWorkerInput, VirtualCheckupUncheckedCreateWithoutHealthWorkerInput> | VirtualCheckupCreateWithoutHealthWorkerInput[] | VirtualCheckupUncheckedCreateWithoutHealthWorkerInput[]
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutHealthWorkerInput | VirtualCheckupCreateOrConnectWithoutHealthWorkerInput[]
    upsert?: VirtualCheckupUpsertWithWhereUniqueWithoutHealthWorkerInput | VirtualCheckupUpsertWithWhereUniqueWithoutHealthWorkerInput[]
    createMany?: VirtualCheckupCreateManyHealthWorkerInputEnvelope
    set?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    disconnect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    delete?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    connect?: VirtualCheckupWhereUniqueInput | VirtualCheckupWhereUniqueInput[]
    update?: VirtualCheckupUpdateWithWhereUniqueWithoutHealthWorkerInput | VirtualCheckupUpdateWithWhereUniqueWithoutHealthWorkerInput[]
    updateMany?: VirtualCheckupUpdateManyWithWhereWithoutHealthWorkerInput | VirtualCheckupUpdateManyWithWhereWithoutHealthWorkerInput[]
    deleteMany?: VirtualCheckupScalarWhereInput | VirtualCheckupScalarWhereInput[]
  }

  export type UserProfileCreateNestedOneWithoutFamilyRecordsHeadedInput = {
    create?: XOR<UserProfileCreateWithoutFamilyRecordsHeadedInput, UserProfileUncheckedCreateWithoutFamilyRecordsHeadedInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFamilyRecordsHeadedInput
    connect?: UserProfileWhereUniqueInput
  }

  export type FamilyMemberCreateNestedManyWithoutFamilyRecordInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyRecordInput, FamilyMemberUncheckedCreateWithoutFamilyRecordInput> | FamilyMemberCreateWithoutFamilyRecordInput[] | FamilyMemberUncheckedCreateWithoutFamilyRecordInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyRecordInput | FamilyMemberCreateOrConnectWithoutFamilyRecordInput[]
    createMany?: FamilyMemberCreateManyFamilyRecordInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type FamilyHealthHistoryCreateNestedOneWithoutFamilyRecordInput = {
    create?: XOR<FamilyHealthHistoryCreateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedCreateWithoutFamilyRecordInput>
    connectOrCreate?: FamilyHealthHistoryCreateOrConnectWithoutFamilyRecordInput
    connect?: FamilyHealthHistoryWhereUniqueInput
  }

  export type FamilyMemberUncheckedCreateNestedManyWithoutFamilyRecordInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyRecordInput, FamilyMemberUncheckedCreateWithoutFamilyRecordInput> | FamilyMemberCreateWithoutFamilyRecordInput[] | FamilyMemberUncheckedCreateWithoutFamilyRecordInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyRecordInput | FamilyMemberCreateOrConnectWithoutFamilyRecordInput[]
    createMany?: FamilyMemberCreateManyFamilyRecordInputEnvelope
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
  }

  export type FamilyHealthHistoryUncheckedCreateNestedOneWithoutFamilyRecordInput = {
    create?: XOR<FamilyHealthHistoryCreateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedCreateWithoutFamilyRecordInput>
    connectOrCreate?: FamilyHealthHistoryCreateOrConnectWithoutFamilyRecordInput
    connect?: FamilyHealthHistoryWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutFamilyRecordsHeadedNestedInput = {
    create?: XOR<UserProfileCreateWithoutFamilyRecordsHeadedInput, UserProfileUncheckedCreateWithoutFamilyRecordsHeadedInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFamilyRecordsHeadedInput
    upsert?: UserProfileUpsertWithoutFamilyRecordsHeadedInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutFamilyRecordsHeadedInput, UserProfileUpdateWithoutFamilyRecordsHeadedInput>, UserProfileUncheckedUpdateWithoutFamilyRecordsHeadedInput>
  }

  export type FamilyMemberUpdateManyWithoutFamilyRecordNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyRecordInput, FamilyMemberUncheckedCreateWithoutFamilyRecordInput> | FamilyMemberCreateWithoutFamilyRecordInput[] | FamilyMemberUncheckedCreateWithoutFamilyRecordInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyRecordInput | FamilyMemberCreateOrConnectWithoutFamilyRecordInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutFamilyRecordInput | FamilyMemberUpsertWithWhereUniqueWithoutFamilyRecordInput[]
    createMany?: FamilyMemberCreateManyFamilyRecordInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutFamilyRecordInput | FamilyMemberUpdateWithWhereUniqueWithoutFamilyRecordInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutFamilyRecordInput | FamilyMemberUpdateManyWithWhereWithoutFamilyRecordInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type FamilyHealthHistoryUpdateOneWithoutFamilyRecordNestedInput = {
    create?: XOR<FamilyHealthHistoryCreateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedCreateWithoutFamilyRecordInput>
    connectOrCreate?: FamilyHealthHistoryCreateOrConnectWithoutFamilyRecordInput
    upsert?: FamilyHealthHistoryUpsertWithoutFamilyRecordInput
    disconnect?: FamilyHealthHistoryWhereInput | boolean
    delete?: FamilyHealthHistoryWhereInput | boolean
    connect?: FamilyHealthHistoryWhereUniqueInput
    update?: XOR<XOR<FamilyHealthHistoryUpdateToOneWithWhereWithoutFamilyRecordInput, FamilyHealthHistoryUpdateWithoutFamilyRecordInput>, FamilyHealthHistoryUncheckedUpdateWithoutFamilyRecordInput>
  }

  export type FamilyMemberUncheckedUpdateManyWithoutFamilyRecordNestedInput = {
    create?: XOR<FamilyMemberCreateWithoutFamilyRecordInput, FamilyMemberUncheckedCreateWithoutFamilyRecordInput> | FamilyMemberCreateWithoutFamilyRecordInput[] | FamilyMemberUncheckedCreateWithoutFamilyRecordInput[]
    connectOrCreate?: FamilyMemberCreateOrConnectWithoutFamilyRecordInput | FamilyMemberCreateOrConnectWithoutFamilyRecordInput[]
    upsert?: FamilyMemberUpsertWithWhereUniqueWithoutFamilyRecordInput | FamilyMemberUpsertWithWhereUniqueWithoutFamilyRecordInput[]
    createMany?: FamilyMemberCreateManyFamilyRecordInputEnvelope
    set?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    disconnect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    delete?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    connect?: FamilyMemberWhereUniqueInput | FamilyMemberWhereUniqueInput[]
    update?: FamilyMemberUpdateWithWhereUniqueWithoutFamilyRecordInput | FamilyMemberUpdateWithWhereUniqueWithoutFamilyRecordInput[]
    updateMany?: FamilyMemberUpdateManyWithWhereWithoutFamilyRecordInput | FamilyMemberUpdateManyWithWhereWithoutFamilyRecordInput[]
    deleteMany?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
  }

  export type FamilyHealthHistoryUncheckedUpdateOneWithoutFamilyRecordNestedInput = {
    create?: XOR<FamilyHealthHistoryCreateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedCreateWithoutFamilyRecordInput>
    connectOrCreate?: FamilyHealthHistoryCreateOrConnectWithoutFamilyRecordInput
    upsert?: FamilyHealthHistoryUpsertWithoutFamilyRecordInput
    disconnect?: FamilyHealthHistoryWhereInput | boolean
    delete?: FamilyHealthHistoryWhereInput | boolean
    connect?: FamilyHealthHistoryWhereUniqueInput
    update?: XOR<XOR<FamilyHealthHistoryUpdateToOneWithWhereWithoutFamilyRecordInput, FamilyHealthHistoryUpdateWithoutFamilyRecordInput>, FamilyHealthHistoryUncheckedUpdateWithoutFamilyRecordInput>
  }

  export type FamilyRecordCreateNestedOneWithoutMembersInput = {
    create?: XOR<FamilyRecordCreateWithoutMembersInput, FamilyRecordUncheckedCreateWithoutMembersInput>
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutMembersInput
    connect?: FamilyRecordWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutFamilyMembersInput = {
    create?: XOR<UserProfileCreateWithoutFamilyMembersInput, UserProfileUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFamilyMembersInput
    connect?: UserProfileWhereUniqueInput
  }

  export type FamilyRecordUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<FamilyRecordCreateWithoutMembersInput, FamilyRecordUncheckedCreateWithoutMembersInput>
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutMembersInput
    upsert?: FamilyRecordUpsertWithoutMembersInput
    connect?: FamilyRecordWhereUniqueInput
    update?: XOR<XOR<FamilyRecordUpdateToOneWithWhereWithoutMembersInput, FamilyRecordUpdateWithoutMembersInput>, FamilyRecordUncheckedUpdateWithoutMembersInput>
  }

  export type UserProfileUpdateOneWithoutFamilyMembersNestedInput = {
    create?: XOR<UserProfileCreateWithoutFamilyMembersInput, UserProfileUncheckedCreateWithoutFamilyMembersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutFamilyMembersInput
    upsert?: UserProfileUpsertWithoutFamilyMembersInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutFamilyMembersInput, UserProfileUpdateWithoutFamilyMembersInput>, UserProfileUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type FamilyRecordCreateNestedOneWithoutFamilyHealthHistoryInput = {
    create?: XOR<FamilyRecordCreateWithoutFamilyHealthHistoryInput, FamilyRecordUncheckedCreateWithoutFamilyHealthHistoryInput>
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutFamilyHealthHistoryInput
    connect?: FamilyRecordWhereUniqueInput
  }

  export type FamilyRecordUpdateOneRequiredWithoutFamilyHealthHistoryNestedInput = {
    create?: XOR<FamilyRecordCreateWithoutFamilyHealthHistoryInput, FamilyRecordUncheckedCreateWithoutFamilyHealthHistoryInput>
    connectOrCreate?: FamilyRecordCreateOrConnectWithoutFamilyHealthHistoryInput
    upsert?: FamilyRecordUpsertWithoutFamilyHealthHistoryInput
    connect?: FamilyRecordWhereUniqueInput
    update?: XOR<XOR<FamilyRecordUpdateToOneWithWhereWithoutFamilyHealthHistoryInput, FamilyRecordUpdateWithoutFamilyHealthHistoryInput>, FamilyRecordUncheckedUpdateWithoutFamilyHealthHistoryInput>
  }

  export type UserProfileCreateNestedOneWithoutMaternalHealthRecordsInput = {
    create?: XOR<UserProfileCreateWithoutMaternalHealthRecordsInput, UserProfileUncheckedCreateWithoutMaternalHealthRecordsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutMaternalHealthRecordsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type PrenatalVisitCreateNestedManyWithoutMaternalHealthInput = {
    create?: XOR<PrenatalVisitCreateWithoutMaternalHealthInput, PrenatalVisitUncheckedCreateWithoutMaternalHealthInput> | PrenatalVisitCreateWithoutMaternalHealthInput[] | PrenatalVisitUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutMaternalHealthInput | PrenatalVisitCreateOrConnectWithoutMaternalHealthInput[]
    createMany?: PrenatalVisitCreateManyMaternalHealthInputEnvelope
    connect?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
  }

  export type BirthInformationCreateNestedManyWithoutMaternalHealthInput = {
    create?: XOR<BirthInformationCreateWithoutMaternalHealthInput, BirthInformationUncheckedCreateWithoutMaternalHealthInput> | BirthInformationCreateWithoutMaternalHealthInput[] | BirthInformationUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutMaternalHealthInput | BirthInformationCreateOrConnectWithoutMaternalHealthInput[]
    createMany?: BirthInformationCreateManyMaternalHealthInputEnvelope
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
  }

  export type PrenatalVisitUncheckedCreateNestedManyWithoutMaternalHealthInput = {
    create?: XOR<PrenatalVisitCreateWithoutMaternalHealthInput, PrenatalVisitUncheckedCreateWithoutMaternalHealthInput> | PrenatalVisitCreateWithoutMaternalHealthInput[] | PrenatalVisitUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutMaternalHealthInput | PrenatalVisitCreateOrConnectWithoutMaternalHealthInput[]
    createMany?: PrenatalVisitCreateManyMaternalHealthInputEnvelope
    connect?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
  }

  export type BirthInformationUncheckedCreateNestedManyWithoutMaternalHealthInput = {
    create?: XOR<BirthInformationCreateWithoutMaternalHealthInput, BirthInformationUncheckedCreateWithoutMaternalHealthInput> | BirthInformationCreateWithoutMaternalHealthInput[] | BirthInformationUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutMaternalHealthInput | BirthInformationCreateOrConnectWithoutMaternalHealthInput[]
    createMany?: BirthInformationCreateManyMaternalHealthInputEnvelope
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
  }

  export type UserProfileUpdateOneRequiredWithoutMaternalHealthRecordsNestedInput = {
    create?: XOR<UserProfileCreateWithoutMaternalHealthRecordsInput, UserProfileUncheckedCreateWithoutMaternalHealthRecordsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutMaternalHealthRecordsInput
    upsert?: UserProfileUpsertWithoutMaternalHealthRecordsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutMaternalHealthRecordsInput, UserProfileUpdateWithoutMaternalHealthRecordsInput>, UserProfileUncheckedUpdateWithoutMaternalHealthRecordsInput>
  }

  export type PrenatalVisitUpdateManyWithoutMaternalHealthNestedInput = {
    create?: XOR<PrenatalVisitCreateWithoutMaternalHealthInput, PrenatalVisitUncheckedCreateWithoutMaternalHealthInput> | PrenatalVisitCreateWithoutMaternalHealthInput[] | PrenatalVisitUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutMaternalHealthInput | PrenatalVisitCreateOrConnectWithoutMaternalHealthInput[]
    upsert?: PrenatalVisitUpsertWithWhereUniqueWithoutMaternalHealthInput | PrenatalVisitUpsertWithWhereUniqueWithoutMaternalHealthInput[]
    createMany?: PrenatalVisitCreateManyMaternalHealthInputEnvelope
    set?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    disconnect?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    delete?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    connect?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    update?: PrenatalVisitUpdateWithWhereUniqueWithoutMaternalHealthInput | PrenatalVisitUpdateWithWhereUniqueWithoutMaternalHealthInput[]
    updateMany?: PrenatalVisitUpdateManyWithWhereWithoutMaternalHealthInput | PrenatalVisitUpdateManyWithWhereWithoutMaternalHealthInput[]
    deleteMany?: PrenatalVisitScalarWhereInput | PrenatalVisitScalarWhereInput[]
  }

  export type BirthInformationUpdateManyWithoutMaternalHealthNestedInput = {
    create?: XOR<BirthInformationCreateWithoutMaternalHealthInput, BirthInformationUncheckedCreateWithoutMaternalHealthInput> | BirthInformationCreateWithoutMaternalHealthInput[] | BirthInformationUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutMaternalHealthInput | BirthInformationCreateOrConnectWithoutMaternalHealthInput[]
    upsert?: BirthInformationUpsertWithWhereUniqueWithoutMaternalHealthInput | BirthInformationUpsertWithWhereUniqueWithoutMaternalHealthInput[]
    createMany?: BirthInformationCreateManyMaternalHealthInputEnvelope
    set?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    disconnect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    delete?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    update?: BirthInformationUpdateWithWhereUniqueWithoutMaternalHealthInput | BirthInformationUpdateWithWhereUniqueWithoutMaternalHealthInput[]
    updateMany?: BirthInformationUpdateManyWithWhereWithoutMaternalHealthInput | BirthInformationUpdateManyWithWhereWithoutMaternalHealthInput[]
    deleteMany?: BirthInformationScalarWhereInput | BirthInformationScalarWhereInput[]
  }

  export type PrenatalVisitUncheckedUpdateManyWithoutMaternalHealthNestedInput = {
    create?: XOR<PrenatalVisitCreateWithoutMaternalHealthInput, PrenatalVisitUncheckedCreateWithoutMaternalHealthInput> | PrenatalVisitCreateWithoutMaternalHealthInput[] | PrenatalVisitUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutMaternalHealthInput | PrenatalVisitCreateOrConnectWithoutMaternalHealthInput[]
    upsert?: PrenatalVisitUpsertWithWhereUniqueWithoutMaternalHealthInput | PrenatalVisitUpsertWithWhereUniqueWithoutMaternalHealthInput[]
    createMany?: PrenatalVisitCreateManyMaternalHealthInputEnvelope
    set?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    disconnect?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    delete?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    connect?: PrenatalVisitWhereUniqueInput | PrenatalVisitWhereUniqueInput[]
    update?: PrenatalVisitUpdateWithWhereUniqueWithoutMaternalHealthInput | PrenatalVisitUpdateWithWhereUniqueWithoutMaternalHealthInput[]
    updateMany?: PrenatalVisitUpdateManyWithWhereWithoutMaternalHealthInput | PrenatalVisitUpdateManyWithWhereWithoutMaternalHealthInput[]
    deleteMany?: PrenatalVisitScalarWhereInput | PrenatalVisitScalarWhereInput[]
  }

  export type BirthInformationUncheckedUpdateManyWithoutMaternalHealthNestedInput = {
    create?: XOR<BirthInformationCreateWithoutMaternalHealthInput, BirthInformationUncheckedCreateWithoutMaternalHealthInput> | BirthInformationCreateWithoutMaternalHealthInput[] | BirthInformationUncheckedCreateWithoutMaternalHealthInput[]
    connectOrCreate?: BirthInformationCreateOrConnectWithoutMaternalHealthInput | BirthInformationCreateOrConnectWithoutMaternalHealthInput[]
    upsert?: BirthInformationUpsertWithWhereUniqueWithoutMaternalHealthInput | BirthInformationUpsertWithWhereUniqueWithoutMaternalHealthInput[]
    createMany?: BirthInformationCreateManyMaternalHealthInputEnvelope
    set?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    disconnect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    delete?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    connect?: BirthInformationWhereUniqueInput | BirthInformationWhereUniqueInput[]
    update?: BirthInformationUpdateWithWhereUniqueWithoutMaternalHealthInput | BirthInformationUpdateWithWhereUniqueWithoutMaternalHealthInput[]
    updateMany?: BirthInformationUpdateManyWithWhereWithoutMaternalHealthInput | BirthInformationUpdateManyWithWhereWithoutMaternalHealthInput[]
    deleteMany?: BirthInformationScalarWhereInput | BirthInformationScalarWhereInput[]
  }

  export type MaternalHealthCreateNestedOneWithoutPrenatalVisitsInput = {
    create?: XOR<MaternalHealthCreateWithoutPrenatalVisitsInput, MaternalHealthUncheckedCreateWithoutPrenatalVisitsInput>
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutPrenatalVisitsInput
    connect?: MaternalHealthWhereUniqueInput
  }

  export type LaboratoryTestCreateNestedManyWithoutPrenatalVisitInput = {
    create?: XOR<LaboratoryTestCreateWithoutPrenatalVisitInput, LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput> | LaboratoryTestCreateWithoutPrenatalVisitInput[] | LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput | LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput[]
    createMany?: LaboratoryTestCreateManyPrenatalVisitInputEnvelope
    connect?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
  }

  export type InterventionCreateNestedManyWithoutPrenatalVisitInput = {
    create?: XOR<InterventionCreateWithoutPrenatalVisitInput, InterventionUncheckedCreateWithoutPrenatalVisitInput> | InterventionCreateWithoutPrenatalVisitInput[] | InterventionUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPrenatalVisitInput | InterventionCreateOrConnectWithoutPrenatalVisitInput[]
    createMany?: InterventionCreateManyPrenatalVisitInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type LaboratoryTestUncheckedCreateNestedManyWithoutPrenatalVisitInput = {
    create?: XOR<LaboratoryTestCreateWithoutPrenatalVisitInput, LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput> | LaboratoryTestCreateWithoutPrenatalVisitInput[] | LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput | LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput[]
    createMany?: LaboratoryTestCreateManyPrenatalVisitInputEnvelope
    connect?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
  }

  export type InterventionUncheckedCreateNestedManyWithoutPrenatalVisitInput = {
    create?: XOR<InterventionCreateWithoutPrenatalVisitInput, InterventionUncheckedCreateWithoutPrenatalVisitInput> | InterventionCreateWithoutPrenatalVisitInput[] | InterventionUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPrenatalVisitInput | InterventionCreateOrConnectWithoutPrenatalVisitInput[]
    createMany?: InterventionCreateManyPrenatalVisitInputEnvelope
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type MaternalHealthUpdateOneRequiredWithoutPrenatalVisitsNestedInput = {
    create?: XOR<MaternalHealthCreateWithoutPrenatalVisitsInput, MaternalHealthUncheckedCreateWithoutPrenatalVisitsInput>
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutPrenatalVisitsInput
    upsert?: MaternalHealthUpsertWithoutPrenatalVisitsInput
    connect?: MaternalHealthWhereUniqueInput
    update?: XOR<XOR<MaternalHealthUpdateToOneWithWhereWithoutPrenatalVisitsInput, MaternalHealthUpdateWithoutPrenatalVisitsInput>, MaternalHealthUncheckedUpdateWithoutPrenatalVisitsInput>
  }

  export type LaboratoryTestUpdateManyWithoutPrenatalVisitNestedInput = {
    create?: XOR<LaboratoryTestCreateWithoutPrenatalVisitInput, LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput> | LaboratoryTestCreateWithoutPrenatalVisitInput[] | LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput | LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput[]
    upsert?: LaboratoryTestUpsertWithWhereUniqueWithoutPrenatalVisitInput | LaboratoryTestUpsertWithWhereUniqueWithoutPrenatalVisitInput[]
    createMany?: LaboratoryTestCreateManyPrenatalVisitInputEnvelope
    set?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    disconnect?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    delete?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    connect?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    update?: LaboratoryTestUpdateWithWhereUniqueWithoutPrenatalVisitInput | LaboratoryTestUpdateWithWhereUniqueWithoutPrenatalVisitInput[]
    updateMany?: LaboratoryTestUpdateManyWithWhereWithoutPrenatalVisitInput | LaboratoryTestUpdateManyWithWhereWithoutPrenatalVisitInput[]
    deleteMany?: LaboratoryTestScalarWhereInput | LaboratoryTestScalarWhereInput[]
  }

  export type InterventionUpdateManyWithoutPrenatalVisitNestedInput = {
    create?: XOR<InterventionCreateWithoutPrenatalVisitInput, InterventionUncheckedCreateWithoutPrenatalVisitInput> | InterventionCreateWithoutPrenatalVisitInput[] | InterventionUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPrenatalVisitInput | InterventionCreateOrConnectWithoutPrenatalVisitInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutPrenatalVisitInput | InterventionUpsertWithWhereUniqueWithoutPrenatalVisitInput[]
    createMany?: InterventionCreateManyPrenatalVisitInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutPrenatalVisitInput | InterventionUpdateWithWhereUniqueWithoutPrenatalVisitInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutPrenatalVisitInput | InterventionUpdateManyWithWhereWithoutPrenatalVisitInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type LaboratoryTestUncheckedUpdateManyWithoutPrenatalVisitNestedInput = {
    create?: XOR<LaboratoryTestCreateWithoutPrenatalVisitInput, LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput> | LaboratoryTestCreateWithoutPrenatalVisitInput[] | LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput | LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput[]
    upsert?: LaboratoryTestUpsertWithWhereUniqueWithoutPrenatalVisitInput | LaboratoryTestUpsertWithWhereUniqueWithoutPrenatalVisitInput[]
    createMany?: LaboratoryTestCreateManyPrenatalVisitInputEnvelope
    set?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    disconnect?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    delete?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    connect?: LaboratoryTestWhereUniqueInput | LaboratoryTestWhereUniqueInput[]
    update?: LaboratoryTestUpdateWithWhereUniqueWithoutPrenatalVisitInput | LaboratoryTestUpdateWithWhereUniqueWithoutPrenatalVisitInput[]
    updateMany?: LaboratoryTestUpdateManyWithWhereWithoutPrenatalVisitInput | LaboratoryTestUpdateManyWithWhereWithoutPrenatalVisitInput[]
    deleteMany?: LaboratoryTestScalarWhereInput | LaboratoryTestScalarWhereInput[]
  }

  export type InterventionUncheckedUpdateManyWithoutPrenatalVisitNestedInput = {
    create?: XOR<InterventionCreateWithoutPrenatalVisitInput, InterventionUncheckedCreateWithoutPrenatalVisitInput> | InterventionCreateWithoutPrenatalVisitInput[] | InterventionUncheckedCreateWithoutPrenatalVisitInput[]
    connectOrCreate?: InterventionCreateOrConnectWithoutPrenatalVisitInput | InterventionCreateOrConnectWithoutPrenatalVisitInput[]
    upsert?: InterventionUpsertWithWhereUniqueWithoutPrenatalVisitInput | InterventionUpsertWithWhereUniqueWithoutPrenatalVisitInput[]
    createMany?: InterventionCreateManyPrenatalVisitInputEnvelope
    set?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    disconnect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    delete?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    connect?: InterventionWhereUniqueInput | InterventionWhereUniqueInput[]
    update?: InterventionUpdateWithWhereUniqueWithoutPrenatalVisitInput | InterventionUpdateWithWhereUniqueWithoutPrenatalVisitInput[]
    updateMany?: InterventionUpdateManyWithWhereWithoutPrenatalVisitInput | InterventionUpdateManyWithWhereWithoutPrenatalVisitInput[]
    deleteMany?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
  }

  export type PrenatalVisitCreateNestedOneWithoutLaboratoryTestsInput = {
    create?: XOR<PrenatalVisitCreateWithoutLaboratoryTestsInput, PrenatalVisitUncheckedCreateWithoutLaboratoryTestsInput>
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutLaboratoryTestsInput
    connect?: PrenatalVisitWhereUniqueInput
  }

  export type PrenatalVisitUpdateOneRequiredWithoutLaboratoryTestsNestedInput = {
    create?: XOR<PrenatalVisitCreateWithoutLaboratoryTestsInput, PrenatalVisitUncheckedCreateWithoutLaboratoryTestsInput>
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutLaboratoryTestsInput
    upsert?: PrenatalVisitUpsertWithoutLaboratoryTestsInput
    connect?: PrenatalVisitWhereUniqueInput
    update?: XOR<XOR<PrenatalVisitUpdateToOneWithWhereWithoutLaboratoryTestsInput, PrenatalVisitUpdateWithoutLaboratoryTestsInput>, PrenatalVisitUncheckedUpdateWithoutLaboratoryTestsInput>
  }

  export type PrenatalVisitCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<PrenatalVisitCreateWithoutInterventionsInput, PrenatalVisitUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutInterventionsInput
    connect?: PrenatalVisitWhereUniqueInput
  }

  export type PrenatalVisitUpdateOneRequiredWithoutInterventionsNestedInput = {
    create?: XOR<PrenatalVisitCreateWithoutInterventionsInput, PrenatalVisitUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: PrenatalVisitCreateOrConnectWithoutInterventionsInput
    upsert?: PrenatalVisitUpsertWithoutInterventionsInput
    connect?: PrenatalVisitWhereUniqueInput
    update?: XOR<XOR<PrenatalVisitUpdateToOneWithWhereWithoutInterventionsInput, PrenatalVisitUpdateWithoutInterventionsInput>, PrenatalVisitUncheckedUpdateWithoutInterventionsInput>
  }

  export type UserProfileCreateNestedOneWithoutBirthInformationInput = {
    create?: XOR<UserProfileCreateWithoutBirthInformationInput, UserProfileUncheckedCreateWithoutBirthInformationInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutBirthInformationInput
    connect?: UserProfileWhereUniqueInput
  }

  export type MaternalHealthCreateNestedOneWithoutBirthInformationInput = {
    create?: XOR<MaternalHealthCreateWithoutBirthInformationInput, MaternalHealthUncheckedCreateWithoutBirthInformationInput>
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutBirthInformationInput
    connect?: MaternalHealthWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutBirthInformationNestedInput = {
    create?: XOR<UserProfileCreateWithoutBirthInformationInput, UserProfileUncheckedCreateWithoutBirthInformationInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutBirthInformationInput
    upsert?: UserProfileUpsertWithoutBirthInformationInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutBirthInformationInput, UserProfileUpdateWithoutBirthInformationInput>, UserProfileUncheckedUpdateWithoutBirthInformationInput>
  }

  export type MaternalHealthUpdateOneRequiredWithoutBirthInformationNestedInput = {
    create?: XOR<MaternalHealthCreateWithoutBirthInformationInput, MaternalHealthUncheckedCreateWithoutBirthInformationInput>
    connectOrCreate?: MaternalHealthCreateOrConnectWithoutBirthInformationInput
    upsert?: MaternalHealthUpsertWithoutBirthInformationInput
    connect?: MaternalHealthWhereUniqueInput
    update?: XOR<XOR<MaternalHealthUpdateToOneWithWhereWithoutBirthInformationInput, MaternalHealthUpdateWithoutBirthInformationInput>, MaternalHealthUncheckedUpdateWithoutBirthInformationInput>
  }

  export type UserProfileCreateNestedOneWithoutImmunizationEventsInput = {
    create?: XOR<UserProfileCreateWithoutImmunizationEventsInput, UserProfileUncheckedCreateWithoutImmunizationEventsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutImmunizationEventsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type VaccineGivenCreateNestedManyWithoutImmunizationEventInput = {
    create?: XOR<VaccineGivenCreateWithoutImmunizationEventInput, VaccineGivenUncheckedCreateWithoutImmunizationEventInput> | VaccineGivenCreateWithoutImmunizationEventInput[] | VaccineGivenUncheckedCreateWithoutImmunizationEventInput[]
    connectOrCreate?: VaccineGivenCreateOrConnectWithoutImmunizationEventInput | VaccineGivenCreateOrConnectWithoutImmunizationEventInput[]
    createMany?: VaccineGivenCreateManyImmunizationEventInputEnvelope
    connect?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
  }

  export type VaccineGivenUncheckedCreateNestedManyWithoutImmunizationEventInput = {
    create?: XOR<VaccineGivenCreateWithoutImmunizationEventInput, VaccineGivenUncheckedCreateWithoutImmunizationEventInput> | VaccineGivenCreateWithoutImmunizationEventInput[] | VaccineGivenUncheckedCreateWithoutImmunizationEventInput[]
    connectOrCreate?: VaccineGivenCreateOrConnectWithoutImmunizationEventInput | VaccineGivenCreateOrConnectWithoutImmunizationEventInput[]
    createMany?: VaccineGivenCreateManyImmunizationEventInputEnvelope
    connect?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileUpdateOneRequiredWithoutImmunizationEventsNestedInput = {
    create?: XOR<UserProfileCreateWithoutImmunizationEventsInput, UserProfileUncheckedCreateWithoutImmunizationEventsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutImmunizationEventsInput
    upsert?: UserProfileUpsertWithoutImmunizationEventsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutImmunizationEventsInput, UserProfileUpdateWithoutImmunizationEventsInput>, UserProfileUncheckedUpdateWithoutImmunizationEventsInput>
  }

  export type VaccineGivenUpdateManyWithoutImmunizationEventNestedInput = {
    create?: XOR<VaccineGivenCreateWithoutImmunizationEventInput, VaccineGivenUncheckedCreateWithoutImmunizationEventInput> | VaccineGivenCreateWithoutImmunizationEventInput[] | VaccineGivenUncheckedCreateWithoutImmunizationEventInput[]
    connectOrCreate?: VaccineGivenCreateOrConnectWithoutImmunizationEventInput | VaccineGivenCreateOrConnectWithoutImmunizationEventInput[]
    upsert?: VaccineGivenUpsertWithWhereUniqueWithoutImmunizationEventInput | VaccineGivenUpsertWithWhereUniqueWithoutImmunizationEventInput[]
    createMany?: VaccineGivenCreateManyImmunizationEventInputEnvelope
    set?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    disconnect?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    delete?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    connect?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    update?: VaccineGivenUpdateWithWhereUniqueWithoutImmunizationEventInput | VaccineGivenUpdateWithWhereUniqueWithoutImmunizationEventInput[]
    updateMany?: VaccineGivenUpdateManyWithWhereWithoutImmunizationEventInput | VaccineGivenUpdateManyWithWhereWithoutImmunizationEventInput[]
    deleteMany?: VaccineGivenScalarWhereInput | VaccineGivenScalarWhereInput[]
  }

  export type VaccineGivenUncheckedUpdateManyWithoutImmunizationEventNestedInput = {
    create?: XOR<VaccineGivenCreateWithoutImmunizationEventInput, VaccineGivenUncheckedCreateWithoutImmunizationEventInput> | VaccineGivenCreateWithoutImmunizationEventInput[] | VaccineGivenUncheckedCreateWithoutImmunizationEventInput[]
    connectOrCreate?: VaccineGivenCreateOrConnectWithoutImmunizationEventInput | VaccineGivenCreateOrConnectWithoutImmunizationEventInput[]
    upsert?: VaccineGivenUpsertWithWhereUniqueWithoutImmunizationEventInput | VaccineGivenUpsertWithWhereUniqueWithoutImmunizationEventInput[]
    createMany?: VaccineGivenCreateManyImmunizationEventInputEnvelope
    set?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    disconnect?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    delete?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    connect?: VaccineGivenWhereUniqueInput | VaccineGivenWhereUniqueInput[]
    update?: VaccineGivenUpdateWithWhereUniqueWithoutImmunizationEventInput | VaccineGivenUpdateWithWhereUniqueWithoutImmunizationEventInput[]
    updateMany?: VaccineGivenUpdateManyWithWhereWithoutImmunizationEventInput | VaccineGivenUpdateManyWithWhereWithoutImmunizationEventInput[]
    deleteMany?: VaccineGivenScalarWhereInput | VaccineGivenScalarWhereInput[]
  }

  export type ImmunizationEventCreateNestedOneWithoutVaccinesGivenInput = {
    create?: XOR<ImmunizationEventCreateWithoutVaccinesGivenInput, ImmunizationEventUncheckedCreateWithoutVaccinesGivenInput>
    connectOrCreate?: ImmunizationEventCreateOrConnectWithoutVaccinesGivenInput
    connect?: ImmunizationEventWhereUniqueInput
  }

  export type ImmunizationEventUpdateOneRequiredWithoutVaccinesGivenNestedInput = {
    create?: XOR<ImmunizationEventCreateWithoutVaccinesGivenInput, ImmunizationEventUncheckedCreateWithoutVaccinesGivenInput>
    connectOrCreate?: ImmunizationEventCreateOrConnectWithoutVaccinesGivenInput
    upsert?: ImmunizationEventUpsertWithoutVaccinesGivenInput
    connect?: ImmunizationEventWhereUniqueInput
    update?: XOR<XOR<ImmunizationEventUpdateToOneWithWhereWithoutVaccinesGivenInput, ImmunizationEventUpdateWithoutVaccinesGivenInput>, ImmunizationEventUncheckedUpdateWithoutVaccinesGivenInput>
  }

  export type UserProfileCreateNestedOneWithoutVitalSignsInput = {
    create?: XOR<UserProfileCreateWithoutVitalSignsInput, UserProfileUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutVitalSignsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserProfileUpdateOneRequiredWithoutVitalSignsNestedInput = {
    create?: XOR<UserProfileCreateWithoutVitalSignsInput, UserProfileUncheckedCreateWithoutVitalSignsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutVitalSignsInput
    upsert?: UserProfileUpsertWithoutVitalSignsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutVitalSignsInput, UserProfileUpdateWithoutVitalSignsInput>, UserProfileUncheckedUpdateWithoutVitalSignsInput>
  }

  export type UserProfileCreateNestedOneWithoutAnthropometricMeasurementsInput = {
    create?: XOR<UserProfileCreateWithoutAnthropometricMeasurementsInput, UserProfileUncheckedCreateWithoutAnthropometricMeasurementsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAnthropometricMeasurementsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutAnthropometricMeasurementsNestedInput = {
    create?: XOR<UserProfileCreateWithoutAnthropometricMeasurementsInput, UserProfileUncheckedCreateWithoutAnthropometricMeasurementsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAnthropometricMeasurementsInput
    upsert?: UserProfileUpsertWithoutAnthropometricMeasurementsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutAnthropometricMeasurementsInput, UserProfileUpdateWithoutAnthropometricMeasurementsInput>, UserProfileUncheckedUpdateWithoutAnthropometricMeasurementsInput>
  }

  export type UserProfileCreateNestedOneWithoutGrowthTrackingInput = {
    create?: XOR<UserProfileCreateWithoutGrowthTrackingInput, UserProfileUncheckedCreateWithoutGrowthTrackingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutGrowthTrackingInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutGrowthTrackingNestedInput = {
    create?: XOR<UserProfileCreateWithoutGrowthTrackingInput, UserProfileUncheckedCreateWithoutGrowthTrackingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutGrowthTrackingInput
    upsert?: UserProfileUpsertWithoutGrowthTrackingInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutGrowthTrackingInput, UserProfileUpdateWithoutGrowthTrackingInput>, UserProfileUncheckedUpdateWithoutGrowthTrackingInput>
  }

  export type UserProfileCreateNestedOneWithoutNcdRiskAssessmentsInput = {
    create?: XOR<UserProfileCreateWithoutNcdRiskAssessmentsInput, UserProfileUncheckedCreateWithoutNcdRiskAssessmentsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNcdRiskAssessmentsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutNcdRiskAssessmentsNestedInput = {
    create?: XOR<UserProfileCreateWithoutNcdRiskAssessmentsInput, UserProfileUncheckedCreateWithoutNcdRiskAssessmentsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNcdRiskAssessmentsInput
    upsert?: UserProfileUpsertWithoutNcdRiskAssessmentsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutNcdRiskAssessmentsInput, UserProfileUpdateWithoutNcdRiskAssessmentsInput>, UserProfileUncheckedUpdateWithoutNcdRiskAssessmentsInput>
  }

  export type UserProfileCreateNestedOneWithoutVisitRecordsInput = {
    create?: XOR<UserProfileCreateWithoutVisitRecordsInput, UserProfileUncheckedCreateWithoutVisitRecordsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutVisitRecordsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutVisitRecordsNestedInput = {
    create?: XOR<UserProfileCreateWithoutVisitRecordsInput, UserProfileUncheckedCreateWithoutVisitRecordsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutVisitRecordsInput
    upsert?: UserProfileUpsertWithoutVisitRecordsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutVisitRecordsInput, UserProfileUpdateWithoutVisitRecordsInput>, UserProfileUncheckedUpdateWithoutVisitRecordsInput>
  }

  export type UserProfileCreateNestedOneWithoutHealthEducationInput = {
    create?: XOR<UserProfileCreateWithoutHealthEducationInput, UserProfileUncheckedCreateWithoutHealthEducationInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutHealthEducationInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutHealthEducationNestedInput = {
    create?: XOR<UserProfileCreateWithoutHealthEducationInput, UserProfileUncheckedCreateWithoutHealthEducationInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutHealthEducationInput
    upsert?: UserProfileUpsertWithoutHealthEducationInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutHealthEducationInput, UserProfileUpdateWithoutHealthEducationInput>, UserProfileUncheckedUpdateWithoutHealthEducationInput>
  }

  export type UserProfileCreateNestedOneWithoutNutritionalCounselingInput = {
    create?: XOR<UserProfileCreateWithoutNutritionalCounselingInput, UserProfileUncheckedCreateWithoutNutritionalCounselingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNutritionalCounselingInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutNutritionalCounselingNestedInput = {
    create?: XOR<UserProfileCreateWithoutNutritionalCounselingInput, UserProfileUncheckedCreateWithoutNutritionalCounselingInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutNutritionalCounselingInput
    upsert?: UserProfileUpsertWithoutNutritionalCounselingInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutNutritionalCounselingInput, UserProfileUpdateWithoutNutritionalCounselingInput>, UserProfileUncheckedUpdateWithoutNutritionalCounselingInput>
  }

  export type UserProfileCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserProfileCreateWithoutReferralsInput, UserProfileUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReferralsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UserProfileCreateWithoutReferralsInput, UserProfileUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutReferralsInput
    upsert?: UserProfileUpsertWithoutReferralsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutReferralsInput, UserProfileUpdateWithoutReferralsInput>, UserProfileUncheckedUpdateWithoutReferralsInput>
  }

  export type UserProfileCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserProfileCreateWithoutAppointmentsInput, UserProfileUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAppointmentsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<UserProfileCreateWithoutAppointmentsInput, UserProfileUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutAppointmentsInput
    upsert?: UserProfileUpsertWithoutAppointmentsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutAppointmentsInput, UserProfileUpdateWithoutAppointmentsInput>, UserProfileUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserProfileCreateNestedOneWithoutImmunizationRemindersInput = {
    create?: XOR<UserProfileCreateWithoutImmunizationRemindersInput, UserProfileUncheckedCreateWithoutImmunizationRemindersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutImmunizationRemindersInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutImmunizationRemindersNestedInput = {
    create?: XOR<UserProfileCreateWithoutImmunizationRemindersInput, UserProfileUncheckedCreateWithoutImmunizationRemindersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutImmunizationRemindersInput
    upsert?: UserProfileUpsertWithoutImmunizationRemindersInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutImmunizationRemindersInput, UserProfileUpdateWithoutImmunizationRemindersInput>, UserProfileUncheckedUpdateWithoutImmunizationRemindersInput>
  }

  export type UserProfileCreateNestedOneWithoutTestRemindersInput = {
    create?: XOR<UserProfileCreateWithoutTestRemindersInput, UserProfileUncheckedCreateWithoutTestRemindersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutTestRemindersInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutTestRemindersNestedInput = {
    create?: XOR<UserProfileCreateWithoutTestRemindersInput, UserProfileUncheckedCreateWithoutTestRemindersInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutTestRemindersInput
    upsert?: UserProfileUpsertWithoutTestRemindersInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutTestRemindersInput, UserProfileUpdateWithoutTestRemindersInput>, UserProfileUncheckedUpdateWithoutTestRemindersInput>
  }

  export type UserProfileCreateNestedOneWithoutVirtualCheckupsInput = {
    create?: XOR<UserProfileCreateWithoutVirtualCheckupsInput, UserProfileUncheckedCreateWithoutVirtualCheckupsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutVirtualCheckupsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type HealthWorkerCreateNestedOneWithoutVirtualCheckupsInput = {
    create?: XOR<HealthWorkerCreateWithoutVirtualCheckupsInput, HealthWorkerUncheckedCreateWithoutVirtualCheckupsInput>
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutVirtualCheckupsInput
    connect?: HealthWorkerWhereUniqueInput
  }

  export type VirtualCheckupNoteCreateNestedManyWithoutVirtualCheckupInput = {
    create?: XOR<VirtualCheckupNoteCreateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput> | VirtualCheckupNoteCreateWithoutVirtualCheckupInput[] | VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput[]
    connectOrCreate?: VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput | VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput[]
    createMany?: VirtualCheckupNoteCreateManyVirtualCheckupInputEnvelope
    connect?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
  }

  export type VirtualCheckupNoteUncheckedCreateNestedManyWithoutVirtualCheckupInput = {
    create?: XOR<VirtualCheckupNoteCreateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput> | VirtualCheckupNoteCreateWithoutVirtualCheckupInput[] | VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput[]
    connectOrCreate?: VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput | VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput[]
    createMany?: VirtualCheckupNoteCreateManyVirtualCheckupInputEnvelope
    connect?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
  }

  export type UserProfileUpdateOneRequiredWithoutVirtualCheckupsNestedInput = {
    create?: XOR<UserProfileCreateWithoutVirtualCheckupsInput, UserProfileUncheckedCreateWithoutVirtualCheckupsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutVirtualCheckupsInput
    upsert?: UserProfileUpsertWithoutVirtualCheckupsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutVirtualCheckupsInput, UserProfileUpdateWithoutVirtualCheckupsInput>, UserProfileUncheckedUpdateWithoutVirtualCheckupsInput>
  }

  export type HealthWorkerUpdateOneRequiredWithoutVirtualCheckupsNestedInput = {
    create?: XOR<HealthWorkerCreateWithoutVirtualCheckupsInput, HealthWorkerUncheckedCreateWithoutVirtualCheckupsInput>
    connectOrCreate?: HealthWorkerCreateOrConnectWithoutVirtualCheckupsInput
    upsert?: HealthWorkerUpsertWithoutVirtualCheckupsInput
    connect?: HealthWorkerWhereUniqueInput
    update?: XOR<XOR<HealthWorkerUpdateToOneWithWhereWithoutVirtualCheckupsInput, HealthWorkerUpdateWithoutVirtualCheckupsInput>, HealthWorkerUncheckedUpdateWithoutVirtualCheckupsInput>
  }

  export type VirtualCheckupNoteUpdateManyWithoutVirtualCheckupNestedInput = {
    create?: XOR<VirtualCheckupNoteCreateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput> | VirtualCheckupNoteCreateWithoutVirtualCheckupInput[] | VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput[]
    connectOrCreate?: VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput | VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput[]
    upsert?: VirtualCheckupNoteUpsertWithWhereUniqueWithoutVirtualCheckupInput | VirtualCheckupNoteUpsertWithWhereUniqueWithoutVirtualCheckupInput[]
    createMany?: VirtualCheckupNoteCreateManyVirtualCheckupInputEnvelope
    set?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    disconnect?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    delete?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    connect?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    update?: VirtualCheckupNoteUpdateWithWhereUniqueWithoutVirtualCheckupInput | VirtualCheckupNoteUpdateWithWhereUniqueWithoutVirtualCheckupInput[]
    updateMany?: VirtualCheckupNoteUpdateManyWithWhereWithoutVirtualCheckupInput | VirtualCheckupNoteUpdateManyWithWhereWithoutVirtualCheckupInput[]
    deleteMany?: VirtualCheckupNoteScalarWhereInput | VirtualCheckupNoteScalarWhereInput[]
  }

  export type VirtualCheckupNoteUncheckedUpdateManyWithoutVirtualCheckupNestedInput = {
    create?: XOR<VirtualCheckupNoteCreateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput> | VirtualCheckupNoteCreateWithoutVirtualCheckupInput[] | VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput[]
    connectOrCreate?: VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput | VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput[]
    upsert?: VirtualCheckupNoteUpsertWithWhereUniqueWithoutVirtualCheckupInput | VirtualCheckupNoteUpsertWithWhereUniqueWithoutVirtualCheckupInput[]
    createMany?: VirtualCheckupNoteCreateManyVirtualCheckupInputEnvelope
    set?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    disconnect?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    delete?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    connect?: VirtualCheckupNoteWhereUniqueInput | VirtualCheckupNoteWhereUniqueInput[]
    update?: VirtualCheckupNoteUpdateWithWhereUniqueWithoutVirtualCheckupInput | VirtualCheckupNoteUpdateWithWhereUniqueWithoutVirtualCheckupInput[]
    updateMany?: VirtualCheckupNoteUpdateManyWithWhereWithoutVirtualCheckupInput | VirtualCheckupNoteUpdateManyWithWhereWithoutVirtualCheckupInput[]
    deleteMany?: VirtualCheckupNoteScalarWhereInput | VirtualCheckupNoteScalarWhereInput[]
  }

  export type VirtualCheckupCreateNestedOneWithoutVirtualCheckupNotesInput = {
    create?: XOR<VirtualCheckupCreateWithoutVirtualCheckupNotesInput, VirtualCheckupUncheckedCreateWithoutVirtualCheckupNotesInput>
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutVirtualCheckupNotesInput
    connect?: VirtualCheckupWhereUniqueInput
  }

  export type VirtualCheckupUpdateOneRequiredWithoutVirtualCheckupNotesNestedInput = {
    create?: XOR<VirtualCheckupCreateWithoutVirtualCheckupNotesInput, VirtualCheckupUncheckedCreateWithoutVirtualCheckupNotesInput>
    connectOrCreate?: VirtualCheckupCreateOrConnectWithoutVirtualCheckupNotesInput
    upsert?: VirtualCheckupUpsertWithoutVirtualCheckupNotesInput
    connect?: VirtualCheckupWhereUniqueInput
    update?: XOR<XOR<VirtualCheckupUpdateToOneWithWhereWithoutVirtualCheckupNotesInput, VirtualCheckupUpdateWithoutVirtualCheckupNotesInput>, VirtualCheckupUncheckedUpdateWithoutVirtualCheckupNotesInput>
  }

  export type AccountCreateNestedOneWithoutEventsInput = {
    create?: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEventsInput
    connect?: AccountWhereUniqueInput
  }

  export type EventRegistrationCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEventsInput
    upsert?: AccountUpsertWithoutEventsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutEventsInput, AccountUpdateWithoutEventsInput>, AccountUncheckedUpdateWithoutEventsInput>
  }

  export type EventRegistrationUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutEventRegistrationsInput = {
    create?: XOR<EventCreateWithoutEventRegistrationsInput, EventUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventRegistrationsInput
    connect?: EventWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutEventRegistrationsInput = {
    create?: XOR<UserProfileCreateWithoutEventRegistrationsInput, UserProfileUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutEventRegistrationsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEventRegistrationsNestedInput = {
    create?: XOR<EventCreateWithoutEventRegistrationsInput, EventUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventRegistrationsInput
    upsert?: EventUpsertWithoutEventRegistrationsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventRegistrationsInput, EventUpdateWithoutEventRegistrationsInput>, EventUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type UserProfileUpdateOneRequiredWithoutEventRegistrationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutEventRegistrationsInput, UserProfileUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutEventRegistrationsInput
    upsert?: UserProfileUpsertWithoutEventRegistrationsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutEventRegistrationsInput, UserProfileUpdateWithoutEventRegistrationsInput>, UserProfileUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type AccountCreateNestedOneWithoutMedicalProgramsInput = {
    create?: XOR<AccountCreateWithoutMedicalProgramsInput, AccountUncheckedCreateWithoutMedicalProgramsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutMedicalProgramsInput
    connect?: AccountWhereUniqueInput
  }

  export type ProgramParticipationCreateNestedManyWithoutMedicalProgramInput = {
    create?: XOR<ProgramParticipationCreateWithoutMedicalProgramInput, ProgramParticipationUncheckedCreateWithoutMedicalProgramInput> | ProgramParticipationCreateWithoutMedicalProgramInput[] | ProgramParticipationUncheckedCreateWithoutMedicalProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutMedicalProgramInput | ProgramParticipationCreateOrConnectWithoutMedicalProgramInput[]
    createMany?: ProgramParticipationCreateManyMedicalProgramInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type ProgramParticipationUncheckedCreateNestedManyWithoutMedicalProgramInput = {
    create?: XOR<ProgramParticipationCreateWithoutMedicalProgramInput, ProgramParticipationUncheckedCreateWithoutMedicalProgramInput> | ProgramParticipationCreateWithoutMedicalProgramInput[] | ProgramParticipationUncheckedCreateWithoutMedicalProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutMedicalProgramInput | ProgramParticipationCreateOrConnectWithoutMedicalProgramInput[]
    createMany?: ProgramParticipationCreateManyMedicalProgramInputEnvelope
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutMedicalProgramsNestedInput = {
    create?: XOR<AccountCreateWithoutMedicalProgramsInput, AccountUncheckedCreateWithoutMedicalProgramsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutMedicalProgramsInput
    upsert?: AccountUpsertWithoutMedicalProgramsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutMedicalProgramsInput, AccountUpdateWithoutMedicalProgramsInput>, AccountUncheckedUpdateWithoutMedicalProgramsInput>
  }

  export type ProgramParticipationUpdateManyWithoutMedicalProgramNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutMedicalProgramInput, ProgramParticipationUncheckedCreateWithoutMedicalProgramInput> | ProgramParticipationCreateWithoutMedicalProgramInput[] | ProgramParticipationUncheckedCreateWithoutMedicalProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutMedicalProgramInput | ProgramParticipationCreateOrConnectWithoutMedicalProgramInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutMedicalProgramInput | ProgramParticipationUpsertWithWhereUniqueWithoutMedicalProgramInput[]
    createMany?: ProgramParticipationCreateManyMedicalProgramInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutMedicalProgramInput | ProgramParticipationUpdateWithWhereUniqueWithoutMedicalProgramInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutMedicalProgramInput | ProgramParticipationUpdateManyWithWhereWithoutMedicalProgramInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutMedicalProgramNestedInput = {
    create?: XOR<ProgramParticipationCreateWithoutMedicalProgramInput, ProgramParticipationUncheckedCreateWithoutMedicalProgramInput> | ProgramParticipationCreateWithoutMedicalProgramInput[] | ProgramParticipationUncheckedCreateWithoutMedicalProgramInput[]
    connectOrCreate?: ProgramParticipationCreateOrConnectWithoutMedicalProgramInput | ProgramParticipationCreateOrConnectWithoutMedicalProgramInput[]
    upsert?: ProgramParticipationUpsertWithWhereUniqueWithoutMedicalProgramInput | ProgramParticipationUpsertWithWhereUniqueWithoutMedicalProgramInput[]
    createMany?: ProgramParticipationCreateManyMedicalProgramInputEnvelope
    set?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    disconnect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    delete?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    connect?: ProgramParticipationWhereUniqueInput | ProgramParticipationWhereUniqueInput[]
    update?: ProgramParticipationUpdateWithWhereUniqueWithoutMedicalProgramInput | ProgramParticipationUpdateWithWhereUniqueWithoutMedicalProgramInput[]
    updateMany?: ProgramParticipationUpdateManyWithWhereWithoutMedicalProgramInput | ProgramParticipationUpdateManyWithWhereWithoutMedicalProgramInput[]
    deleteMany?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
  }

  export type MedicalProgramCreateNestedOneWithoutProgramParticipationsInput = {
    create?: XOR<MedicalProgramCreateWithoutProgramParticipationsInput, MedicalProgramUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: MedicalProgramCreateOrConnectWithoutProgramParticipationsInput
    connect?: MedicalProgramWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutProgramParticipationsInput = {
    create?: XOR<UserProfileCreateWithoutProgramParticipationsInput, UserProfileUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutProgramParticipationsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type MedicalProgramUpdateOneRequiredWithoutProgramParticipationsNestedInput = {
    create?: XOR<MedicalProgramCreateWithoutProgramParticipationsInput, MedicalProgramUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: MedicalProgramCreateOrConnectWithoutProgramParticipationsInput
    upsert?: MedicalProgramUpsertWithoutProgramParticipationsInput
    connect?: MedicalProgramWhereUniqueInput
    update?: XOR<XOR<MedicalProgramUpdateToOneWithWhereWithoutProgramParticipationsInput, MedicalProgramUpdateWithoutProgramParticipationsInput>, MedicalProgramUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type UserProfileUpdateOneRequiredWithoutProgramParticipationsNestedInput = {
    create?: XOR<UserProfileCreateWithoutProgramParticipationsInput, UserProfileUncheckedCreateWithoutProgramParticipationsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutProgramParticipationsInput
    upsert?: UserProfileUpsertWithoutProgramParticipationsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutProgramParticipationsInput, UserProfileUpdateWithoutProgramParticipationsInput>, UserProfileUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type UserProfileCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<UserProfileCreateWithoutInquiriesInput, UserProfileUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutInquiriesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type InquiryResponseCreateNestedManyWithoutInquiryInput = {
    create?: XOR<InquiryResponseCreateWithoutInquiryInput, InquiryResponseUncheckedCreateWithoutInquiryInput> | InquiryResponseCreateWithoutInquiryInput[] | InquiryResponseUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutInquiryInput | InquiryResponseCreateOrConnectWithoutInquiryInput[]
    createMany?: InquiryResponseCreateManyInquiryInputEnvelope
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
  }

  export type InquiryResponseUncheckedCreateNestedManyWithoutInquiryInput = {
    create?: XOR<InquiryResponseCreateWithoutInquiryInput, InquiryResponseUncheckedCreateWithoutInquiryInput> | InquiryResponseCreateWithoutInquiryInput[] | InquiryResponseUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutInquiryInput | InquiryResponseCreateOrConnectWithoutInquiryInput[]
    createMany?: InquiryResponseCreateManyInquiryInputEnvelope
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
  }

  export type UserProfileUpdateOneRequiredWithoutInquiriesNestedInput = {
    create?: XOR<UserProfileCreateWithoutInquiriesInput, UserProfileUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutInquiriesInput
    upsert?: UserProfileUpsertWithoutInquiriesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutInquiriesInput, UserProfileUpdateWithoutInquiriesInput>, UserProfileUncheckedUpdateWithoutInquiriesInput>
  }

  export type InquiryResponseUpdateManyWithoutInquiryNestedInput = {
    create?: XOR<InquiryResponseCreateWithoutInquiryInput, InquiryResponseUncheckedCreateWithoutInquiryInput> | InquiryResponseCreateWithoutInquiryInput[] | InquiryResponseUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutInquiryInput | InquiryResponseCreateOrConnectWithoutInquiryInput[]
    upsert?: InquiryResponseUpsertWithWhereUniqueWithoutInquiryInput | InquiryResponseUpsertWithWhereUniqueWithoutInquiryInput[]
    createMany?: InquiryResponseCreateManyInquiryInputEnvelope
    set?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    disconnect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    delete?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    update?: InquiryResponseUpdateWithWhereUniqueWithoutInquiryInput | InquiryResponseUpdateWithWhereUniqueWithoutInquiryInput[]
    updateMany?: InquiryResponseUpdateManyWithWhereWithoutInquiryInput | InquiryResponseUpdateManyWithWhereWithoutInquiryInput[]
    deleteMany?: InquiryResponseScalarWhereInput | InquiryResponseScalarWhereInput[]
  }

  export type InquiryResponseUncheckedUpdateManyWithoutInquiryNestedInput = {
    create?: XOR<InquiryResponseCreateWithoutInquiryInput, InquiryResponseUncheckedCreateWithoutInquiryInput> | InquiryResponseCreateWithoutInquiryInput[] | InquiryResponseUncheckedCreateWithoutInquiryInput[]
    connectOrCreate?: InquiryResponseCreateOrConnectWithoutInquiryInput | InquiryResponseCreateOrConnectWithoutInquiryInput[]
    upsert?: InquiryResponseUpsertWithWhereUniqueWithoutInquiryInput | InquiryResponseUpsertWithWhereUniqueWithoutInquiryInput[]
    createMany?: InquiryResponseCreateManyInquiryInputEnvelope
    set?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    disconnect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    delete?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    connect?: InquiryResponseWhereUniqueInput | InquiryResponseWhereUniqueInput[]
    update?: InquiryResponseUpdateWithWhereUniqueWithoutInquiryInput | InquiryResponseUpdateWithWhereUniqueWithoutInquiryInput[]
    updateMany?: InquiryResponseUpdateManyWithWhereWithoutInquiryInput | InquiryResponseUpdateManyWithWhereWithoutInquiryInput[]
    deleteMany?: InquiryResponseScalarWhereInput | InquiryResponseScalarWhereInput[]
  }

  export type InquiryCreateNestedOneWithoutInquiryResponsesInput = {
    create?: XOR<InquiryCreateWithoutInquiryResponsesInput, InquiryUncheckedCreateWithoutInquiryResponsesInput>
    connectOrCreate?: InquiryCreateOrConnectWithoutInquiryResponsesInput
    connect?: InquiryWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutInquiryResponsesInput = {
    create?: XOR<AccountCreateWithoutInquiryResponsesInput, AccountUncheckedCreateWithoutInquiryResponsesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInquiryResponsesInput
    connect?: AccountWhereUniqueInput
  }

  export type InquiryUpdateOneRequiredWithoutInquiryResponsesNestedInput = {
    create?: XOR<InquiryCreateWithoutInquiryResponsesInput, InquiryUncheckedCreateWithoutInquiryResponsesInput>
    connectOrCreate?: InquiryCreateOrConnectWithoutInquiryResponsesInput
    upsert?: InquiryUpsertWithoutInquiryResponsesInput
    connect?: InquiryWhereUniqueInput
    update?: XOR<XOR<InquiryUpdateToOneWithWhereWithoutInquiryResponsesInput, InquiryUpdateWithoutInquiryResponsesInput>, InquiryUncheckedUpdateWithoutInquiryResponsesInput>
  }

  export type AccountUpdateOneRequiredWithoutInquiryResponsesNestedInput = {
    create?: XOR<AccountCreateWithoutInquiryResponsesInput, AccountUncheckedCreateWithoutInquiryResponsesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutInquiryResponsesInput
    upsert?: AccountUpsertWithoutInquiryResponsesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutInquiryResponsesInput, AccountUpdateWithoutInquiryResponsesInput>, AccountUncheckedUpdateWithoutInquiryResponsesInput>
  }

  export type AccountCreateNestedOneWithoutSurveysInput = {
    create?: XOR<AccountCreateWithoutSurveysInput, AccountUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSurveysInput
    connect?: AccountWhereUniqueInput
  }

  export type SurveyQuestionCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyInput, SurveyQuestionUncheckedCreateWithoutSurveyInput> | SurveyQuestionCreateWithoutSurveyInput[] | SurveyQuestionUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyInput | SurveyQuestionCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyQuestionCreateManySurveyInputEnvelope
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
  }

  export type SurveyResponseCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type SurveyQuestionUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyInput, SurveyQuestionUncheckedCreateWithoutSurveyInput> | SurveyQuestionCreateWithoutSurveyInput[] | SurveyQuestionUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyInput | SurveyQuestionCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyQuestionCreateManySurveyInputEnvelope
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
  }

  export type SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutSurveysNestedInput = {
    create?: XOR<AccountCreateWithoutSurveysInput, AccountUncheckedCreateWithoutSurveysInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSurveysInput
    upsert?: AccountUpsertWithoutSurveysInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSurveysInput, AccountUpdateWithoutSurveysInput>, AccountUncheckedUpdateWithoutSurveysInput>
  }

  export type SurveyQuestionUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyInput, SurveyQuestionUncheckedCreateWithoutSurveyInput> | SurveyQuestionCreateWithoutSurveyInput[] | SurveyQuestionUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyInput | SurveyQuestionCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput | SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyQuestionCreateManySurveyInputEnvelope
    set?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    disconnect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    delete?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    update?: SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput | SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyQuestionUpdateManyWithWhereWithoutSurveyInput | SurveyQuestionUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
  }

  export type SurveyResponseUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput | SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput | SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutSurveyInput | SurveyResponseUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type SurveyQuestionUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyInput, SurveyQuestionUncheckedCreateWithoutSurveyInput> | SurveyQuestionCreateWithoutSurveyInput[] | SurveyQuestionUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyInput | SurveyQuestionCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput | SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyQuestionCreateManySurveyInputEnvelope
    set?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    disconnect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    delete?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    connect?: SurveyQuestionWhereUniqueInput | SurveyQuestionWhereUniqueInput[]
    update?: SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput | SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyQuestionUpdateManyWithWhereWithoutSurveyInput | SurveyQuestionUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
  }

  export type SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput> | SurveyResponseCreateWithoutSurveyInput[] | SurveyResponseUncheckedCreateWithoutSurveyInput[]
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyInput | SurveyResponseCreateOrConnectWithoutSurveyInput[]
    upsert?: SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput | SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput[]
    createMany?: SurveyResponseCreateManySurveyInputEnvelope
    set?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    disconnect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    delete?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    connect?: SurveyResponseWhereUniqueInput | SurveyResponseWhereUniqueInput[]
    update?: SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput | SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput[]
    updateMany?: SurveyResponseUpdateManyWithWhereWithoutSurveyInput | SurveyResponseUpdateManyWithWhereWithoutSurveyInput[]
    deleteMany?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
  }

  export type SurveyCreateNestedOneWithoutSurveyQuestionsInput = {
    create?: XOR<SurveyCreateWithoutSurveyQuestionsInput, SurveyUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyQuestionsInput
    connect?: SurveyWhereUniqueInput
  }

  export type SurveyAnswerCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyQuestionInput, SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput> | SurveyAnswerCreateWithoutSurveyQuestionInput[] | SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput | SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput[]
    createMany?: SurveyAnswerCreateManySurveyQuestionInputEnvelope
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
  }

  export type SurveyAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyQuestionInput, SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput> | SurveyAnswerCreateWithoutSurveyQuestionInput[] | SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput | SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput[]
    createMany?: SurveyAnswerCreateManySurveyQuestionInputEnvelope
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
  }

  export type SurveyUpdateOneRequiredWithoutSurveyQuestionsNestedInput = {
    create?: XOR<SurveyCreateWithoutSurveyQuestionsInput, SurveyUncheckedCreateWithoutSurveyQuestionsInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyQuestionsInput
    upsert?: SurveyUpsertWithoutSurveyQuestionsInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutSurveyQuestionsInput, SurveyUpdateWithoutSurveyQuestionsInput>, SurveyUncheckedUpdateWithoutSurveyQuestionsInput>
  }

  export type SurveyAnswerUpdateManyWithoutSurveyQuestionNestedInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyQuestionInput, SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput> | SurveyAnswerCreateWithoutSurveyQuestionInput[] | SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput | SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput[]
    upsert?: SurveyAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput | SurveyAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput[]
    createMany?: SurveyAnswerCreateManySurveyQuestionInputEnvelope
    set?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    disconnect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    delete?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    update?: SurveyAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput | SurveyAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput[]
    updateMany?: SurveyAnswerUpdateManyWithWhereWithoutSurveyQuestionInput | SurveyAnswerUpdateManyWithWhereWithoutSurveyQuestionInput[]
    deleteMany?: SurveyAnswerScalarWhereInput | SurveyAnswerScalarWhereInput[]
  }

  export type SurveyAnswerUncheckedUpdateManyWithoutSurveyQuestionNestedInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyQuestionInput, SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput> | SurveyAnswerCreateWithoutSurveyQuestionInput[] | SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput | SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput[]
    upsert?: SurveyAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput | SurveyAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput[]
    createMany?: SurveyAnswerCreateManySurveyQuestionInputEnvelope
    set?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    disconnect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    delete?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    update?: SurveyAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput | SurveyAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput[]
    updateMany?: SurveyAnswerUpdateManyWithWhereWithoutSurveyQuestionInput | SurveyAnswerUpdateManyWithWhereWithoutSurveyQuestionInput[]
    deleteMany?: SurveyAnswerScalarWhereInput | SurveyAnswerScalarWhereInput[]
  }

  export type SurveyCreateNestedOneWithoutSurveyResponsesInput = {
    create?: XOR<SurveyCreateWithoutSurveyResponsesInput, SurveyUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyResponsesInput
    connect?: SurveyWhereUniqueInput
  }

  export type UserProfileCreateNestedOneWithoutSurveyResponsesInput = {
    create?: XOR<UserProfileCreateWithoutSurveyResponsesInput, UserProfileUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSurveyResponsesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type SurveyAnswerCreateNestedManyWithoutSurveyResponseInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyResponseInput, SurveyAnswerUncheckedCreateWithoutSurveyResponseInput> | SurveyAnswerCreateWithoutSurveyResponseInput[] | SurveyAnswerUncheckedCreateWithoutSurveyResponseInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyResponseInput | SurveyAnswerCreateOrConnectWithoutSurveyResponseInput[]
    createMany?: SurveyAnswerCreateManySurveyResponseInputEnvelope
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
  }

  export type SurveyAnswerUncheckedCreateNestedManyWithoutSurveyResponseInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyResponseInput, SurveyAnswerUncheckedCreateWithoutSurveyResponseInput> | SurveyAnswerCreateWithoutSurveyResponseInput[] | SurveyAnswerUncheckedCreateWithoutSurveyResponseInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyResponseInput | SurveyAnswerCreateOrConnectWithoutSurveyResponseInput[]
    createMany?: SurveyAnswerCreateManySurveyResponseInputEnvelope
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
  }

  export type SurveyUpdateOneRequiredWithoutSurveyResponsesNestedInput = {
    create?: XOR<SurveyCreateWithoutSurveyResponsesInput, SurveyUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: SurveyCreateOrConnectWithoutSurveyResponsesInput
    upsert?: SurveyUpsertWithoutSurveyResponsesInput
    connect?: SurveyWhereUniqueInput
    update?: XOR<XOR<SurveyUpdateToOneWithWhereWithoutSurveyResponsesInput, SurveyUpdateWithoutSurveyResponsesInput>, SurveyUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type UserProfileUpdateOneRequiredWithoutSurveyResponsesNestedInput = {
    create?: XOR<UserProfileCreateWithoutSurveyResponsesInput, UserProfileUncheckedCreateWithoutSurveyResponsesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutSurveyResponsesInput
    upsert?: UserProfileUpsertWithoutSurveyResponsesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutSurveyResponsesInput, UserProfileUpdateWithoutSurveyResponsesInput>, UserProfileUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type SurveyAnswerUpdateManyWithoutSurveyResponseNestedInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyResponseInput, SurveyAnswerUncheckedCreateWithoutSurveyResponseInput> | SurveyAnswerCreateWithoutSurveyResponseInput[] | SurveyAnswerUncheckedCreateWithoutSurveyResponseInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyResponseInput | SurveyAnswerCreateOrConnectWithoutSurveyResponseInput[]
    upsert?: SurveyAnswerUpsertWithWhereUniqueWithoutSurveyResponseInput | SurveyAnswerUpsertWithWhereUniqueWithoutSurveyResponseInput[]
    createMany?: SurveyAnswerCreateManySurveyResponseInputEnvelope
    set?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    disconnect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    delete?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    update?: SurveyAnswerUpdateWithWhereUniqueWithoutSurveyResponseInput | SurveyAnswerUpdateWithWhereUniqueWithoutSurveyResponseInput[]
    updateMany?: SurveyAnswerUpdateManyWithWhereWithoutSurveyResponseInput | SurveyAnswerUpdateManyWithWhereWithoutSurveyResponseInput[]
    deleteMany?: SurveyAnswerScalarWhereInput | SurveyAnswerScalarWhereInput[]
  }

  export type SurveyAnswerUncheckedUpdateManyWithoutSurveyResponseNestedInput = {
    create?: XOR<SurveyAnswerCreateWithoutSurveyResponseInput, SurveyAnswerUncheckedCreateWithoutSurveyResponseInput> | SurveyAnswerCreateWithoutSurveyResponseInput[] | SurveyAnswerUncheckedCreateWithoutSurveyResponseInput[]
    connectOrCreate?: SurveyAnswerCreateOrConnectWithoutSurveyResponseInput | SurveyAnswerCreateOrConnectWithoutSurveyResponseInput[]
    upsert?: SurveyAnswerUpsertWithWhereUniqueWithoutSurveyResponseInput | SurveyAnswerUpsertWithWhereUniqueWithoutSurveyResponseInput[]
    createMany?: SurveyAnswerCreateManySurveyResponseInputEnvelope
    set?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    disconnect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    delete?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    connect?: SurveyAnswerWhereUniqueInput | SurveyAnswerWhereUniqueInput[]
    update?: SurveyAnswerUpdateWithWhereUniqueWithoutSurveyResponseInput | SurveyAnswerUpdateWithWhereUniqueWithoutSurveyResponseInput[]
    updateMany?: SurveyAnswerUpdateManyWithWhereWithoutSurveyResponseInput | SurveyAnswerUpdateManyWithWhereWithoutSurveyResponseInput[]
    deleteMany?: SurveyAnswerScalarWhereInput | SurveyAnswerScalarWhereInput[]
  }

  export type SurveyResponseCreateNestedOneWithoutSurveyAnswersInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyAnswersInput, SurveyResponseUncheckedCreateWithoutSurveyAnswersInput>
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyAnswersInput
    connect?: SurveyResponseWhereUniqueInput
  }

  export type SurveyQuestionCreateNestedOneWithoutSurveyAnswersInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyAnswersInput, SurveyQuestionUncheckedCreateWithoutSurveyAnswersInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyAnswersInput
    connect?: SurveyQuestionWhereUniqueInput
  }

  export type SurveyResponseUpdateOneRequiredWithoutSurveyAnswersNestedInput = {
    create?: XOR<SurveyResponseCreateWithoutSurveyAnswersInput, SurveyResponseUncheckedCreateWithoutSurveyAnswersInput>
    connectOrCreate?: SurveyResponseCreateOrConnectWithoutSurveyAnswersInput
    upsert?: SurveyResponseUpsertWithoutSurveyAnswersInput
    connect?: SurveyResponseWhereUniqueInput
    update?: XOR<XOR<SurveyResponseUpdateToOneWithWhereWithoutSurveyAnswersInput, SurveyResponseUpdateWithoutSurveyAnswersInput>, SurveyResponseUncheckedUpdateWithoutSurveyAnswersInput>
  }

  export type SurveyQuestionUpdateOneRequiredWithoutSurveyAnswersNestedInput = {
    create?: XOR<SurveyQuestionCreateWithoutSurveyAnswersInput, SurveyQuestionUncheckedCreateWithoutSurveyAnswersInput>
    connectOrCreate?: SurveyQuestionCreateOrConnectWithoutSurveyAnswersInput
    upsert?: SurveyQuestionUpsertWithoutSurveyAnswersInput
    connect?: SurveyQuestionWhereUniqueInput
    update?: XOR<XOR<SurveyQuestionUpdateToOneWithWhereWithoutSurveyAnswersInput, SurveyQuestionUpdateWithoutSurveyAnswersInput>, SurveyQuestionUncheckedUpdateWithoutSurveyAnswersInput>
  }

  export type AccountCreateNestedOneWithoutAnalyticsReportsInput = {
    create?: XOR<AccountCreateWithoutAnalyticsReportsInput, AccountUncheckedCreateWithoutAnalyticsReportsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAnalyticsReportsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutAnalyticsReportsNestedInput = {
    create?: XOR<AccountCreateWithoutAnalyticsReportsInput, AccountUncheckedCreateWithoutAnalyticsReportsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAnalyticsReportsInput
    upsert?: AccountUpsertWithoutAnalyticsReportsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAnalyticsReportsInput, AccountUpdateWithoutAnalyticsReportsInput>, AccountUncheckedUpdateWithoutAnalyticsReportsInput>
  }

  export type AccountCreateNestedOneWithoutPredictionModelsInput = {
    create?: XOR<AccountCreateWithoutPredictionModelsInput, AccountUncheckedCreateWithoutPredictionModelsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPredictionModelsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutPredictionModelsNestedInput = {
    create?: XOR<AccountCreateWithoutPredictionModelsInput, AccountUncheckedCreateWithoutPredictionModelsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPredictionModelsInput
    upsert?: AccountUpsertWithoutPredictionModelsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPredictionModelsInput, AccountUpdateWithoutPredictionModelsInput>, AccountUncheckedUpdateWithoutPredictionModelsInput>
  }

  export type AccountCreateNestedOneWithoutSystemLogsInput = {
    create?: XOR<AccountCreateWithoutSystemLogsInput, AccountUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSystemLogsInput
    connect?: AccountWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutSystemLogsNestedInput = {
    create?: XOR<AccountCreateWithoutSystemLogsInput, AccountUncheckedCreateWithoutSystemLogsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSystemLogsInput
    upsert?: AccountUpsertWithoutSystemLogsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSystemLogsInput, AccountUpdateWithoutSystemLogsInput>, AccountUncheckedUpdateWithoutSystemLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserProfileCreateWithoutAccountInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutAccountInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutAccountInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutAccountInput, UserProfileUncheckedCreateWithoutAccountInput>
  }

  export type HealthWorkerCreateWithoutAccountInput = {
    id?: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutHealthWorkerInput
  }

  export type HealthWorkerUncheckedCreateWithoutAccountInput = {
    id?: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutHealthWorkerInput
  }

  export type HealthWorkerCreateOrConnectWithoutAccountInput = {
    where: HealthWorkerWhereUniqueInput
    create: XOR<HealthWorkerCreateWithoutAccountInput, HealthWorkerUncheckedCreateWithoutAccountInput>
  }

  export type HealthWorkerCreateManyAccountInputEnvelope = {
    data: HealthWorkerCreateManyAccountInput | HealthWorkerCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCreatorInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventCreateManyCreatorInputEnvelope = {
    data: EventCreateManyCreatorInput | EventCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SurveyCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdAt?: Date | string
    surveyQuestions?: SurveyQuestionCreateNestedManyWithoutSurveyInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdAt?: Date | string
    surveyQuestions?: SurveyQuestionUncheckedCreateNestedManyWithoutSurveyInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutCreatorInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutCreatorInput, SurveyUncheckedCreateWithoutCreatorInput>
  }

  export type SurveyCreateManyCreatorInputEnvelope = {
    data: SurveyCreateManyCreatorInput | SurveyCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type InquiryResponseCreateWithoutResponderInput = {
    id?: string
    message: string
    inquiry: InquiryCreateNestedOneWithoutInquiryResponsesInput
  }

  export type InquiryResponseUncheckedCreateWithoutResponderInput = {
    id?: string
    inquiryId: string
    message: string
  }

  export type InquiryResponseCreateOrConnectWithoutResponderInput = {
    where: InquiryResponseWhereUniqueInput
    create: XOR<InquiryResponseCreateWithoutResponderInput, InquiryResponseUncheckedCreateWithoutResponderInput>
  }

  export type InquiryResponseCreateManyResponderInputEnvelope = {
    data: InquiryResponseCreateManyResponderInput | InquiryResponseCreateManyResponderInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsReportCreateWithoutGeneratorInput = {
    id?: string
    reportName: string
    reportType: string
    dataFilters: JsonNullValueInput | InputJsonValue
    reportData: JsonNullValueInput | InputJsonValue
    reportPeriodStart: Date | string
    reportPeriodEnd: Date | string
  }

  export type AnalyticsReportUncheckedCreateWithoutGeneratorInput = {
    id?: string
    reportName: string
    reportType: string
    dataFilters: JsonNullValueInput | InputJsonValue
    reportData: JsonNullValueInput | InputJsonValue
    reportPeriodStart: Date | string
    reportPeriodEnd: Date | string
  }

  export type AnalyticsReportCreateOrConnectWithoutGeneratorInput = {
    where: AnalyticsReportWhereUniqueInput
    create: XOR<AnalyticsReportCreateWithoutGeneratorInput, AnalyticsReportUncheckedCreateWithoutGeneratorInput>
  }

  export type AnalyticsReportCreateManyGeneratorInputEnvelope = {
    data: AnalyticsReportCreateManyGeneratorInput | AnalyticsReportCreateManyGeneratorInput[]
    skipDuplicates?: boolean
  }

  export type PredictionModelCreateWithoutCreatorInput = {
    id?: string
    modelName: string
    modelType: string
    modelParameters: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    lastTrained?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PredictionModelUncheckedCreateWithoutCreatorInput = {
    id?: string
    modelName: string
    modelType: string
    modelParameters: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    lastTrained?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PredictionModelCreateOrConnectWithoutCreatorInput = {
    where: PredictionModelWhereUniqueInput
    create: XOR<PredictionModelCreateWithoutCreatorInput, PredictionModelUncheckedCreateWithoutCreatorInput>
  }

  export type PredictionModelCreateManyCreatorInputEnvelope = {
    data: PredictionModelCreateManyCreatorInput | PredictionModelCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type SystemLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SystemLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SystemLogCreateOrConnectWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type SystemLogCreateManyUserInputEnvelope = {
    data: SystemLogCreateManyUserInput | SystemLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MedicalProgramCreateWithoutCreatorInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    programParticipations?: ProgramParticipationCreateNestedManyWithoutMedicalProgramInput
  }

  export type MedicalProgramUncheckedCreateWithoutCreatorInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutMedicalProgramInput
  }

  export type MedicalProgramCreateOrConnectWithoutCreatorInput = {
    where: MedicalProgramWhereUniqueInput
    create: XOR<MedicalProgramCreateWithoutCreatorInput, MedicalProgramUncheckedCreateWithoutCreatorInput>
  }

  export type MedicalProgramCreateManyCreatorInputEnvelope = {
    data: MedicalProgramCreateManyCreatorInput | MedicalProgramCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutAccountInput = {
    update: XOR<UserProfileUpdateWithoutAccountInput, UserProfileUncheckedUpdateWithoutAccountInput>
    create: XOR<UserProfileCreateWithoutAccountInput, UserProfileUncheckedCreateWithoutAccountInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutAccountInput, UserProfileUncheckedUpdateWithoutAccountInput>
  }

  export type UserProfileUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type HealthWorkerUpsertWithWhereUniqueWithoutAccountInput = {
    where: HealthWorkerWhereUniqueInput
    update: XOR<HealthWorkerUpdateWithoutAccountInput, HealthWorkerUncheckedUpdateWithoutAccountInput>
    create: XOR<HealthWorkerCreateWithoutAccountInput, HealthWorkerUncheckedCreateWithoutAccountInput>
  }

  export type HealthWorkerUpdateWithWhereUniqueWithoutAccountInput = {
    where: HealthWorkerWhereUniqueInput
    data: XOR<HealthWorkerUpdateWithoutAccountInput, HealthWorkerUncheckedUpdateWithoutAccountInput>
  }

  export type HealthWorkerUpdateManyWithWhereWithoutAccountInput = {
    where: HealthWorkerScalarWhereInput
    data: XOR<HealthWorkerUpdateManyMutationInput, HealthWorkerUncheckedUpdateManyWithoutAccountInput>
  }

  export type HealthWorkerScalarWhereInput = {
    AND?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
    OR?: HealthWorkerScalarWhereInput[]
    NOT?: HealthWorkerScalarWhereInput | HealthWorkerScalarWhereInput[]
    id?: StringFilter<"HealthWorker"> | string
    accountId?: StringFilter<"HealthWorker"> | string
    name?: StringFilter<"HealthWorker"> | string
    role?: StringFilter<"HealthWorker"> | string
    contactNumber?: StringFilter<"HealthWorker"> | string
    signature?: StringNullableFilter<"HealthWorker"> | string | null
    isActive?: BoolFilter<"HealthWorker"> | boolean
  }

  export type EventUpsertWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatorInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCreatorInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    eventDate?: DateTimeFilter<"Event"> | Date | string
    startTime?: StringFilter<"Event"> | string
    endTime?: StringFilter<"Event"> | string
    venue?: StringFilter<"Event"> | string
    targetAudience?: StringNullableFilter<"Event"> | string | null
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    status?: StringFilter<"Event"> | string
    bannerImageUrl?: StringNullableFilter<"Event"> | string | null
    createdBy?: StringFilter<"Event"> | string
    createdAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type SurveyUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SurveyWhereUniqueInput
    update: XOR<SurveyUpdateWithoutCreatorInput, SurveyUncheckedUpdateWithoutCreatorInput>
    create: XOR<SurveyCreateWithoutCreatorInput, SurveyUncheckedCreateWithoutCreatorInput>
  }

  export type SurveyUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SurveyWhereUniqueInput
    data: XOR<SurveyUpdateWithoutCreatorInput, SurveyUncheckedUpdateWithoutCreatorInput>
  }

  export type SurveyUpdateManyWithWhereWithoutCreatorInput = {
    where: SurveyScalarWhereInput
    data: XOR<SurveyUpdateManyMutationInput, SurveyUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SurveyScalarWhereInput = {
    AND?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
    OR?: SurveyScalarWhereInput[]
    NOT?: SurveyScalarWhereInput | SurveyScalarWhereInput[]
    id?: StringFilter<"Survey"> | string
    title?: StringFilter<"Survey"> | string
    description?: StringFilter<"Survey"> | string
    surveyType?: StringFilter<"Survey"> | string
    isActive?: BoolFilter<"Survey"> | boolean
    startDate?: DateTimeFilter<"Survey"> | Date | string
    endDate?: DateTimeFilter<"Survey"> | Date | string
    qrCode?: StringNullableFilter<"Survey"> | string | null
    createdBy?: StringFilter<"Survey"> | string
    createdAt?: DateTimeFilter<"Survey"> | Date | string
  }

  export type InquiryResponseUpsertWithWhereUniqueWithoutResponderInput = {
    where: InquiryResponseWhereUniqueInput
    update: XOR<InquiryResponseUpdateWithoutResponderInput, InquiryResponseUncheckedUpdateWithoutResponderInput>
    create: XOR<InquiryResponseCreateWithoutResponderInput, InquiryResponseUncheckedCreateWithoutResponderInput>
  }

  export type InquiryResponseUpdateWithWhereUniqueWithoutResponderInput = {
    where: InquiryResponseWhereUniqueInput
    data: XOR<InquiryResponseUpdateWithoutResponderInput, InquiryResponseUncheckedUpdateWithoutResponderInput>
  }

  export type InquiryResponseUpdateManyWithWhereWithoutResponderInput = {
    where: InquiryResponseScalarWhereInput
    data: XOR<InquiryResponseUpdateManyMutationInput, InquiryResponseUncheckedUpdateManyWithoutResponderInput>
  }

  export type InquiryResponseScalarWhereInput = {
    AND?: InquiryResponseScalarWhereInput | InquiryResponseScalarWhereInput[]
    OR?: InquiryResponseScalarWhereInput[]
    NOT?: InquiryResponseScalarWhereInput | InquiryResponseScalarWhereInput[]
    id?: StringFilter<"InquiryResponse"> | string
    inquiryId?: StringFilter<"InquiryResponse"> | string
    message?: StringFilter<"InquiryResponse"> | string
    respondedBy?: StringFilter<"InquiryResponse"> | string
  }

  export type AnalyticsReportUpsertWithWhereUniqueWithoutGeneratorInput = {
    where: AnalyticsReportWhereUniqueInput
    update: XOR<AnalyticsReportUpdateWithoutGeneratorInput, AnalyticsReportUncheckedUpdateWithoutGeneratorInput>
    create: XOR<AnalyticsReportCreateWithoutGeneratorInput, AnalyticsReportUncheckedCreateWithoutGeneratorInput>
  }

  export type AnalyticsReportUpdateWithWhereUniqueWithoutGeneratorInput = {
    where: AnalyticsReportWhereUniqueInput
    data: XOR<AnalyticsReportUpdateWithoutGeneratorInput, AnalyticsReportUncheckedUpdateWithoutGeneratorInput>
  }

  export type AnalyticsReportUpdateManyWithWhereWithoutGeneratorInput = {
    where: AnalyticsReportScalarWhereInput
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyWithoutGeneratorInput>
  }

  export type AnalyticsReportScalarWhereInput = {
    AND?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
    OR?: AnalyticsReportScalarWhereInput[]
    NOT?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
    id?: StringFilter<"AnalyticsReport"> | string
    reportName?: StringFilter<"AnalyticsReport"> | string
    reportType?: StringFilter<"AnalyticsReport"> | string
    dataFilters?: JsonFilter<"AnalyticsReport">
    reportData?: JsonFilter<"AnalyticsReport">
    reportPeriodStart?: DateTimeFilter<"AnalyticsReport"> | Date | string
    reportPeriodEnd?: DateTimeFilter<"AnalyticsReport"> | Date | string
    generatedBy?: StringFilter<"AnalyticsReport"> | string
  }

  export type PredictionModelUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PredictionModelWhereUniqueInput
    update: XOR<PredictionModelUpdateWithoutCreatorInput, PredictionModelUncheckedUpdateWithoutCreatorInput>
    create: XOR<PredictionModelCreateWithoutCreatorInput, PredictionModelUncheckedCreateWithoutCreatorInput>
  }

  export type PredictionModelUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PredictionModelWhereUniqueInput
    data: XOR<PredictionModelUpdateWithoutCreatorInput, PredictionModelUncheckedUpdateWithoutCreatorInput>
  }

  export type PredictionModelUpdateManyWithWhereWithoutCreatorInput = {
    where: PredictionModelScalarWhereInput
    data: XOR<PredictionModelUpdateManyMutationInput, PredictionModelUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PredictionModelScalarWhereInput = {
    AND?: PredictionModelScalarWhereInput | PredictionModelScalarWhereInput[]
    OR?: PredictionModelScalarWhereInput[]
    NOT?: PredictionModelScalarWhereInput | PredictionModelScalarWhereInput[]
    id?: StringFilter<"PredictionModel"> | string
    modelName?: StringFilter<"PredictionModel"> | string
    modelType?: StringFilter<"PredictionModel"> | string
    modelParameters?: JsonFilter<"PredictionModel">
    predictionResults?: JsonNullableFilter<"PredictionModel">
    accuracy?: FloatNullableFilter<"PredictionModel"> | number | null
    lastTrained?: DateTimeNullableFilter<"PredictionModel"> | Date | string | null
    isActive?: BoolFilter<"PredictionModel"> | boolean
    createdBy?: StringFilter<"PredictionModel"> | string
    createdAt?: DateTimeFilter<"PredictionModel"> | Date | string
  }

  export type SystemLogUpsertWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    update: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
    create: XOR<SystemLogCreateWithoutUserInput, SystemLogUncheckedCreateWithoutUserInput>
  }

  export type SystemLogUpdateWithWhereUniqueWithoutUserInput = {
    where: SystemLogWhereUniqueInput
    data: XOR<SystemLogUpdateWithoutUserInput, SystemLogUncheckedUpdateWithoutUserInput>
  }

  export type SystemLogUpdateManyWithWhereWithoutUserInput = {
    where: SystemLogScalarWhereInput
    data: XOR<SystemLogUpdateManyMutationInput, SystemLogUncheckedUpdateManyWithoutUserInput>
  }

  export type SystemLogScalarWhereInput = {
    AND?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    OR?: SystemLogScalarWhereInput[]
    NOT?: SystemLogScalarWhereInput | SystemLogScalarWhereInput[]
    id?: StringFilter<"SystemLog"> | string
    userId?: StringFilter<"SystemLog"> | string
    action?: StringFilter<"SystemLog"> | string
    entityType?: StringFilter<"SystemLog"> | string
    entityId?: StringFilter<"SystemLog"> | string
    oldData?: JsonNullableFilter<"SystemLog">
    newData?: JsonNullableFilter<"SystemLog">
    ipAddress?: StringNullableFilter<"SystemLog"> | string | null
    userAgent?: StringNullableFilter<"SystemLog"> | string | null
  }

  export type MedicalProgramUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MedicalProgramWhereUniqueInput
    update: XOR<MedicalProgramUpdateWithoutCreatorInput, MedicalProgramUncheckedUpdateWithoutCreatorInput>
    create: XOR<MedicalProgramCreateWithoutCreatorInput, MedicalProgramUncheckedCreateWithoutCreatorInput>
  }

  export type MedicalProgramUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MedicalProgramWhereUniqueInput
    data: XOR<MedicalProgramUpdateWithoutCreatorInput, MedicalProgramUncheckedUpdateWithoutCreatorInput>
  }

  export type MedicalProgramUpdateManyWithWhereWithoutCreatorInput = {
    where: MedicalProgramScalarWhereInput
    data: XOR<MedicalProgramUpdateManyMutationInput, MedicalProgramUncheckedUpdateManyWithoutCreatorInput>
  }

  export type MedicalProgramScalarWhereInput = {
    AND?: MedicalProgramScalarWhereInput | MedicalProgramScalarWhereInput[]
    OR?: MedicalProgramScalarWhereInput[]
    NOT?: MedicalProgramScalarWhereInput | MedicalProgramScalarWhereInput[]
    id?: StringFilter<"MedicalProgram"> | string
    programName?: StringFilter<"MedicalProgram"> | string
    description?: StringFilter<"MedicalProgram"> | string
    programType?: StringFilter<"MedicalProgram"> | string
    startDate?: DateTimeFilter<"MedicalProgram"> | Date | string
    endDate?: DateTimeFilter<"MedicalProgram"> | Date | string
    venue?: StringFilter<"MedicalProgram"> | string
    targetDemographic?: StringNullableFilter<"MedicalProgram"> | string | null
    targetParticipants?: IntNullableFilter<"MedicalProgram"> | number | null
    status?: StringFilter<"MedicalProgram"> | string
    bannerImageUrl?: StringNullableFilter<"MedicalProgram"> | string | null
    createdBy?: StringFilter<"MedicalProgram"> | string
    createdAt?: DateTimeFilter<"MedicalProgram"> | Date | string
  }

  export type AccountCreateWithoutUserProfileInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutUserProfileInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutUserProfileInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserProfileInput, AccountUncheckedCreateWithoutUserProfileInput>
  }

  export type FamilyRecordCreateWithoutHeadOfFamilyInput = {
    id?: string
    familyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyMemberCreateNestedManyWithoutFamilyRecordInput
    familyHealthHistory?: FamilyHealthHistoryCreateNestedOneWithoutFamilyRecordInput
  }

  export type FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput = {
    id?: string
    familyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyRecordInput
    familyHealthHistory?: FamilyHealthHistoryUncheckedCreateNestedOneWithoutFamilyRecordInput
  }

  export type FamilyRecordCreateOrConnectWithoutHeadOfFamilyInput = {
    where: FamilyRecordWhereUniqueInput
    create: XOR<FamilyRecordCreateWithoutHeadOfFamilyInput, FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput>
  }

  export type FamilyRecordCreateManyHeadOfFamilyInputEnvelope = {
    data: FamilyRecordCreateManyHeadOfFamilyInput | FamilyRecordCreateManyHeadOfFamilyInput[]
    skipDuplicates?: boolean
  }

  export type FamilyMemberCreateWithoutUserProfileInput = {
    id?: string
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
    familyRecord: FamilyRecordCreateNestedOneWithoutMembersInput
  }

  export type FamilyMemberUncheckedCreateWithoutUserProfileInput = {
    id?: string
    familyRecordId: string
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
  }

  export type FamilyMemberCreateOrConnectWithoutUserProfileInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutUserProfileInput, FamilyMemberUncheckedCreateWithoutUserProfileInput>
  }

  export type FamilyMemberCreateManyUserProfileInputEnvelope = {
    data: FamilyMemberCreateManyUserProfileInput | FamilyMemberCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type MaternalHealthCreateWithoutUserProfileInput = {
    id?: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    prenatalVisits?: PrenatalVisitCreateNestedManyWithoutMaternalHealthInput
    birthInformation?: BirthInformationCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthUncheckedCreateWithoutUserProfileInput = {
    id?: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    prenatalVisits?: PrenatalVisitUncheckedCreateNestedManyWithoutMaternalHealthInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthCreateOrConnectWithoutUserProfileInput = {
    where: MaternalHealthWhereUniqueInput
    create: XOR<MaternalHealthCreateWithoutUserProfileInput, MaternalHealthUncheckedCreateWithoutUserProfileInput>
  }

  export type MaternalHealthCreateManyUserProfileInputEnvelope = {
    data: MaternalHealthCreateManyUserProfileInput | MaternalHealthCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type BirthInformationCreateWithoutUserProfileInput = {
    id?: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
    maternalHealth: MaternalHealthCreateNestedOneWithoutBirthInformationInput
  }

  export type BirthInformationUncheckedCreateWithoutUserProfileInput = {
    id?: string
    maternalHealthId: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
  }

  export type BirthInformationCreateOrConnectWithoutUserProfileInput = {
    where: BirthInformationWhereUniqueInput
    create: XOR<BirthInformationCreateWithoutUserProfileInput, BirthInformationUncheckedCreateWithoutUserProfileInput>
  }

  export type BirthInformationCreateManyUserProfileInputEnvelope = {
    data: BirthInformationCreateManyUserProfileInput | BirthInformationCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type ImmunizationEventCreateWithoutUserProfileInput = {
    id?: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
    vaccinesGiven?: VaccineGivenCreateNestedManyWithoutImmunizationEventInput
  }

  export type ImmunizationEventUncheckedCreateWithoutUserProfileInput = {
    id?: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
    vaccinesGiven?: VaccineGivenUncheckedCreateNestedManyWithoutImmunizationEventInput
  }

  export type ImmunizationEventCreateOrConnectWithoutUserProfileInput = {
    where: ImmunizationEventWhereUniqueInput
    create: XOR<ImmunizationEventCreateWithoutUserProfileInput, ImmunizationEventUncheckedCreateWithoutUserProfileInput>
  }

  export type ImmunizationEventCreateManyUserProfileInputEnvelope = {
    data: ImmunizationEventCreateManyUserProfileInput | ImmunizationEventCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type VitalSignsCreateWithoutUserProfileInput = {
    id?: string
    recordDate: Date | string
    bloodPressure?: string | null
    heartRate?: number | null
    respiratoryRate?: number | null
    temperatureCelsius?: number | null
    pulseRate?: number | null
    recordedBy: string
  }

  export type VitalSignsUncheckedCreateWithoutUserProfileInput = {
    id?: string
    recordDate: Date | string
    bloodPressure?: string | null
    heartRate?: number | null
    respiratoryRate?: number | null
    temperatureCelsius?: number | null
    pulseRate?: number | null
    recordedBy: string
  }

  export type VitalSignsCreateOrConnectWithoutUserProfileInput = {
    where: VitalSignsWhereUniqueInput
    create: XOR<VitalSignsCreateWithoutUserProfileInput, VitalSignsUncheckedCreateWithoutUserProfileInput>
  }

  export type VitalSignsCreateManyUserProfileInputEnvelope = {
    data: VitalSignsCreateManyUserProfileInput | VitalSignsCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type AnthropometricMeasurementCreateWithoutUserProfileInput = {
    id?: string
    measurementDate: Date | string
    weightKg?: number | null
    heightCm?: number | null
    headCircumferenceCm?: number | null
    waistCircumferenceCm?: number | null
    bmi?: number | null
    recordedBy: string
  }

  export type AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput = {
    id?: string
    measurementDate: Date | string
    weightKg?: number | null
    heightCm?: number | null
    headCircumferenceCm?: number | null
    waistCircumferenceCm?: number | null
    bmi?: number | null
    recordedBy: string
  }

  export type AnthropometricMeasurementCreateOrConnectWithoutUserProfileInput = {
    where: AnthropometricMeasurementWhereUniqueInput
    create: XOR<AnthropometricMeasurementCreateWithoutUserProfileInput, AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput>
  }

  export type AnthropometricMeasurementCreateManyUserProfileInputEnvelope = {
    data: AnthropometricMeasurementCreateManyUserProfileInput | AnthropometricMeasurementCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type GrowthTrackingCreateWithoutUserProfileInput = {
    id?: string
    trackingDate: Date | string
    weightForAge?: string | null
    heightForAge?: string | null
    weightForHeight?: string | null
    recordedBy: string
  }

  export type GrowthTrackingUncheckedCreateWithoutUserProfileInput = {
    id?: string
    trackingDate: Date | string
    weightForAge?: string | null
    heightForAge?: string | null
    weightForHeight?: string | null
    recordedBy: string
  }

  export type GrowthTrackingCreateOrConnectWithoutUserProfileInput = {
    where: GrowthTrackingWhereUniqueInput
    create: XOR<GrowthTrackingCreateWithoutUserProfileInput, GrowthTrackingUncheckedCreateWithoutUserProfileInput>
  }

  export type GrowthTrackingCreateManyUserProfileInputEnvelope = {
    data: GrowthTrackingCreateManyUserProfileInput | GrowthTrackingCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type NCDRiskAssessmentCreateWithoutUserProfileInput = {
    id?: string
    assessmentDate: Date | string
    smokingStatus?: string | null
    alcoholIntake?: string | null
    physicalActivity?: string | null
    fruitVegetableIntake?: string | null
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications: JsonNullValueInput | InputJsonValue
    healthEducationReceived: JsonNullValueInput | InputJsonValue
    recordedBy: string
  }

  export type NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput = {
    id?: string
    assessmentDate: Date | string
    smokingStatus?: string | null
    alcoholIntake?: string | null
    physicalActivity?: string | null
    fruitVegetableIntake?: string | null
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications: JsonNullValueInput | InputJsonValue
    healthEducationReceived: JsonNullValueInput | InputJsonValue
    recordedBy: string
  }

  export type NCDRiskAssessmentCreateOrConnectWithoutUserProfileInput = {
    where: NCDRiskAssessmentWhereUniqueInput
    create: XOR<NCDRiskAssessmentCreateWithoutUserProfileInput, NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput>
  }

  export type NCDRiskAssessmentCreateManyUserProfileInputEnvelope = {
    data: NCDRiskAssessmentCreateManyUserProfileInput | NCDRiskAssessmentCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type VisitRecordCreateWithoutUserProfileInput = {
    id?: string
    visitDate: Date | string
    visitType: string
    visitFrequency?: string | null
    referred?: boolean
    facilityName?: string | null
    referralReason?: string | null
    recordedBy: string
  }

  export type VisitRecordUncheckedCreateWithoutUserProfileInput = {
    id?: string
    visitDate: Date | string
    visitType: string
    visitFrequency?: string | null
    referred?: boolean
    facilityName?: string | null
    referralReason?: string | null
    recordedBy: string
  }

  export type VisitRecordCreateOrConnectWithoutUserProfileInput = {
    where: VisitRecordWhereUniqueInput
    create: XOR<VisitRecordCreateWithoutUserProfileInput, VisitRecordUncheckedCreateWithoutUserProfileInput>
  }

  export type VisitRecordCreateManyUserProfileInputEnvelope = {
    data: VisitRecordCreateManyUserProfileInput | VisitRecordCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type HealthEducationCreateWithoutUserProfileInput = {
    id?: string
    topicsCovered: JsonNullValueInput | InputJsonValue
    dateProvided: Date | string
    providedBy: string
  }

  export type HealthEducationUncheckedCreateWithoutUserProfileInput = {
    id?: string
    topicsCovered: JsonNullValueInput | InputJsonValue
    dateProvided: Date | string
    providedBy: string
  }

  export type HealthEducationCreateOrConnectWithoutUserProfileInput = {
    where: HealthEducationWhereUniqueInput
    create: XOR<HealthEducationCreateWithoutUserProfileInput, HealthEducationUncheckedCreateWithoutUserProfileInput>
  }

  export type HealthEducationCreateManyUserProfileInputEnvelope = {
    data: HealthEducationCreateManyUserProfileInput | HealthEducationCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type NutritionalCounselingCreateWithoutUserProfileInput = {
    id?: string
    recommendations: string
    dateProvided: Date | string
    providedBy: string
  }

  export type NutritionalCounselingUncheckedCreateWithoutUserProfileInput = {
    id?: string
    recommendations: string
    dateProvided: Date | string
    providedBy: string
  }

  export type NutritionalCounselingCreateOrConnectWithoutUserProfileInput = {
    where: NutritionalCounselingWhereUniqueInput
    create: XOR<NutritionalCounselingCreateWithoutUserProfileInput, NutritionalCounselingUncheckedCreateWithoutUserProfileInput>
  }

  export type NutritionalCounselingCreateManyUserProfileInputEnvelope = {
    data: NutritionalCounselingCreateManyUserProfileInput | NutritionalCounselingCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutUserProfileInput = {
    id?: string
    facilityName: string
    reason: string
    dateReferred: Date | string
    status: string
    referredBy: string
  }

  export type ReferralUncheckedCreateWithoutUserProfileInput = {
    id?: string
    facilityName: string
    reason: string
    dateReferred: Date | string
    status: string
    referredBy: string
  }

  export type ReferralCreateOrConnectWithoutUserProfileInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutUserProfileInput, ReferralUncheckedCreateWithoutUserProfileInput>
  }

  export type ReferralCreateManyUserProfileInputEnvelope = {
    data: ReferralCreateManyUserProfileInput | ReferralCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutUserProfileInput = {
    id?: string
    nextVisitDate: Date | string
    visitType: string
    appointmentStatus: string
    scheduledBy: string
    createdAt?: Date | string
  }

  export type AppointmentUncheckedCreateWithoutUserProfileInput = {
    id?: string
    nextVisitDate: Date | string
    visitType: string
    appointmentStatus: string
    scheduledBy: string
    createdAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutUserProfileInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutUserProfileInput, AppointmentUncheckedCreateWithoutUserProfileInput>
  }

  export type AppointmentCreateManyUserProfileInputEnvelope = {
    data: AppointmentCreateManyUserProfileInput | AppointmentCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type ImmunizationReminderCreateWithoutUserProfileInput = {
    id?: string
    vaccineName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type ImmunizationReminderUncheckedCreateWithoutUserProfileInput = {
    id?: string
    vaccineName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type ImmunizationReminderCreateOrConnectWithoutUserProfileInput = {
    where: ImmunizationReminderWhereUniqueInput
    create: XOR<ImmunizationReminderCreateWithoutUserProfileInput, ImmunizationReminderUncheckedCreateWithoutUserProfileInput>
  }

  export type ImmunizationReminderCreateManyUserProfileInputEnvelope = {
    data: ImmunizationReminderCreateManyUserProfileInput | ImmunizationReminderCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type TestReminderCreateWithoutUserProfileInput = {
    id?: string
    testName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type TestReminderUncheckedCreateWithoutUserProfileInput = {
    id?: string
    testName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type TestReminderCreateOrConnectWithoutUserProfileInput = {
    where: TestReminderWhereUniqueInput
    create: XOR<TestReminderCreateWithoutUserProfileInput, TestReminderUncheckedCreateWithoutUserProfileInput>
  }

  export type TestReminderCreateManyUserProfileInputEnvelope = {
    data: TestReminderCreateManyUserProfileInput | TestReminderCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type VirtualCheckupCreateWithoutUserProfileInput = {
    id?: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
    healthWorker: HealthWorkerCreateNestedOneWithoutVirtualCheckupsInput
    virtualCheckupNotes?: VirtualCheckupNoteCreateNestedManyWithoutVirtualCheckupInput
  }

  export type VirtualCheckupUncheckedCreateWithoutUserProfileInput = {
    id?: string
    healthWorkerId: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
    virtualCheckupNotes?: VirtualCheckupNoteUncheckedCreateNestedManyWithoutVirtualCheckupInput
  }

  export type VirtualCheckupCreateOrConnectWithoutUserProfileInput = {
    where: VirtualCheckupWhereUniqueInput
    create: XOR<VirtualCheckupCreateWithoutUserProfileInput, VirtualCheckupUncheckedCreateWithoutUserProfileInput>
  }

  export type VirtualCheckupCreateManyUserProfileInputEnvelope = {
    data: VirtualCheckupCreateManyUserProfileInput | VirtualCheckupCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type EventRegistrationCreateWithoutUserProfileInput = {
    id?: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
    event: EventCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutUserProfileInput = {
    id?: string
    eventId: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
  }

  export type EventRegistrationCreateOrConnectWithoutUserProfileInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutUserProfileInput, EventRegistrationUncheckedCreateWithoutUserProfileInput>
  }

  export type EventRegistrationCreateManyUserProfileInputEnvelope = {
    data: EventRegistrationCreateManyUserProfileInput | EventRegistrationCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProgramParticipationCreateWithoutUserProfileInput = {
    id?: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
    medicalProgram: MedicalProgramCreateNestedOneWithoutProgramParticipationsInput
  }

  export type ProgramParticipationUncheckedCreateWithoutUserProfileInput = {
    id?: string
    medicalProgramId: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
  }

  export type ProgramParticipationCreateOrConnectWithoutUserProfileInput = {
    where: ProgramParticipationWhereUniqueInput
    create: XOR<ProgramParticipationCreateWithoutUserProfileInput, ProgramParticipationUncheckedCreateWithoutUserProfileInput>
  }

  export type ProgramParticipationCreateManyUserProfileInputEnvelope = {
    data: ProgramParticipationCreateManyUserProfileInput | ProgramParticipationCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type InquiryCreateWithoutUserProfileInput = {
    id?: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutInquiryInput
  }

  export type InquiryUncheckedCreateWithoutUserProfileInput = {
    id?: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutInquiryInput
  }

  export type InquiryCreateOrConnectWithoutUserProfileInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutUserProfileInput, InquiryUncheckedCreateWithoutUserProfileInput>
  }

  export type InquiryCreateManyUserProfileInputEnvelope = {
    data: InquiryCreateManyUserProfileInput | InquiryCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseCreateWithoutUserProfileInput = {
    id?: string
    ipAddress?: string | null
    submittedAt?: Date | string
    survey: SurveyCreateNestedOneWithoutSurveyResponsesInput
    surveyAnswers?: SurveyAnswerCreateNestedManyWithoutSurveyResponseInput
  }

  export type SurveyResponseUncheckedCreateWithoutUserProfileInput = {
    id?: string
    surveyId: string
    ipAddress?: string | null
    submittedAt?: Date | string
    surveyAnswers?: SurveyAnswerUncheckedCreateNestedManyWithoutSurveyResponseInput
  }

  export type SurveyResponseCreateOrConnectWithoutUserProfileInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutUserProfileInput, SurveyResponseUncheckedCreateWithoutUserProfileInput>
  }

  export type SurveyResponseCreateManyUserProfileInputEnvelope = {
    data: SurveyResponseCreateManyUserProfileInput | SurveyResponseCreateManyUserProfileInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutUserProfileInput = {
    update: XOR<AccountUpdateWithoutUserProfileInput, AccountUncheckedUpdateWithoutUserProfileInput>
    create: XOR<AccountCreateWithoutUserProfileInput, AccountUncheckedCreateWithoutUserProfileInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutUserProfileInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutUserProfileInput, AccountUncheckedUpdateWithoutUserProfileInput>
  }

  export type AccountUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type FamilyRecordUpsertWithWhereUniqueWithoutHeadOfFamilyInput = {
    where: FamilyRecordWhereUniqueInput
    update: XOR<FamilyRecordUpdateWithoutHeadOfFamilyInput, FamilyRecordUncheckedUpdateWithoutHeadOfFamilyInput>
    create: XOR<FamilyRecordCreateWithoutHeadOfFamilyInput, FamilyRecordUncheckedCreateWithoutHeadOfFamilyInput>
  }

  export type FamilyRecordUpdateWithWhereUniqueWithoutHeadOfFamilyInput = {
    where: FamilyRecordWhereUniqueInput
    data: XOR<FamilyRecordUpdateWithoutHeadOfFamilyInput, FamilyRecordUncheckedUpdateWithoutHeadOfFamilyInput>
  }

  export type FamilyRecordUpdateManyWithWhereWithoutHeadOfFamilyInput = {
    where: FamilyRecordScalarWhereInput
    data: XOR<FamilyRecordUpdateManyMutationInput, FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyInput>
  }

  export type FamilyRecordScalarWhereInput = {
    AND?: FamilyRecordScalarWhereInput | FamilyRecordScalarWhereInput[]
    OR?: FamilyRecordScalarWhereInput[]
    NOT?: FamilyRecordScalarWhereInput | FamilyRecordScalarWhereInput[]
    id?: StringFilter<"FamilyRecord"> | string
    familyId?: StringFilter<"FamilyRecord"> | string
    headOfFamilyId?: StringFilter<"FamilyRecord"> | string
    address?: StringFilter<"FamilyRecord"> | string
    contactNumber?: StringFilter<"FamilyRecord"> | string
    smsConsent?: BoolFilter<"FamilyRecord"> | boolean
    createdAt?: DateTimeFilter<"FamilyRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FamilyRecord"> | Date | string
  }

  export type FamilyMemberUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: FamilyMemberWhereUniqueInput
    update: XOR<FamilyMemberUpdateWithoutUserProfileInput, FamilyMemberUncheckedUpdateWithoutUserProfileInput>
    create: XOR<FamilyMemberCreateWithoutUserProfileInput, FamilyMemberUncheckedCreateWithoutUserProfileInput>
  }

  export type FamilyMemberUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: FamilyMemberWhereUniqueInput
    data: XOR<FamilyMemberUpdateWithoutUserProfileInput, FamilyMemberUncheckedUpdateWithoutUserProfileInput>
  }

  export type FamilyMemberUpdateManyWithWhereWithoutUserProfileInput = {
    where: FamilyMemberScalarWhereInput
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type FamilyMemberScalarWhereInput = {
    AND?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    OR?: FamilyMemberScalarWhereInput[]
    NOT?: FamilyMemberScalarWhereInput | FamilyMemberScalarWhereInput[]
    id?: StringFilter<"FamilyMember"> | string
    familyRecordId?: StringFilter<"FamilyMember"> | string
    userProfileId?: StringNullableFilter<"FamilyMember"> | string | null
    memberName?: StringFilter<"FamilyMember"> | string
    relationship?: StringFilter<"FamilyMember"> | string
    gender?: StringFilter<"FamilyMember"> | string
    age?: IntFilter<"FamilyMember"> | number
    occupation?: StringNullableFilter<"FamilyMember"> | string | null
    civilStatus?: StringFilter<"FamilyMember"> | string
  }

  export type MaternalHealthUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: MaternalHealthWhereUniqueInput
    update: XOR<MaternalHealthUpdateWithoutUserProfileInput, MaternalHealthUncheckedUpdateWithoutUserProfileInput>
    create: XOR<MaternalHealthCreateWithoutUserProfileInput, MaternalHealthUncheckedCreateWithoutUserProfileInput>
  }

  export type MaternalHealthUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: MaternalHealthWhereUniqueInput
    data: XOR<MaternalHealthUpdateWithoutUserProfileInput, MaternalHealthUncheckedUpdateWithoutUserProfileInput>
  }

  export type MaternalHealthUpdateManyWithWhereWithoutUserProfileInput = {
    where: MaternalHealthScalarWhereInput
    data: XOR<MaternalHealthUpdateManyMutationInput, MaternalHealthUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type MaternalHealthScalarWhereInput = {
    AND?: MaternalHealthScalarWhereInput | MaternalHealthScalarWhereInput[]
    OR?: MaternalHealthScalarWhereInput[]
    NOT?: MaternalHealthScalarWhereInput | MaternalHealthScalarWhereInput[]
    id?: StringFilter<"MaternalHealth"> | string
    userProfileId?: StringFilter<"MaternalHealth"> | string
    mothersName?: StringFilter<"MaternalHealth"> | string
    mothersAge?: IntFilter<"MaternalHealth"> | number
    mothersBirthday?: DateTimeFilter<"MaternalHealth"> | Date | string
    mothersMaidenName?: StringFilter<"MaternalHealth"> | string
    mothersReligion?: StringNullableFilter<"MaternalHealth"> | string | null
    mothersEducation?: StringNullableFilter<"MaternalHealth"> | string | null
    mothersOccupation?: StringNullableFilter<"MaternalHealth"> | string | null
    numberOfChildren?: IntFilter<"MaternalHealth"> | number
    gravidaPara?: StringFilter<"MaternalHealth"> | string
    menarcheAge?: IntFilter<"MaternalHealth"> | number
    lastMenstrualPeriod?: DateTimeFilter<"MaternalHealth"> | Date | string
    expectedDeliveryDate?: DateTimeFilter<"MaternalHealth"> | Date | string
    tetanusToxoidStatus?: StringNullableFilter<"MaternalHealth"> | string | null
    createdAt?: DateTimeFilter<"MaternalHealth"> | Date | string
  }

  export type BirthInformationUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: BirthInformationWhereUniqueInput
    update: XOR<BirthInformationUpdateWithoutUserProfileInput, BirthInformationUncheckedUpdateWithoutUserProfileInput>
    create: XOR<BirthInformationCreateWithoutUserProfileInput, BirthInformationUncheckedCreateWithoutUserProfileInput>
  }

  export type BirthInformationUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: BirthInformationWhereUniqueInput
    data: XOR<BirthInformationUpdateWithoutUserProfileInput, BirthInformationUncheckedUpdateWithoutUserProfileInput>
  }

  export type BirthInformationUpdateManyWithWhereWithoutUserProfileInput = {
    where: BirthInformationScalarWhereInput
    data: XOR<BirthInformationUpdateManyMutationInput, BirthInformationUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type BirthInformationScalarWhereInput = {
    AND?: BirthInformationScalarWhereInput | BirthInformationScalarWhereInput[]
    OR?: BirthInformationScalarWhereInput[]
    NOT?: BirthInformationScalarWhereInput | BirthInformationScalarWhereInput[]
    id?: StringFilter<"BirthInformation"> | string
    userProfileId?: StringFilter<"BirthInformation"> | string
    maternalHealthId?: StringFilter<"BirthInformation"> | string
    placeOfDelivery?: StringFilter<"BirthInformation"> | string
    timeOfDelivery?: StringFilter<"BirthInformation"> | string
    deliveryType?: StringFilter<"BirthInformation"> | string
    birthWeightKg?: FloatFilter<"BirthInformation"> | number
    birthHeightCm?: FloatFilter<"BirthInformation"> | number
    newbornScreeningDate?: DateTimeNullableFilter<"BirthInformation"> | Date | string | null
    newbornScreeningCompleted?: BoolFilter<"BirthInformation"> | boolean
    feedingType?: StringFilter<"BirthInformation"> | string
    createdAt?: DateTimeFilter<"BirthInformation"> | Date | string
    recordedBy?: StringFilter<"BirthInformation"> | string
  }

  export type ImmunizationEventUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: ImmunizationEventWhereUniqueInput
    update: XOR<ImmunizationEventUpdateWithoutUserProfileInput, ImmunizationEventUncheckedUpdateWithoutUserProfileInput>
    create: XOR<ImmunizationEventCreateWithoutUserProfileInput, ImmunizationEventUncheckedCreateWithoutUserProfileInput>
  }

  export type ImmunizationEventUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: ImmunizationEventWhereUniqueInput
    data: XOR<ImmunizationEventUpdateWithoutUserProfileInput, ImmunizationEventUncheckedUpdateWithoutUserProfileInput>
  }

  export type ImmunizationEventUpdateManyWithWhereWithoutUserProfileInput = {
    where: ImmunizationEventScalarWhereInput
    data: XOR<ImmunizationEventUpdateManyMutationInput, ImmunizationEventUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type ImmunizationEventScalarWhereInput = {
    AND?: ImmunizationEventScalarWhereInput | ImmunizationEventScalarWhereInput[]
    OR?: ImmunizationEventScalarWhereInput[]
    NOT?: ImmunizationEventScalarWhereInput | ImmunizationEventScalarWhereInput[]
    id?: StringFilter<"ImmunizationEvent"> | string
    userProfileId?: StringFilter<"ImmunizationEvent"> | string
    visitDate?: DateTimeFilter<"ImmunizationEvent"> | Date | string
    temperatureCelsius?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    weightKg?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    heightCm?: FloatNullableFilter<"ImmunizationEvent"> | number | null
    adverseReactions?: StringNullableFilter<"ImmunizationEvent"> | string | null
    healthWorkerName?: StringFilter<"ImmunizationEvent"> | string
    healthWorkerSignature?: StringNullableFilter<"ImmunizationEvent"> | string | null
    nextFollowupDate?: DateTimeNullableFilter<"ImmunizationEvent"> | Date | string | null
    recordedBy?: StringFilter<"ImmunizationEvent"> | string
  }

  export type VitalSignsUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: VitalSignsWhereUniqueInput
    update: XOR<VitalSignsUpdateWithoutUserProfileInput, VitalSignsUncheckedUpdateWithoutUserProfileInput>
    create: XOR<VitalSignsCreateWithoutUserProfileInput, VitalSignsUncheckedCreateWithoutUserProfileInput>
  }

  export type VitalSignsUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: VitalSignsWhereUniqueInput
    data: XOR<VitalSignsUpdateWithoutUserProfileInput, VitalSignsUncheckedUpdateWithoutUserProfileInput>
  }

  export type VitalSignsUpdateManyWithWhereWithoutUserProfileInput = {
    where: VitalSignsScalarWhereInput
    data: XOR<VitalSignsUpdateManyMutationInput, VitalSignsUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type VitalSignsScalarWhereInput = {
    AND?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
    OR?: VitalSignsScalarWhereInput[]
    NOT?: VitalSignsScalarWhereInput | VitalSignsScalarWhereInput[]
    id?: StringFilter<"VitalSigns"> | string
    userProfileId?: StringFilter<"VitalSigns"> | string
    recordDate?: DateTimeFilter<"VitalSigns"> | Date | string
    bloodPressure?: StringNullableFilter<"VitalSigns"> | string | null
    heartRate?: IntNullableFilter<"VitalSigns"> | number | null
    respiratoryRate?: IntNullableFilter<"VitalSigns"> | number | null
    temperatureCelsius?: FloatNullableFilter<"VitalSigns"> | number | null
    pulseRate?: IntNullableFilter<"VitalSigns"> | number | null
    recordedBy?: StringFilter<"VitalSigns"> | string
  }

  export type AnthropometricMeasurementUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: AnthropometricMeasurementWhereUniqueInput
    update: XOR<AnthropometricMeasurementUpdateWithoutUserProfileInput, AnthropometricMeasurementUncheckedUpdateWithoutUserProfileInput>
    create: XOR<AnthropometricMeasurementCreateWithoutUserProfileInput, AnthropometricMeasurementUncheckedCreateWithoutUserProfileInput>
  }

  export type AnthropometricMeasurementUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: AnthropometricMeasurementWhereUniqueInput
    data: XOR<AnthropometricMeasurementUpdateWithoutUserProfileInput, AnthropometricMeasurementUncheckedUpdateWithoutUserProfileInput>
  }

  export type AnthropometricMeasurementUpdateManyWithWhereWithoutUserProfileInput = {
    where: AnthropometricMeasurementScalarWhereInput
    data: XOR<AnthropometricMeasurementUpdateManyMutationInput, AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type AnthropometricMeasurementScalarWhereInput = {
    AND?: AnthropometricMeasurementScalarWhereInput | AnthropometricMeasurementScalarWhereInput[]
    OR?: AnthropometricMeasurementScalarWhereInput[]
    NOT?: AnthropometricMeasurementScalarWhereInput | AnthropometricMeasurementScalarWhereInput[]
    id?: StringFilter<"AnthropometricMeasurement"> | string
    userProfileId?: StringFilter<"AnthropometricMeasurement"> | string
    measurementDate?: DateTimeFilter<"AnthropometricMeasurement"> | Date | string
    weightKg?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    heightCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    headCircumferenceCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    waistCircumferenceCm?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    bmi?: FloatNullableFilter<"AnthropometricMeasurement"> | number | null
    recordedBy?: StringFilter<"AnthropometricMeasurement"> | string
  }

  export type GrowthTrackingUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: GrowthTrackingWhereUniqueInput
    update: XOR<GrowthTrackingUpdateWithoutUserProfileInput, GrowthTrackingUncheckedUpdateWithoutUserProfileInput>
    create: XOR<GrowthTrackingCreateWithoutUserProfileInput, GrowthTrackingUncheckedCreateWithoutUserProfileInput>
  }

  export type GrowthTrackingUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: GrowthTrackingWhereUniqueInput
    data: XOR<GrowthTrackingUpdateWithoutUserProfileInput, GrowthTrackingUncheckedUpdateWithoutUserProfileInput>
  }

  export type GrowthTrackingUpdateManyWithWhereWithoutUserProfileInput = {
    where: GrowthTrackingScalarWhereInput
    data: XOR<GrowthTrackingUpdateManyMutationInput, GrowthTrackingUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type GrowthTrackingScalarWhereInput = {
    AND?: GrowthTrackingScalarWhereInput | GrowthTrackingScalarWhereInput[]
    OR?: GrowthTrackingScalarWhereInput[]
    NOT?: GrowthTrackingScalarWhereInput | GrowthTrackingScalarWhereInput[]
    id?: StringFilter<"GrowthTracking"> | string
    userProfileId?: StringFilter<"GrowthTracking"> | string
    trackingDate?: DateTimeFilter<"GrowthTracking"> | Date | string
    weightForAge?: StringNullableFilter<"GrowthTracking"> | string | null
    heightForAge?: StringNullableFilter<"GrowthTracking"> | string | null
    weightForHeight?: StringNullableFilter<"GrowthTracking"> | string | null
    recordedBy?: StringFilter<"GrowthTracking"> | string
  }

  export type NCDRiskAssessmentUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: NCDRiskAssessmentWhereUniqueInput
    update: XOR<NCDRiskAssessmentUpdateWithoutUserProfileInput, NCDRiskAssessmentUncheckedUpdateWithoutUserProfileInput>
    create: XOR<NCDRiskAssessmentCreateWithoutUserProfileInput, NCDRiskAssessmentUncheckedCreateWithoutUserProfileInput>
  }

  export type NCDRiskAssessmentUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: NCDRiskAssessmentWhereUniqueInput
    data: XOR<NCDRiskAssessmentUpdateWithoutUserProfileInput, NCDRiskAssessmentUncheckedUpdateWithoutUserProfileInput>
  }

  export type NCDRiskAssessmentUpdateManyWithWhereWithoutUserProfileInput = {
    where: NCDRiskAssessmentScalarWhereInput
    data: XOR<NCDRiskAssessmentUpdateManyMutationInput, NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type NCDRiskAssessmentScalarWhereInput = {
    AND?: NCDRiskAssessmentScalarWhereInput | NCDRiskAssessmentScalarWhereInput[]
    OR?: NCDRiskAssessmentScalarWhereInput[]
    NOT?: NCDRiskAssessmentScalarWhereInput | NCDRiskAssessmentScalarWhereInput[]
    id?: StringFilter<"NCDRiskAssessment"> | string
    userProfileId?: StringFilter<"NCDRiskAssessment"> | string
    assessmentDate?: DateTimeFilter<"NCDRiskAssessment"> | Date | string
    smokingStatus?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    alcoholIntake?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    physicalActivity?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    fruitVegetableIntake?: StringNullableFilter<"NCDRiskAssessment"> | string | null
    familyHistoryDiabetes?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHypertension?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryHeartDisease?: BoolFilter<"NCDRiskAssessment"> | boolean
    familyHistoryStroke?: BoolFilter<"NCDRiskAssessment"> | boolean
    screeningCompleted?: BoolFilter<"NCDRiskAssessment"> | boolean
    followUpNeeded?: BoolFilter<"NCDRiskAssessment"> | boolean
    lifestyleModifications?: JsonFilter<"NCDRiskAssessment">
    healthEducationReceived?: JsonFilter<"NCDRiskAssessment">
    recordedBy?: StringFilter<"NCDRiskAssessment"> | string
  }

  export type VisitRecordUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: VisitRecordWhereUniqueInput
    update: XOR<VisitRecordUpdateWithoutUserProfileInput, VisitRecordUncheckedUpdateWithoutUserProfileInput>
    create: XOR<VisitRecordCreateWithoutUserProfileInput, VisitRecordUncheckedCreateWithoutUserProfileInput>
  }

  export type VisitRecordUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: VisitRecordWhereUniqueInput
    data: XOR<VisitRecordUpdateWithoutUserProfileInput, VisitRecordUncheckedUpdateWithoutUserProfileInput>
  }

  export type VisitRecordUpdateManyWithWhereWithoutUserProfileInput = {
    where: VisitRecordScalarWhereInput
    data: XOR<VisitRecordUpdateManyMutationInput, VisitRecordUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type VisitRecordScalarWhereInput = {
    AND?: VisitRecordScalarWhereInput | VisitRecordScalarWhereInput[]
    OR?: VisitRecordScalarWhereInput[]
    NOT?: VisitRecordScalarWhereInput | VisitRecordScalarWhereInput[]
    id?: StringFilter<"VisitRecord"> | string
    userProfileId?: StringFilter<"VisitRecord"> | string
    visitDate?: DateTimeFilter<"VisitRecord"> | Date | string
    visitType?: StringFilter<"VisitRecord"> | string
    visitFrequency?: StringNullableFilter<"VisitRecord"> | string | null
    referred?: BoolFilter<"VisitRecord"> | boolean
    facilityName?: StringNullableFilter<"VisitRecord"> | string | null
    referralReason?: StringNullableFilter<"VisitRecord"> | string | null
    recordedBy?: StringFilter<"VisitRecord"> | string
  }

  export type HealthEducationUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: HealthEducationWhereUniqueInput
    update: XOR<HealthEducationUpdateWithoutUserProfileInput, HealthEducationUncheckedUpdateWithoutUserProfileInput>
    create: XOR<HealthEducationCreateWithoutUserProfileInput, HealthEducationUncheckedCreateWithoutUserProfileInput>
  }

  export type HealthEducationUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: HealthEducationWhereUniqueInput
    data: XOR<HealthEducationUpdateWithoutUserProfileInput, HealthEducationUncheckedUpdateWithoutUserProfileInput>
  }

  export type HealthEducationUpdateManyWithWhereWithoutUserProfileInput = {
    where: HealthEducationScalarWhereInput
    data: XOR<HealthEducationUpdateManyMutationInput, HealthEducationUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type HealthEducationScalarWhereInput = {
    AND?: HealthEducationScalarWhereInput | HealthEducationScalarWhereInput[]
    OR?: HealthEducationScalarWhereInput[]
    NOT?: HealthEducationScalarWhereInput | HealthEducationScalarWhereInput[]
    id?: StringFilter<"HealthEducation"> | string
    userProfileId?: StringFilter<"HealthEducation"> | string
    topicsCovered?: JsonFilter<"HealthEducation">
    dateProvided?: DateTimeFilter<"HealthEducation"> | Date | string
    providedBy?: StringFilter<"HealthEducation"> | string
  }

  export type NutritionalCounselingUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: NutritionalCounselingWhereUniqueInput
    update: XOR<NutritionalCounselingUpdateWithoutUserProfileInput, NutritionalCounselingUncheckedUpdateWithoutUserProfileInput>
    create: XOR<NutritionalCounselingCreateWithoutUserProfileInput, NutritionalCounselingUncheckedCreateWithoutUserProfileInput>
  }

  export type NutritionalCounselingUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: NutritionalCounselingWhereUniqueInput
    data: XOR<NutritionalCounselingUpdateWithoutUserProfileInput, NutritionalCounselingUncheckedUpdateWithoutUserProfileInput>
  }

  export type NutritionalCounselingUpdateManyWithWhereWithoutUserProfileInput = {
    where: NutritionalCounselingScalarWhereInput
    data: XOR<NutritionalCounselingUpdateManyMutationInput, NutritionalCounselingUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type NutritionalCounselingScalarWhereInput = {
    AND?: NutritionalCounselingScalarWhereInput | NutritionalCounselingScalarWhereInput[]
    OR?: NutritionalCounselingScalarWhereInput[]
    NOT?: NutritionalCounselingScalarWhereInput | NutritionalCounselingScalarWhereInput[]
    id?: StringFilter<"NutritionalCounseling"> | string
    userProfileId?: StringFilter<"NutritionalCounseling"> | string
    recommendations?: StringFilter<"NutritionalCounseling"> | string
    dateProvided?: DateTimeFilter<"NutritionalCounseling"> | Date | string
    providedBy?: StringFilter<"NutritionalCounseling"> | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutUserProfileInput, ReferralUncheckedUpdateWithoutUserProfileInput>
    create: XOR<ReferralCreateWithoutUserProfileInput, ReferralUncheckedCreateWithoutUserProfileInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutUserProfileInput, ReferralUncheckedUpdateWithoutUserProfileInput>
  }

  export type ReferralUpdateManyWithWhereWithoutUserProfileInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    userProfileId?: StringFilter<"Referral"> | string
    facilityName?: StringFilter<"Referral"> | string
    reason?: StringFilter<"Referral"> | string
    dateReferred?: DateTimeFilter<"Referral"> | Date | string
    status?: StringFilter<"Referral"> | string
    referredBy?: StringFilter<"Referral"> | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutUserProfileInput, AppointmentUncheckedUpdateWithoutUserProfileInput>
    create: XOR<AppointmentCreateWithoutUserProfileInput, AppointmentUncheckedCreateWithoutUserProfileInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutUserProfileInput, AppointmentUncheckedUpdateWithoutUserProfileInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutUserProfileInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    userProfileId?: StringFilter<"Appointment"> | string
    nextVisitDate?: DateTimeFilter<"Appointment"> | Date | string
    visitType?: StringFilter<"Appointment"> | string
    appointmentStatus?: StringFilter<"Appointment"> | string
    scheduledBy?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type ImmunizationReminderUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: ImmunizationReminderWhereUniqueInput
    update: XOR<ImmunizationReminderUpdateWithoutUserProfileInput, ImmunizationReminderUncheckedUpdateWithoutUserProfileInput>
    create: XOR<ImmunizationReminderCreateWithoutUserProfileInput, ImmunizationReminderUncheckedCreateWithoutUserProfileInput>
  }

  export type ImmunizationReminderUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: ImmunizationReminderWhereUniqueInput
    data: XOR<ImmunizationReminderUpdateWithoutUserProfileInput, ImmunizationReminderUncheckedUpdateWithoutUserProfileInput>
  }

  export type ImmunizationReminderUpdateManyWithWhereWithoutUserProfileInput = {
    where: ImmunizationReminderScalarWhereInput
    data: XOR<ImmunizationReminderUpdateManyMutationInput, ImmunizationReminderUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type ImmunizationReminderScalarWhereInput = {
    AND?: ImmunizationReminderScalarWhereInput | ImmunizationReminderScalarWhereInput[]
    OR?: ImmunizationReminderScalarWhereInput[]
    NOT?: ImmunizationReminderScalarWhereInput | ImmunizationReminderScalarWhereInput[]
    id?: StringFilter<"ImmunizationReminder"> | string
    userProfileId?: StringFilter<"ImmunizationReminder"> | string
    vaccineName?: StringFilter<"ImmunizationReminder"> | string
    dueDate?: DateTimeFilter<"ImmunizationReminder"> | Date | string
    reminderSent?: BoolFilter<"ImmunizationReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"ImmunizationReminder"> | Date | string | null
  }

  export type TestReminderUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: TestReminderWhereUniqueInput
    update: XOR<TestReminderUpdateWithoutUserProfileInput, TestReminderUncheckedUpdateWithoutUserProfileInput>
    create: XOR<TestReminderCreateWithoutUserProfileInput, TestReminderUncheckedCreateWithoutUserProfileInput>
  }

  export type TestReminderUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: TestReminderWhereUniqueInput
    data: XOR<TestReminderUpdateWithoutUserProfileInput, TestReminderUncheckedUpdateWithoutUserProfileInput>
  }

  export type TestReminderUpdateManyWithWhereWithoutUserProfileInput = {
    where: TestReminderScalarWhereInput
    data: XOR<TestReminderUpdateManyMutationInput, TestReminderUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type TestReminderScalarWhereInput = {
    AND?: TestReminderScalarWhereInput | TestReminderScalarWhereInput[]
    OR?: TestReminderScalarWhereInput[]
    NOT?: TestReminderScalarWhereInput | TestReminderScalarWhereInput[]
    id?: StringFilter<"TestReminder"> | string
    userProfileId?: StringFilter<"TestReminder"> | string
    testName?: StringFilter<"TestReminder"> | string
    dueDate?: DateTimeFilter<"TestReminder"> | Date | string
    reminderSent?: BoolFilter<"TestReminder"> | boolean
    sentAt?: DateTimeNullableFilter<"TestReminder"> | Date | string | null
  }

  export type VirtualCheckupUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: VirtualCheckupWhereUniqueInput
    update: XOR<VirtualCheckupUpdateWithoutUserProfileInput, VirtualCheckupUncheckedUpdateWithoutUserProfileInput>
    create: XOR<VirtualCheckupCreateWithoutUserProfileInput, VirtualCheckupUncheckedCreateWithoutUserProfileInput>
  }

  export type VirtualCheckupUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: VirtualCheckupWhereUniqueInput
    data: XOR<VirtualCheckupUpdateWithoutUserProfileInput, VirtualCheckupUncheckedUpdateWithoutUserProfileInput>
  }

  export type VirtualCheckupUpdateManyWithWhereWithoutUserProfileInput = {
    where: VirtualCheckupScalarWhereInput
    data: XOR<VirtualCheckupUpdateManyMutationInput, VirtualCheckupUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type VirtualCheckupScalarWhereInput = {
    AND?: VirtualCheckupScalarWhereInput | VirtualCheckupScalarWhereInput[]
    OR?: VirtualCheckupScalarWhereInput[]
    NOT?: VirtualCheckupScalarWhereInput | VirtualCheckupScalarWhereInput[]
    id?: StringFilter<"VirtualCheckup"> | string
    userProfileId?: StringFilter<"VirtualCheckup"> | string
    healthWorkerId?: StringFilter<"VirtualCheckup"> | string
    scheduledDate?: DateTimeFilter<"VirtualCheckup"> | Date | string
    scheduledTime?: StringFilter<"VirtualCheckup"> | string
    meetingUrl?: StringNullableFilter<"VirtualCheckup"> | string | null
    status?: StringFilter<"VirtualCheckup"> | string
    consultationType?: StringNullableFilter<"VirtualCheckup"> | string | null
    chiefComplaint?: StringNullableFilter<"VirtualCheckup"> | string | null
    notes?: StringNullableFilter<"VirtualCheckup"> | string | null
    durationMinutes?: IntNullableFilter<"VirtualCheckup"> | number | null
    createdAt?: DateTimeFilter<"VirtualCheckup"> | Date | string
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutUserProfileInput, EventRegistrationUncheckedUpdateWithoutUserProfileInput>
    create: XOR<EventRegistrationCreateWithoutUserProfileInput, EventRegistrationUncheckedCreateWithoutUserProfileInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutUserProfileInput, EventRegistrationUncheckedUpdateWithoutUserProfileInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutUserProfileInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type EventRegistrationScalarWhereInput = {
    AND?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    OR?: EventRegistrationScalarWhereInput[]
    NOT?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    id?: StringFilter<"EventRegistration"> | string
    eventId?: StringFilter<"EventRegistration"> | string
    userProfileId?: StringFilter<"EventRegistration"> | string
    registrationDate?: DateTimeFilter<"EventRegistration"> | Date | string
    status?: StringFilter<"EventRegistration"> | string
    notes?: StringNullableFilter<"EventRegistration"> | string | null
  }

  export type ProgramParticipationUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: ProgramParticipationWhereUniqueInput
    update: XOR<ProgramParticipationUpdateWithoutUserProfileInput, ProgramParticipationUncheckedUpdateWithoutUserProfileInput>
    create: XOR<ProgramParticipationCreateWithoutUserProfileInput, ProgramParticipationUncheckedCreateWithoutUserProfileInput>
  }

  export type ProgramParticipationUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: ProgramParticipationWhereUniqueInput
    data: XOR<ProgramParticipationUpdateWithoutUserProfileInput, ProgramParticipationUncheckedUpdateWithoutUserProfileInput>
  }

  export type ProgramParticipationUpdateManyWithWhereWithoutUserProfileInput = {
    where: ProgramParticipationScalarWhereInput
    data: XOR<ProgramParticipationUpdateManyMutationInput, ProgramParticipationUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type ProgramParticipationScalarWhereInput = {
    AND?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
    OR?: ProgramParticipationScalarWhereInput[]
    NOT?: ProgramParticipationScalarWhereInput | ProgramParticipationScalarWhereInput[]
    id?: StringFilter<"ProgramParticipation"> | string
    medicalProgramId?: StringFilter<"ProgramParticipation"> | string
    userProfileId?: StringFilter<"ProgramParticipation"> | string
    participationDate?: DateTimeFilter<"ProgramParticipation"> | Date | string
    status?: StringFilter<"ProgramParticipation"> | string
    servicesReceived?: StringNullableFilter<"ProgramParticipation"> | string | null
    notes?: StringNullableFilter<"ProgramParticipation"> | string | null
    recordedBy?: StringFilter<"ProgramParticipation"> | string
  }

  export type InquiryUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutUserProfileInput, InquiryUncheckedUpdateWithoutUserProfileInput>
    create: XOR<InquiryCreateWithoutUserProfileInput, InquiryUncheckedCreateWithoutUserProfileInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutUserProfileInput, InquiryUncheckedUpdateWithoutUserProfileInput>
  }

  export type InquiryUpdateManyWithWhereWithoutUserProfileInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type InquiryScalarWhereInput = {
    AND?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    OR?: InquiryScalarWhereInput[]
    NOT?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    id?: StringFilter<"Inquiry"> | string
    userProfileId?: StringFilter<"Inquiry"> | string
    subject?: StringFilter<"Inquiry"> | string
    message?: StringFilter<"Inquiry"> | string
    priority?: StringFilter<"Inquiry"> | string
    status?: StringFilter<"Inquiry"> | string
    category?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
  }

  export type SurveyResponseUpsertWithWhereUniqueWithoutUserProfileInput = {
    where: SurveyResponseWhereUniqueInput
    update: XOR<SurveyResponseUpdateWithoutUserProfileInput, SurveyResponseUncheckedUpdateWithoutUserProfileInput>
    create: XOR<SurveyResponseCreateWithoutUserProfileInput, SurveyResponseUncheckedCreateWithoutUserProfileInput>
  }

  export type SurveyResponseUpdateWithWhereUniqueWithoutUserProfileInput = {
    where: SurveyResponseWhereUniqueInput
    data: XOR<SurveyResponseUpdateWithoutUserProfileInput, SurveyResponseUncheckedUpdateWithoutUserProfileInput>
  }

  export type SurveyResponseUpdateManyWithWhereWithoutUserProfileInput = {
    where: SurveyResponseScalarWhereInput
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyWithoutUserProfileInput>
  }

  export type SurveyResponseScalarWhereInput = {
    AND?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
    OR?: SurveyResponseScalarWhereInput[]
    NOT?: SurveyResponseScalarWhereInput | SurveyResponseScalarWhereInput[]
    id?: StringFilter<"SurveyResponse"> | string
    surveyId?: StringFilter<"SurveyResponse"> | string
    userProfileId?: StringFilter<"SurveyResponse"> | string
    ipAddress?: StringNullableFilter<"SurveyResponse"> | string | null
    submittedAt?: DateTimeFilter<"SurveyResponse"> | Date | string
  }

  export type AccountCreateWithoutHealthWorkersInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutHealthWorkersInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutHealthWorkersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutHealthWorkersInput, AccountUncheckedCreateWithoutHealthWorkersInput>
  }

  export type VirtualCheckupCreateWithoutHealthWorkerInput = {
    id?: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutVirtualCheckupsInput
    virtualCheckupNotes?: VirtualCheckupNoteCreateNestedManyWithoutVirtualCheckupInput
  }

  export type VirtualCheckupUncheckedCreateWithoutHealthWorkerInput = {
    id?: string
    userProfileId: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
    virtualCheckupNotes?: VirtualCheckupNoteUncheckedCreateNestedManyWithoutVirtualCheckupInput
  }

  export type VirtualCheckupCreateOrConnectWithoutHealthWorkerInput = {
    where: VirtualCheckupWhereUniqueInput
    create: XOR<VirtualCheckupCreateWithoutHealthWorkerInput, VirtualCheckupUncheckedCreateWithoutHealthWorkerInput>
  }

  export type VirtualCheckupCreateManyHealthWorkerInputEnvelope = {
    data: VirtualCheckupCreateManyHealthWorkerInput | VirtualCheckupCreateManyHealthWorkerInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutHealthWorkersInput = {
    update: XOR<AccountUpdateWithoutHealthWorkersInput, AccountUncheckedUpdateWithoutHealthWorkersInput>
    create: XOR<AccountCreateWithoutHealthWorkersInput, AccountUncheckedCreateWithoutHealthWorkersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutHealthWorkersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutHealthWorkersInput, AccountUncheckedUpdateWithoutHealthWorkersInput>
  }

  export type AccountUpdateWithoutHealthWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutHealthWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type VirtualCheckupUpsertWithWhereUniqueWithoutHealthWorkerInput = {
    where: VirtualCheckupWhereUniqueInput
    update: XOR<VirtualCheckupUpdateWithoutHealthWorkerInput, VirtualCheckupUncheckedUpdateWithoutHealthWorkerInput>
    create: XOR<VirtualCheckupCreateWithoutHealthWorkerInput, VirtualCheckupUncheckedCreateWithoutHealthWorkerInput>
  }

  export type VirtualCheckupUpdateWithWhereUniqueWithoutHealthWorkerInput = {
    where: VirtualCheckupWhereUniqueInput
    data: XOR<VirtualCheckupUpdateWithoutHealthWorkerInput, VirtualCheckupUncheckedUpdateWithoutHealthWorkerInput>
  }

  export type VirtualCheckupUpdateManyWithWhereWithoutHealthWorkerInput = {
    where: VirtualCheckupScalarWhereInput
    data: XOR<VirtualCheckupUpdateManyMutationInput, VirtualCheckupUncheckedUpdateManyWithoutHealthWorkerInput>
  }

  export type UserProfileCreateWithoutFamilyRecordsHeadedInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutFamilyRecordsHeadedInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutFamilyRecordsHeadedInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutFamilyRecordsHeadedInput, UserProfileUncheckedCreateWithoutFamilyRecordsHeadedInput>
  }

  export type FamilyMemberCreateWithoutFamilyRecordInput = {
    id?: string
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
    userProfile?: UserProfileCreateNestedOneWithoutFamilyMembersInput
  }

  export type FamilyMemberUncheckedCreateWithoutFamilyRecordInput = {
    id?: string
    userProfileId?: string | null
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
  }

  export type FamilyMemberCreateOrConnectWithoutFamilyRecordInput = {
    where: FamilyMemberWhereUniqueInput
    create: XOR<FamilyMemberCreateWithoutFamilyRecordInput, FamilyMemberUncheckedCreateWithoutFamilyRecordInput>
  }

  export type FamilyMemberCreateManyFamilyRecordInputEnvelope = {
    data: FamilyMemberCreateManyFamilyRecordInput | FamilyMemberCreateManyFamilyRecordInput[]
    skipDuplicates?: boolean
  }

  export type FamilyHealthHistoryCreateWithoutFamilyRecordInput = {
    id?: string
    geneticConditions: JsonNullValueInput | InputJsonValue
    chronicDiseases: JsonNullValueInput | InputJsonValue
    recordedDate?: Date | string
    recordedBy: string
  }

  export type FamilyHealthHistoryUncheckedCreateWithoutFamilyRecordInput = {
    id?: string
    geneticConditions: JsonNullValueInput | InputJsonValue
    chronicDiseases: JsonNullValueInput | InputJsonValue
    recordedDate?: Date | string
    recordedBy: string
  }

  export type FamilyHealthHistoryCreateOrConnectWithoutFamilyRecordInput = {
    where: FamilyHealthHistoryWhereUniqueInput
    create: XOR<FamilyHealthHistoryCreateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedCreateWithoutFamilyRecordInput>
  }

  export type UserProfileUpsertWithoutFamilyRecordsHeadedInput = {
    update: XOR<UserProfileUpdateWithoutFamilyRecordsHeadedInput, UserProfileUncheckedUpdateWithoutFamilyRecordsHeadedInput>
    create: XOR<UserProfileCreateWithoutFamilyRecordsHeadedInput, UserProfileUncheckedCreateWithoutFamilyRecordsHeadedInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutFamilyRecordsHeadedInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutFamilyRecordsHeadedInput, UserProfileUncheckedUpdateWithoutFamilyRecordsHeadedInput>
  }

  export type UserProfileUpdateWithoutFamilyRecordsHeadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutFamilyRecordsHeadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type FamilyMemberUpsertWithWhereUniqueWithoutFamilyRecordInput = {
    where: FamilyMemberWhereUniqueInput
    update: XOR<FamilyMemberUpdateWithoutFamilyRecordInput, FamilyMemberUncheckedUpdateWithoutFamilyRecordInput>
    create: XOR<FamilyMemberCreateWithoutFamilyRecordInput, FamilyMemberUncheckedCreateWithoutFamilyRecordInput>
  }

  export type FamilyMemberUpdateWithWhereUniqueWithoutFamilyRecordInput = {
    where: FamilyMemberWhereUniqueInput
    data: XOR<FamilyMemberUpdateWithoutFamilyRecordInput, FamilyMemberUncheckedUpdateWithoutFamilyRecordInput>
  }

  export type FamilyMemberUpdateManyWithWhereWithoutFamilyRecordInput = {
    where: FamilyMemberScalarWhereInput
    data: XOR<FamilyMemberUpdateManyMutationInput, FamilyMemberUncheckedUpdateManyWithoutFamilyRecordInput>
  }

  export type FamilyHealthHistoryUpsertWithoutFamilyRecordInput = {
    update: XOR<FamilyHealthHistoryUpdateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedUpdateWithoutFamilyRecordInput>
    create: XOR<FamilyHealthHistoryCreateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedCreateWithoutFamilyRecordInput>
    where?: FamilyHealthHistoryWhereInput
  }

  export type FamilyHealthHistoryUpdateToOneWithWhereWithoutFamilyRecordInput = {
    where?: FamilyHealthHistoryWhereInput
    data: XOR<FamilyHealthHistoryUpdateWithoutFamilyRecordInput, FamilyHealthHistoryUncheckedUpdateWithoutFamilyRecordInput>
  }

  export type FamilyHealthHistoryUpdateWithoutFamilyRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    geneticConditions?: JsonNullValueInput | InputJsonValue
    chronicDiseases?: JsonNullValueInput | InputJsonValue
    recordedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyHealthHistoryUncheckedUpdateWithoutFamilyRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    geneticConditions?: JsonNullValueInput | InputJsonValue
    chronicDiseases?: JsonNullValueInput | InputJsonValue
    recordedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyRecordCreateWithoutMembersInput = {
    id?: string
    familyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    headOfFamily: UserProfileCreateNestedOneWithoutFamilyRecordsHeadedInput
    familyHealthHistory?: FamilyHealthHistoryCreateNestedOneWithoutFamilyRecordInput
  }

  export type FamilyRecordUncheckedCreateWithoutMembersInput = {
    id?: string
    familyId: string
    headOfFamilyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    familyHealthHistory?: FamilyHealthHistoryUncheckedCreateNestedOneWithoutFamilyRecordInput
  }

  export type FamilyRecordCreateOrConnectWithoutMembersInput = {
    where: FamilyRecordWhereUniqueInput
    create: XOR<FamilyRecordCreateWithoutMembersInput, FamilyRecordUncheckedCreateWithoutMembersInput>
  }

  export type UserProfileCreateWithoutFamilyMembersInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutFamilyMembersInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutFamilyMembersInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutFamilyMembersInput, UserProfileUncheckedCreateWithoutFamilyMembersInput>
  }

  export type FamilyRecordUpsertWithoutMembersInput = {
    update: XOR<FamilyRecordUpdateWithoutMembersInput, FamilyRecordUncheckedUpdateWithoutMembersInput>
    create: XOR<FamilyRecordCreateWithoutMembersInput, FamilyRecordUncheckedCreateWithoutMembersInput>
    where?: FamilyRecordWhereInput
  }

  export type FamilyRecordUpdateToOneWithWhereWithoutMembersInput = {
    where?: FamilyRecordWhereInput
    data: XOR<FamilyRecordUpdateWithoutMembersInput, FamilyRecordUncheckedUpdateWithoutMembersInput>
  }

  export type FamilyRecordUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headOfFamily?: UserProfileUpdateOneRequiredWithoutFamilyRecordsHeadedNestedInput
    familyHealthHistory?: FamilyHealthHistoryUpdateOneWithoutFamilyRecordNestedInput
  }

  export type FamilyRecordUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyHealthHistory?: FamilyHealthHistoryUncheckedUpdateOneWithoutFamilyRecordNestedInput
  }

  export type UserProfileUpsertWithoutFamilyMembersInput = {
    update: XOR<UserProfileUpdateWithoutFamilyMembersInput, UserProfileUncheckedUpdateWithoutFamilyMembersInput>
    create: XOR<UserProfileCreateWithoutFamilyMembersInput, UserProfileUncheckedCreateWithoutFamilyMembersInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutFamilyMembersInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutFamilyMembersInput, UserProfileUncheckedUpdateWithoutFamilyMembersInput>
  }

  export type UserProfileUpdateWithoutFamilyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutFamilyMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type FamilyRecordCreateWithoutFamilyHealthHistoryInput = {
    id?: string
    familyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    headOfFamily: UserProfileCreateNestedOneWithoutFamilyRecordsHeadedInput
    members?: FamilyMemberCreateNestedManyWithoutFamilyRecordInput
  }

  export type FamilyRecordUncheckedCreateWithoutFamilyHealthHistoryInput = {
    id?: string
    familyId: string
    headOfFamilyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: FamilyMemberUncheckedCreateNestedManyWithoutFamilyRecordInput
  }

  export type FamilyRecordCreateOrConnectWithoutFamilyHealthHistoryInput = {
    where: FamilyRecordWhereUniqueInput
    create: XOR<FamilyRecordCreateWithoutFamilyHealthHistoryInput, FamilyRecordUncheckedCreateWithoutFamilyHealthHistoryInput>
  }

  export type FamilyRecordUpsertWithoutFamilyHealthHistoryInput = {
    update: XOR<FamilyRecordUpdateWithoutFamilyHealthHistoryInput, FamilyRecordUncheckedUpdateWithoutFamilyHealthHistoryInput>
    create: XOR<FamilyRecordCreateWithoutFamilyHealthHistoryInput, FamilyRecordUncheckedCreateWithoutFamilyHealthHistoryInput>
    where?: FamilyRecordWhereInput
  }

  export type FamilyRecordUpdateToOneWithWhereWithoutFamilyHealthHistoryInput = {
    where?: FamilyRecordWhereInput
    data: XOR<FamilyRecordUpdateWithoutFamilyHealthHistoryInput, FamilyRecordUncheckedUpdateWithoutFamilyHealthHistoryInput>
  }

  export type FamilyRecordUpdateWithoutFamilyHealthHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    headOfFamily?: UserProfileUpdateOneRequiredWithoutFamilyRecordsHeadedNestedInput
    members?: FamilyMemberUpdateManyWithoutFamilyRecordNestedInput
  }

  export type FamilyRecordUncheckedUpdateWithoutFamilyHealthHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    headOfFamilyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyMemberUncheckedUpdateManyWithoutFamilyRecordNestedInput
  }

  export type UserProfileCreateWithoutMaternalHealthRecordsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutMaternalHealthRecordsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutMaternalHealthRecordsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutMaternalHealthRecordsInput, UserProfileUncheckedCreateWithoutMaternalHealthRecordsInput>
  }

  export type PrenatalVisitCreateWithoutMaternalHealthInput = {
    id?: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    laboratoryTests?: LaboratoryTestCreateNestedManyWithoutPrenatalVisitInput
    interventions?: InterventionCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitUncheckedCreateWithoutMaternalHealthInput = {
    id?: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    laboratoryTests?: LaboratoryTestUncheckedCreateNestedManyWithoutPrenatalVisitInput
    interventions?: InterventionUncheckedCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitCreateOrConnectWithoutMaternalHealthInput = {
    where: PrenatalVisitWhereUniqueInput
    create: XOR<PrenatalVisitCreateWithoutMaternalHealthInput, PrenatalVisitUncheckedCreateWithoutMaternalHealthInput>
  }

  export type PrenatalVisitCreateManyMaternalHealthInputEnvelope = {
    data: PrenatalVisitCreateManyMaternalHealthInput | PrenatalVisitCreateManyMaternalHealthInput[]
    skipDuplicates?: boolean
  }

  export type BirthInformationCreateWithoutMaternalHealthInput = {
    id?: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutBirthInformationInput
  }

  export type BirthInformationUncheckedCreateWithoutMaternalHealthInput = {
    id?: string
    userProfileId: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
  }

  export type BirthInformationCreateOrConnectWithoutMaternalHealthInput = {
    where: BirthInformationWhereUniqueInput
    create: XOR<BirthInformationCreateWithoutMaternalHealthInput, BirthInformationUncheckedCreateWithoutMaternalHealthInput>
  }

  export type BirthInformationCreateManyMaternalHealthInputEnvelope = {
    data: BirthInformationCreateManyMaternalHealthInput | BirthInformationCreateManyMaternalHealthInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutMaternalHealthRecordsInput = {
    update: XOR<UserProfileUpdateWithoutMaternalHealthRecordsInput, UserProfileUncheckedUpdateWithoutMaternalHealthRecordsInput>
    create: XOR<UserProfileCreateWithoutMaternalHealthRecordsInput, UserProfileUncheckedCreateWithoutMaternalHealthRecordsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutMaternalHealthRecordsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutMaternalHealthRecordsInput, UserProfileUncheckedUpdateWithoutMaternalHealthRecordsInput>
  }

  export type UserProfileUpdateWithoutMaternalHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutMaternalHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type PrenatalVisitUpsertWithWhereUniqueWithoutMaternalHealthInput = {
    where: PrenatalVisitWhereUniqueInput
    update: XOR<PrenatalVisitUpdateWithoutMaternalHealthInput, PrenatalVisitUncheckedUpdateWithoutMaternalHealthInput>
    create: XOR<PrenatalVisitCreateWithoutMaternalHealthInput, PrenatalVisitUncheckedCreateWithoutMaternalHealthInput>
  }

  export type PrenatalVisitUpdateWithWhereUniqueWithoutMaternalHealthInput = {
    where: PrenatalVisitWhereUniqueInput
    data: XOR<PrenatalVisitUpdateWithoutMaternalHealthInput, PrenatalVisitUncheckedUpdateWithoutMaternalHealthInput>
  }

  export type PrenatalVisitUpdateManyWithWhereWithoutMaternalHealthInput = {
    where: PrenatalVisitScalarWhereInput
    data: XOR<PrenatalVisitUpdateManyMutationInput, PrenatalVisitUncheckedUpdateManyWithoutMaternalHealthInput>
  }

  export type PrenatalVisitScalarWhereInput = {
    AND?: PrenatalVisitScalarWhereInput | PrenatalVisitScalarWhereInput[]
    OR?: PrenatalVisitScalarWhereInput[]
    NOT?: PrenatalVisitScalarWhereInput | PrenatalVisitScalarWhereInput[]
    id?: StringFilter<"PrenatalVisit"> | string
    maternalHealthId?: StringFilter<"PrenatalVisit"> | string
    visitDate?: DateTimeFilter<"PrenatalVisit"> | Date | string
    gestationalAgeWeeks?: IntFilter<"PrenatalVisit"> | number
    weightKg?: FloatFilter<"PrenatalVisit"> | number
    heightCm?: FloatFilter<"PrenatalVisit"> | number
    bloodPressure?: StringFilter<"PrenatalVisit"> | string
    fundalHeightCm?: FloatFilter<"PrenatalVisit"> | number
    fetalHeartTone?: StringFilter<"PrenatalVisit"> | string
    nextVisitDate?: DateTimeNullableFilter<"PrenatalVisit"> | Date | string | null
    recordedBy?: StringFilter<"PrenatalVisit"> | string
  }

  export type BirthInformationUpsertWithWhereUniqueWithoutMaternalHealthInput = {
    where: BirthInformationWhereUniqueInput
    update: XOR<BirthInformationUpdateWithoutMaternalHealthInput, BirthInformationUncheckedUpdateWithoutMaternalHealthInput>
    create: XOR<BirthInformationCreateWithoutMaternalHealthInput, BirthInformationUncheckedCreateWithoutMaternalHealthInput>
  }

  export type BirthInformationUpdateWithWhereUniqueWithoutMaternalHealthInput = {
    where: BirthInformationWhereUniqueInput
    data: XOR<BirthInformationUpdateWithoutMaternalHealthInput, BirthInformationUncheckedUpdateWithoutMaternalHealthInput>
  }

  export type BirthInformationUpdateManyWithWhereWithoutMaternalHealthInput = {
    where: BirthInformationScalarWhereInput
    data: XOR<BirthInformationUpdateManyMutationInput, BirthInformationUncheckedUpdateManyWithoutMaternalHealthInput>
  }

  export type MaternalHealthCreateWithoutPrenatalVisitsInput = {
    id?: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutMaternalHealthRecordsInput
    birthInformation?: BirthInformationCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthUncheckedCreateWithoutPrenatalVisitsInput = {
    id?: string
    userProfileId: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthCreateOrConnectWithoutPrenatalVisitsInput = {
    where: MaternalHealthWhereUniqueInput
    create: XOR<MaternalHealthCreateWithoutPrenatalVisitsInput, MaternalHealthUncheckedCreateWithoutPrenatalVisitsInput>
  }

  export type LaboratoryTestCreateWithoutPrenatalVisitInput = {
    id?: string
    userProfileId: string
    testDate: Date | string
    testType: string
    testCompleted?: boolean
    recordedBy: string
  }

  export type LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput = {
    id?: string
    userProfileId: string
    testDate: Date | string
    testType: string
    testCompleted?: boolean
    recordedBy: string
  }

  export type LaboratoryTestCreateOrConnectWithoutPrenatalVisitInput = {
    where: LaboratoryTestWhereUniqueInput
    create: XOR<LaboratoryTestCreateWithoutPrenatalVisitInput, LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput>
  }

  export type LaboratoryTestCreateManyPrenatalVisitInputEnvelope = {
    data: LaboratoryTestCreateManyPrenatalVisitInput | LaboratoryTestCreateManyPrenatalVisitInput[]
    skipDuplicates?: boolean
  }

  export type InterventionCreateWithoutPrenatalVisitInput = {
    id?: string
    tetanusToxoidDose?: string | null
    tetanusToxoidLocation?: string | null
    tetanusToxoidDate?: Date | string | null
    ironSupplementation?: boolean
    ironMedication?: string | null
    vitaminSupplementation?: boolean
    vitaminMedication?: string | null
    calciumSupplementation?: boolean
    calciumMedication?: string | null
    healthEducationTopics: JsonNullValueInput | InputJsonValue
  }

  export type InterventionUncheckedCreateWithoutPrenatalVisitInput = {
    id?: string
    tetanusToxoidDose?: string | null
    tetanusToxoidLocation?: string | null
    tetanusToxoidDate?: Date | string | null
    ironSupplementation?: boolean
    ironMedication?: string | null
    vitaminSupplementation?: boolean
    vitaminMedication?: string | null
    calciumSupplementation?: boolean
    calciumMedication?: string | null
    healthEducationTopics: JsonNullValueInput | InputJsonValue
  }

  export type InterventionCreateOrConnectWithoutPrenatalVisitInput = {
    where: InterventionWhereUniqueInput
    create: XOR<InterventionCreateWithoutPrenatalVisitInput, InterventionUncheckedCreateWithoutPrenatalVisitInput>
  }

  export type InterventionCreateManyPrenatalVisitInputEnvelope = {
    data: InterventionCreateManyPrenatalVisitInput | InterventionCreateManyPrenatalVisitInput[]
    skipDuplicates?: boolean
  }

  export type MaternalHealthUpsertWithoutPrenatalVisitsInput = {
    update: XOR<MaternalHealthUpdateWithoutPrenatalVisitsInput, MaternalHealthUncheckedUpdateWithoutPrenatalVisitsInput>
    create: XOR<MaternalHealthCreateWithoutPrenatalVisitsInput, MaternalHealthUncheckedCreateWithoutPrenatalVisitsInput>
    where?: MaternalHealthWhereInput
  }

  export type MaternalHealthUpdateToOneWithWhereWithoutPrenatalVisitsInput = {
    where?: MaternalHealthWhereInput
    data: XOR<MaternalHealthUpdateWithoutPrenatalVisitsInput, MaternalHealthUncheckedUpdateWithoutPrenatalVisitsInput>
  }

  export type MaternalHealthUpdateWithoutPrenatalVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutMaternalHealthRecordsNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutMaternalHealthNestedInput
  }

  export type MaternalHealthUncheckedUpdateWithoutPrenatalVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutMaternalHealthNestedInput
  }

  export type LaboratoryTestUpsertWithWhereUniqueWithoutPrenatalVisitInput = {
    where: LaboratoryTestWhereUniqueInput
    update: XOR<LaboratoryTestUpdateWithoutPrenatalVisitInput, LaboratoryTestUncheckedUpdateWithoutPrenatalVisitInput>
    create: XOR<LaboratoryTestCreateWithoutPrenatalVisitInput, LaboratoryTestUncheckedCreateWithoutPrenatalVisitInput>
  }

  export type LaboratoryTestUpdateWithWhereUniqueWithoutPrenatalVisitInput = {
    where: LaboratoryTestWhereUniqueInput
    data: XOR<LaboratoryTestUpdateWithoutPrenatalVisitInput, LaboratoryTestUncheckedUpdateWithoutPrenatalVisitInput>
  }

  export type LaboratoryTestUpdateManyWithWhereWithoutPrenatalVisitInput = {
    where: LaboratoryTestScalarWhereInput
    data: XOR<LaboratoryTestUpdateManyMutationInput, LaboratoryTestUncheckedUpdateManyWithoutPrenatalVisitInput>
  }

  export type LaboratoryTestScalarWhereInput = {
    AND?: LaboratoryTestScalarWhereInput | LaboratoryTestScalarWhereInput[]
    OR?: LaboratoryTestScalarWhereInput[]
    NOT?: LaboratoryTestScalarWhereInput | LaboratoryTestScalarWhereInput[]
    id?: StringFilter<"LaboratoryTest"> | string
    prenatalVisitId?: StringFilter<"LaboratoryTest"> | string
    userProfileId?: StringFilter<"LaboratoryTest"> | string
    testDate?: DateTimeFilter<"LaboratoryTest"> | Date | string
    testType?: StringFilter<"LaboratoryTest"> | string
    testCompleted?: BoolFilter<"LaboratoryTest"> | boolean
    recordedBy?: StringFilter<"LaboratoryTest"> | string
  }

  export type InterventionUpsertWithWhereUniqueWithoutPrenatalVisitInput = {
    where: InterventionWhereUniqueInput
    update: XOR<InterventionUpdateWithoutPrenatalVisitInput, InterventionUncheckedUpdateWithoutPrenatalVisitInput>
    create: XOR<InterventionCreateWithoutPrenatalVisitInput, InterventionUncheckedCreateWithoutPrenatalVisitInput>
  }

  export type InterventionUpdateWithWhereUniqueWithoutPrenatalVisitInput = {
    where: InterventionWhereUniqueInput
    data: XOR<InterventionUpdateWithoutPrenatalVisitInput, InterventionUncheckedUpdateWithoutPrenatalVisitInput>
  }

  export type InterventionUpdateManyWithWhereWithoutPrenatalVisitInput = {
    where: InterventionScalarWhereInput
    data: XOR<InterventionUpdateManyMutationInput, InterventionUncheckedUpdateManyWithoutPrenatalVisitInput>
  }

  export type InterventionScalarWhereInput = {
    AND?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    OR?: InterventionScalarWhereInput[]
    NOT?: InterventionScalarWhereInput | InterventionScalarWhereInput[]
    id?: StringFilter<"Intervention"> | string
    prenatalVisitId?: StringFilter<"Intervention"> | string
    tetanusToxoidDose?: StringNullableFilter<"Intervention"> | string | null
    tetanusToxoidLocation?: StringNullableFilter<"Intervention"> | string | null
    tetanusToxoidDate?: DateTimeNullableFilter<"Intervention"> | Date | string | null
    ironSupplementation?: BoolFilter<"Intervention"> | boolean
    ironMedication?: StringNullableFilter<"Intervention"> | string | null
    vitaminSupplementation?: BoolFilter<"Intervention"> | boolean
    vitaminMedication?: StringNullableFilter<"Intervention"> | string | null
    calciumSupplementation?: BoolFilter<"Intervention"> | boolean
    calciumMedication?: StringNullableFilter<"Intervention"> | string | null
    healthEducationTopics?: JsonFilter<"Intervention">
  }

  export type PrenatalVisitCreateWithoutLaboratoryTestsInput = {
    id?: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    maternalHealth: MaternalHealthCreateNestedOneWithoutPrenatalVisitsInput
    interventions?: InterventionCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitUncheckedCreateWithoutLaboratoryTestsInput = {
    id?: string
    maternalHealthId: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    interventions?: InterventionUncheckedCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitCreateOrConnectWithoutLaboratoryTestsInput = {
    where: PrenatalVisitWhereUniqueInput
    create: XOR<PrenatalVisitCreateWithoutLaboratoryTestsInput, PrenatalVisitUncheckedCreateWithoutLaboratoryTestsInput>
  }

  export type PrenatalVisitUpsertWithoutLaboratoryTestsInput = {
    update: XOR<PrenatalVisitUpdateWithoutLaboratoryTestsInput, PrenatalVisitUncheckedUpdateWithoutLaboratoryTestsInput>
    create: XOR<PrenatalVisitCreateWithoutLaboratoryTestsInput, PrenatalVisitUncheckedCreateWithoutLaboratoryTestsInput>
    where?: PrenatalVisitWhereInput
  }

  export type PrenatalVisitUpdateToOneWithWhereWithoutLaboratoryTestsInput = {
    where?: PrenatalVisitWhereInput
    data: XOR<PrenatalVisitUpdateWithoutLaboratoryTestsInput, PrenatalVisitUncheckedUpdateWithoutLaboratoryTestsInput>
  }

  export type PrenatalVisitUpdateWithoutLaboratoryTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    maternalHealth?: MaternalHealthUpdateOneRequiredWithoutPrenatalVisitsNestedInput
    interventions?: InterventionUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type PrenatalVisitUncheckedUpdateWithoutLaboratoryTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    interventions?: InterventionUncheckedUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type PrenatalVisitCreateWithoutInterventionsInput = {
    id?: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    maternalHealth: MaternalHealthCreateNestedOneWithoutPrenatalVisitsInput
    laboratoryTests?: LaboratoryTestCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitUncheckedCreateWithoutInterventionsInput = {
    id?: string
    maternalHealthId: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
    laboratoryTests?: LaboratoryTestUncheckedCreateNestedManyWithoutPrenatalVisitInput
  }

  export type PrenatalVisitCreateOrConnectWithoutInterventionsInput = {
    where: PrenatalVisitWhereUniqueInput
    create: XOR<PrenatalVisitCreateWithoutInterventionsInput, PrenatalVisitUncheckedCreateWithoutInterventionsInput>
  }

  export type PrenatalVisitUpsertWithoutInterventionsInput = {
    update: XOR<PrenatalVisitUpdateWithoutInterventionsInput, PrenatalVisitUncheckedUpdateWithoutInterventionsInput>
    create: XOR<PrenatalVisitCreateWithoutInterventionsInput, PrenatalVisitUncheckedCreateWithoutInterventionsInput>
    where?: PrenatalVisitWhereInput
  }

  export type PrenatalVisitUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: PrenatalVisitWhereInput
    data: XOR<PrenatalVisitUpdateWithoutInterventionsInput, PrenatalVisitUncheckedUpdateWithoutInterventionsInput>
  }

  export type PrenatalVisitUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    maternalHealth?: MaternalHealthUpdateOneRequiredWithoutPrenatalVisitsNestedInput
    laboratoryTests?: LaboratoryTestUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type PrenatalVisitUncheckedUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    laboratoryTests?: LaboratoryTestUncheckedUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type UserProfileCreateWithoutBirthInformationInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutBirthInformationInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutBirthInformationInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutBirthInformationInput, UserProfileUncheckedCreateWithoutBirthInformationInput>
  }

  export type MaternalHealthCreateWithoutBirthInformationInput = {
    id?: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutMaternalHealthRecordsInput
    prenatalVisits?: PrenatalVisitCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthUncheckedCreateWithoutBirthInformationInput = {
    id?: string
    userProfileId: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
    prenatalVisits?: PrenatalVisitUncheckedCreateNestedManyWithoutMaternalHealthInput
  }

  export type MaternalHealthCreateOrConnectWithoutBirthInformationInput = {
    where: MaternalHealthWhereUniqueInput
    create: XOR<MaternalHealthCreateWithoutBirthInformationInput, MaternalHealthUncheckedCreateWithoutBirthInformationInput>
  }

  export type UserProfileUpsertWithoutBirthInformationInput = {
    update: XOR<UserProfileUpdateWithoutBirthInformationInput, UserProfileUncheckedUpdateWithoutBirthInformationInput>
    create: XOR<UserProfileCreateWithoutBirthInformationInput, UserProfileUncheckedCreateWithoutBirthInformationInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutBirthInformationInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutBirthInformationInput, UserProfileUncheckedUpdateWithoutBirthInformationInput>
  }

  export type UserProfileUpdateWithoutBirthInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutBirthInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type MaternalHealthUpsertWithoutBirthInformationInput = {
    update: XOR<MaternalHealthUpdateWithoutBirthInformationInput, MaternalHealthUncheckedUpdateWithoutBirthInformationInput>
    create: XOR<MaternalHealthCreateWithoutBirthInformationInput, MaternalHealthUncheckedCreateWithoutBirthInformationInput>
    where?: MaternalHealthWhereInput
  }

  export type MaternalHealthUpdateToOneWithWhereWithoutBirthInformationInput = {
    where?: MaternalHealthWhereInput
    data: XOR<MaternalHealthUpdateWithoutBirthInformationInput, MaternalHealthUncheckedUpdateWithoutBirthInformationInput>
  }

  export type MaternalHealthUpdateWithoutBirthInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutMaternalHealthRecordsNestedInput
    prenatalVisits?: PrenatalVisitUpdateManyWithoutMaternalHealthNestedInput
  }

  export type MaternalHealthUncheckedUpdateWithoutBirthInformationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenatalVisits?: PrenatalVisitUncheckedUpdateManyWithoutMaternalHealthNestedInput
  }

  export type UserProfileCreateWithoutImmunizationEventsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutImmunizationEventsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutImmunizationEventsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutImmunizationEventsInput, UserProfileUncheckedCreateWithoutImmunizationEventsInput>
  }

  export type VaccineGivenCreateWithoutImmunizationEventInput = {
    id?: string
    vaccineName: string
    doseNumber: string
    dateGiven: Date | string
    lotNumber?: string | null
  }

  export type VaccineGivenUncheckedCreateWithoutImmunizationEventInput = {
    id?: string
    vaccineName: string
    doseNumber: string
    dateGiven: Date | string
    lotNumber?: string | null
  }

  export type VaccineGivenCreateOrConnectWithoutImmunizationEventInput = {
    where: VaccineGivenWhereUniqueInput
    create: XOR<VaccineGivenCreateWithoutImmunizationEventInput, VaccineGivenUncheckedCreateWithoutImmunizationEventInput>
  }

  export type VaccineGivenCreateManyImmunizationEventInputEnvelope = {
    data: VaccineGivenCreateManyImmunizationEventInput | VaccineGivenCreateManyImmunizationEventInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutImmunizationEventsInput = {
    update: XOR<UserProfileUpdateWithoutImmunizationEventsInput, UserProfileUncheckedUpdateWithoutImmunizationEventsInput>
    create: XOR<UserProfileCreateWithoutImmunizationEventsInput, UserProfileUncheckedCreateWithoutImmunizationEventsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutImmunizationEventsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutImmunizationEventsInput, UserProfileUncheckedUpdateWithoutImmunizationEventsInput>
  }

  export type UserProfileUpdateWithoutImmunizationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutImmunizationEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type VaccineGivenUpsertWithWhereUniqueWithoutImmunizationEventInput = {
    where: VaccineGivenWhereUniqueInput
    update: XOR<VaccineGivenUpdateWithoutImmunizationEventInput, VaccineGivenUncheckedUpdateWithoutImmunizationEventInput>
    create: XOR<VaccineGivenCreateWithoutImmunizationEventInput, VaccineGivenUncheckedCreateWithoutImmunizationEventInput>
  }

  export type VaccineGivenUpdateWithWhereUniqueWithoutImmunizationEventInput = {
    where: VaccineGivenWhereUniqueInput
    data: XOR<VaccineGivenUpdateWithoutImmunizationEventInput, VaccineGivenUncheckedUpdateWithoutImmunizationEventInput>
  }

  export type VaccineGivenUpdateManyWithWhereWithoutImmunizationEventInput = {
    where: VaccineGivenScalarWhereInput
    data: XOR<VaccineGivenUpdateManyMutationInput, VaccineGivenUncheckedUpdateManyWithoutImmunizationEventInput>
  }

  export type VaccineGivenScalarWhereInput = {
    AND?: VaccineGivenScalarWhereInput | VaccineGivenScalarWhereInput[]
    OR?: VaccineGivenScalarWhereInput[]
    NOT?: VaccineGivenScalarWhereInput | VaccineGivenScalarWhereInput[]
    id?: StringFilter<"VaccineGiven"> | string
    immunizationEventId?: StringFilter<"VaccineGiven"> | string
    vaccineName?: StringFilter<"VaccineGiven"> | string
    doseNumber?: StringFilter<"VaccineGiven"> | string
    dateGiven?: DateTimeFilter<"VaccineGiven"> | Date | string
    lotNumber?: StringNullableFilter<"VaccineGiven"> | string | null
  }

  export type ImmunizationEventCreateWithoutVaccinesGivenInput = {
    id?: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutImmunizationEventsInput
  }

  export type ImmunizationEventUncheckedCreateWithoutVaccinesGivenInput = {
    id?: string
    userProfileId: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
  }

  export type ImmunizationEventCreateOrConnectWithoutVaccinesGivenInput = {
    where: ImmunizationEventWhereUniqueInput
    create: XOR<ImmunizationEventCreateWithoutVaccinesGivenInput, ImmunizationEventUncheckedCreateWithoutVaccinesGivenInput>
  }

  export type ImmunizationEventUpsertWithoutVaccinesGivenInput = {
    update: XOR<ImmunizationEventUpdateWithoutVaccinesGivenInput, ImmunizationEventUncheckedUpdateWithoutVaccinesGivenInput>
    create: XOR<ImmunizationEventCreateWithoutVaccinesGivenInput, ImmunizationEventUncheckedCreateWithoutVaccinesGivenInput>
    where?: ImmunizationEventWhereInput
  }

  export type ImmunizationEventUpdateToOneWithWhereWithoutVaccinesGivenInput = {
    where?: ImmunizationEventWhereInput
    data: XOR<ImmunizationEventUpdateWithoutVaccinesGivenInput, ImmunizationEventUncheckedUpdateWithoutVaccinesGivenInput>
  }

  export type ImmunizationEventUpdateWithoutVaccinesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutImmunizationEventsNestedInput
  }

  export type ImmunizationEventUncheckedUpdateWithoutVaccinesGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserProfileCreateWithoutVitalSignsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutVitalSignsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutVitalSignsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutVitalSignsInput, UserProfileUncheckedCreateWithoutVitalSignsInput>
  }

  export type UserProfileUpsertWithoutVitalSignsInput = {
    update: XOR<UserProfileUpdateWithoutVitalSignsInput, UserProfileUncheckedUpdateWithoutVitalSignsInput>
    create: XOR<UserProfileCreateWithoutVitalSignsInput, UserProfileUncheckedCreateWithoutVitalSignsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutVitalSignsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutVitalSignsInput, UserProfileUncheckedUpdateWithoutVitalSignsInput>
  }

  export type UserProfileUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutVitalSignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutAnthropometricMeasurementsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutAnthropometricMeasurementsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutAnthropometricMeasurementsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutAnthropometricMeasurementsInput, UserProfileUncheckedCreateWithoutAnthropometricMeasurementsInput>
  }

  export type UserProfileUpsertWithoutAnthropometricMeasurementsInput = {
    update: XOR<UserProfileUpdateWithoutAnthropometricMeasurementsInput, UserProfileUncheckedUpdateWithoutAnthropometricMeasurementsInput>
    create: XOR<UserProfileCreateWithoutAnthropometricMeasurementsInput, UserProfileUncheckedCreateWithoutAnthropometricMeasurementsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutAnthropometricMeasurementsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutAnthropometricMeasurementsInput, UserProfileUncheckedUpdateWithoutAnthropometricMeasurementsInput>
  }

  export type UserProfileUpdateWithoutAnthropometricMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutAnthropometricMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutGrowthTrackingInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutGrowthTrackingInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutGrowthTrackingInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutGrowthTrackingInput, UserProfileUncheckedCreateWithoutGrowthTrackingInput>
  }

  export type UserProfileUpsertWithoutGrowthTrackingInput = {
    update: XOR<UserProfileUpdateWithoutGrowthTrackingInput, UserProfileUncheckedUpdateWithoutGrowthTrackingInput>
    create: XOR<UserProfileCreateWithoutGrowthTrackingInput, UserProfileUncheckedCreateWithoutGrowthTrackingInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutGrowthTrackingInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutGrowthTrackingInput, UserProfileUncheckedUpdateWithoutGrowthTrackingInput>
  }

  export type UserProfileUpdateWithoutGrowthTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutGrowthTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutNcdRiskAssessmentsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutNcdRiskAssessmentsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutNcdRiskAssessmentsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutNcdRiskAssessmentsInput, UserProfileUncheckedCreateWithoutNcdRiskAssessmentsInput>
  }

  export type UserProfileUpsertWithoutNcdRiskAssessmentsInput = {
    update: XOR<UserProfileUpdateWithoutNcdRiskAssessmentsInput, UserProfileUncheckedUpdateWithoutNcdRiskAssessmentsInput>
    create: XOR<UserProfileCreateWithoutNcdRiskAssessmentsInput, UserProfileUncheckedCreateWithoutNcdRiskAssessmentsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutNcdRiskAssessmentsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutNcdRiskAssessmentsInput, UserProfileUncheckedUpdateWithoutNcdRiskAssessmentsInput>
  }

  export type UserProfileUpdateWithoutNcdRiskAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutNcdRiskAssessmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutVisitRecordsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutVisitRecordsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutVisitRecordsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutVisitRecordsInput, UserProfileUncheckedCreateWithoutVisitRecordsInput>
  }

  export type UserProfileUpsertWithoutVisitRecordsInput = {
    update: XOR<UserProfileUpdateWithoutVisitRecordsInput, UserProfileUncheckedUpdateWithoutVisitRecordsInput>
    create: XOR<UserProfileCreateWithoutVisitRecordsInput, UserProfileUncheckedCreateWithoutVisitRecordsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutVisitRecordsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutVisitRecordsInput, UserProfileUncheckedUpdateWithoutVisitRecordsInput>
  }

  export type UserProfileUpdateWithoutVisitRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutVisitRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutHealthEducationInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutHealthEducationInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutHealthEducationInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutHealthEducationInput, UserProfileUncheckedCreateWithoutHealthEducationInput>
  }

  export type UserProfileUpsertWithoutHealthEducationInput = {
    update: XOR<UserProfileUpdateWithoutHealthEducationInput, UserProfileUncheckedUpdateWithoutHealthEducationInput>
    create: XOR<UserProfileCreateWithoutHealthEducationInput, UserProfileUncheckedCreateWithoutHealthEducationInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutHealthEducationInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutHealthEducationInput, UserProfileUncheckedUpdateWithoutHealthEducationInput>
  }

  export type UserProfileUpdateWithoutHealthEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutHealthEducationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutNutritionalCounselingInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutNutritionalCounselingInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutNutritionalCounselingInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutNutritionalCounselingInput, UserProfileUncheckedCreateWithoutNutritionalCounselingInput>
  }

  export type UserProfileUpsertWithoutNutritionalCounselingInput = {
    update: XOR<UserProfileUpdateWithoutNutritionalCounselingInput, UserProfileUncheckedUpdateWithoutNutritionalCounselingInput>
    create: XOR<UserProfileCreateWithoutNutritionalCounselingInput, UserProfileUncheckedCreateWithoutNutritionalCounselingInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutNutritionalCounselingInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutNutritionalCounselingInput, UserProfileUncheckedUpdateWithoutNutritionalCounselingInput>
  }

  export type UserProfileUpdateWithoutNutritionalCounselingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutNutritionalCounselingInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutReferralsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutReferralsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutReferralsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutReferralsInput, UserProfileUncheckedCreateWithoutReferralsInput>
  }

  export type UserProfileUpsertWithoutReferralsInput = {
    update: XOR<UserProfileUpdateWithoutReferralsInput, UserProfileUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserProfileCreateWithoutReferralsInput, UserProfileUncheckedCreateWithoutReferralsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutReferralsInput, UserProfileUncheckedUpdateWithoutReferralsInput>
  }

  export type UserProfileUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutAppointmentsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutAppointmentsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutAppointmentsInput, UserProfileUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserProfileUpsertWithoutAppointmentsInput = {
    update: XOR<UserProfileUpdateWithoutAppointmentsInput, UserProfileUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserProfileCreateWithoutAppointmentsInput, UserProfileUncheckedCreateWithoutAppointmentsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutAppointmentsInput, UserProfileUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserProfileUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutImmunizationRemindersInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutImmunizationRemindersInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutImmunizationRemindersInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutImmunizationRemindersInput, UserProfileUncheckedCreateWithoutImmunizationRemindersInput>
  }

  export type UserProfileUpsertWithoutImmunizationRemindersInput = {
    update: XOR<UserProfileUpdateWithoutImmunizationRemindersInput, UserProfileUncheckedUpdateWithoutImmunizationRemindersInput>
    create: XOR<UserProfileCreateWithoutImmunizationRemindersInput, UserProfileUncheckedCreateWithoutImmunizationRemindersInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutImmunizationRemindersInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutImmunizationRemindersInput, UserProfileUncheckedUpdateWithoutImmunizationRemindersInput>
  }

  export type UserProfileUpdateWithoutImmunizationRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutImmunizationRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutTestRemindersInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutTestRemindersInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutTestRemindersInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutTestRemindersInput, UserProfileUncheckedCreateWithoutTestRemindersInput>
  }

  export type UserProfileUpsertWithoutTestRemindersInput = {
    update: XOR<UserProfileUpdateWithoutTestRemindersInput, UserProfileUncheckedUpdateWithoutTestRemindersInput>
    create: XOR<UserProfileCreateWithoutTestRemindersInput, UserProfileUncheckedCreateWithoutTestRemindersInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutTestRemindersInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutTestRemindersInput, UserProfileUncheckedUpdateWithoutTestRemindersInput>
  }

  export type UserProfileUpdateWithoutTestRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutTestRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutVirtualCheckupsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutVirtualCheckupsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutVirtualCheckupsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutVirtualCheckupsInput, UserProfileUncheckedCreateWithoutVirtualCheckupsInput>
  }

  export type HealthWorkerCreateWithoutVirtualCheckupsInput = {
    id?: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
    account: AccountCreateNestedOneWithoutHealthWorkersInput
  }

  export type HealthWorkerUncheckedCreateWithoutVirtualCheckupsInput = {
    id?: string
    accountId: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
  }

  export type HealthWorkerCreateOrConnectWithoutVirtualCheckupsInput = {
    where: HealthWorkerWhereUniqueInput
    create: XOR<HealthWorkerCreateWithoutVirtualCheckupsInput, HealthWorkerUncheckedCreateWithoutVirtualCheckupsInput>
  }

  export type VirtualCheckupNoteCreateWithoutVirtualCheckupInput = {
    id?: string
    note: string
    createdBy: string
  }

  export type VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput = {
    id?: string
    note: string
    createdBy: string
  }

  export type VirtualCheckupNoteCreateOrConnectWithoutVirtualCheckupInput = {
    where: VirtualCheckupNoteWhereUniqueInput
    create: XOR<VirtualCheckupNoteCreateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput>
  }

  export type VirtualCheckupNoteCreateManyVirtualCheckupInputEnvelope = {
    data: VirtualCheckupNoteCreateManyVirtualCheckupInput | VirtualCheckupNoteCreateManyVirtualCheckupInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutVirtualCheckupsInput = {
    update: XOR<UserProfileUpdateWithoutVirtualCheckupsInput, UserProfileUncheckedUpdateWithoutVirtualCheckupsInput>
    create: XOR<UserProfileCreateWithoutVirtualCheckupsInput, UserProfileUncheckedCreateWithoutVirtualCheckupsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutVirtualCheckupsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutVirtualCheckupsInput, UserProfileUncheckedUpdateWithoutVirtualCheckupsInput>
  }

  export type UserProfileUpdateWithoutVirtualCheckupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutVirtualCheckupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type HealthWorkerUpsertWithoutVirtualCheckupsInput = {
    update: XOR<HealthWorkerUpdateWithoutVirtualCheckupsInput, HealthWorkerUncheckedUpdateWithoutVirtualCheckupsInput>
    create: XOR<HealthWorkerCreateWithoutVirtualCheckupsInput, HealthWorkerUncheckedCreateWithoutVirtualCheckupsInput>
    where?: HealthWorkerWhereInput
  }

  export type HealthWorkerUpdateToOneWithWhereWithoutVirtualCheckupsInput = {
    where?: HealthWorkerWhereInput
    data: XOR<HealthWorkerUpdateWithoutVirtualCheckupsInput, HealthWorkerUncheckedUpdateWithoutVirtualCheckupsInput>
  }

  export type HealthWorkerUpdateWithoutVirtualCheckupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    account?: AccountUpdateOneRequiredWithoutHealthWorkersNestedInput
  }

  export type HealthWorkerUncheckedUpdateWithoutVirtualCheckupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VirtualCheckupNoteUpsertWithWhereUniqueWithoutVirtualCheckupInput = {
    where: VirtualCheckupNoteWhereUniqueInput
    update: XOR<VirtualCheckupNoteUpdateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedUpdateWithoutVirtualCheckupInput>
    create: XOR<VirtualCheckupNoteCreateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedCreateWithoutVirtualCheckupInput>
  }

  export type VirtualCheckupNoteUpdateWithWhereUniqueWithoutVirtualCheckupInput = {
    where: VirtualCheckupNoteWhereUniqueInput
    data: XOR<VirtualCheckupNoteUpdateWithoutVirtualCheckupInput, VirtualCheckupNoteUncheckedUpdateWithoutVirtualCheckupInput>
  }

  export type VirtualCheckupNoteUpdateManyWithWhereWithoutVirtualCheckupInput = {
    where: VirtualCheckupNoteScalarWhereInput
    data: XOR<VirtualCheckupNoteUpdateManyMutationInput, VirtualCheckupNoteUncheckedUpdateManyWithoutVirtualCheckupInput>
  }

  export type VirtualCheckupNoteScalarWhereInput = {
    AND?: VirtualCheckupNoteScalarWhereInput | VirtualCheckupNoteScalarWhereInput[]
    OR?: VirtualCheckupNoteScalarWhereInput[]
    NOT?: VirtualCheckupNoteScalarWhereInput | VirtualCheckupNoteScalarWhereInput[]
    id?: StringFilter<"VirtualCheckupNote"> | string
    virtualCheckupId?: StringFilter<"VirtualCheckupNote"> | string
    note?: StringFilter<"VirtualCheckupNote"> | string
    createdBy?: StringFilter<"VirtualCheckupNote"> | string
  }

  export type VirtualCheckupCreateWithoutVirtualCheckupNotesInput = {
    id?: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutVirtualCheckupsInput
    healthWorker: HealthWorkerCreateNestedOneWithoutVirtualCheckupsInput
  }

  export type VirtualCheckupUncheckedCreateWithoutVirtualCheckupNotesInput = {
    id?: string
    userProfileId: string
    healthWorkerId: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
  }

  export type VirtualCheckupCreateOrConnectWithoutVirtualCheckupNotesInput = {
    where: VirtualCheckupWhereUniqueInput
    create: XOR<VirtualCheckupCreateWithoutVirtualCheckupNotesInput, VirtualCheckupUncheckedCreateWithoutVirtualCheckupNotesInput>
  }

  export type VirtualCheckupUpsertWithoutVirtualCheckupNotesInput = {
    update: XOR<VirtualCheckupUpdateWithoutVirtualCheckupNotesInput, VirtualCheckupUncheckedUpdateWithoutVirtualCheckupNotesInput>
    create: XOR<VirtualCheckupCreateWithoutVirtualCheckupNotesInput, VirtualCheckupUncheckedCreateWithoutVirtualCheckupNotesInput>
    where?: VirtualCheckupWhereInput
  }

  export type VirtualCheckupUpdateToOneWithWhereWithoutVirtualCheckupNotesInput = {
    where?: VirtualCheckupWhereInput
    data: XOR<VirtualCheckupUpdateWithoutVirtualCheckupNotesInput, VirtualCheckupUncheckedUpdateWithoutVirtualCheckupNotesInput>
  }

  export type VirtualCheckupUpdateWithoutVirtualCheckupNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutVirtualCheckupsNestedInput
    healthWorker?: HealthWorkerUpdateOneRequiredWithoutVirtualCheckupsNestedInput
  }

  export type VirtualCheckupUncheckedUpdateWithoutVirtualCheckupNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    healthWorkerId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateWithoutEventsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutEventsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutEventsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
  }

  export type EventRegistrationCreateWithoutEventInput = {
    id?: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
    userProfile: UserProfileCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutEventInput = {
    id?: string
    userProfileId: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
  }

  export type EventRegistrationCreateOrConnectWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationCreateManyEventInputEnvelope = {
    data: EventRegistrationCreateManyEventInput | EventRegistrationCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutEventsInput = {
    update: XOR<AccountUpdateWithoutEventsInput, AccountUncheckedUpdateWithoutEventsInput>
    create: XOR<AccountCreateWithoutEventsInput, AccountUncheckedCreateWithoutEventsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutEventsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutEventsInput, AccountUncheckedUpdateWithoutEventsInput>
  }

  export type AccountUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutEventInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutEventRegistrationsInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutEventRegistrationsInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type EventCreateOrConnectWithoutEventRegistrationsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventRegistrationsInput, EventUncheckedCreateWithoutEventRegistrationsInput>
  }

  export type UserProfileCreateWithoutEventRegistrationsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutEventRegistrationsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutEventRegistrationsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutEventRegistrationsInput, UserProfileUncheckedCreateWithoutEventRegistrationsInput>
  }

  export type EventUpsertWithoutEventRegistrationsInput = {
    update: XOR<EventUpdateWithoutEventRegistrationsInput, EventUncheckedUpdateWithoutEventRegistrationsInput>
    create: XOR<EventCreateWithoutEventRegistrationsInput, EventUncheckedCreateWithoutEventRegistrationsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventRegistrationsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventRegistrationsInput, EventUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type EventUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpsertWithoutEventRegistrationsInput = {
    update: XOR<UserProfileUpdateWithoutEventRegistrationsInput, UserProfileUncheckedUpdateWithoutEventRegistrationsInput>
    create: XOR<UserProfileCreateWithoutEventRegistrationsInput, UserProfileUncheckedCreateWithoutEventRegistrationsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutEventRegistrationsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutEventRegistrationsInput, UserProfileUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type UserProfileUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type AccountCreateWithoutMedicalProgramsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
  }

  export type AccountUncheckedCreateWithoutMedicalProgramsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type AccountCreateOrConnectWithoutMedicalProgramsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutMedicalProgramsInput, AccountUncheckedCreateWithoutMedicalProgramsInput>
  }

  export type ProgramParticipationCreateWithoutMedicalProgramInput = {
    id?: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
    userProfile: UserProfileCreateNestedOneWithoutProgramParticipationsInput
  }

  export type ProgramParticipationUncheckedCreateWithoutMedicalProgramInput = {
    id?: string
    userProfileId: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
  }

  export type ProgramParticipationCreateOrConnectWithoutMedicalProgramInput = {
    where: ProgramParticipationWhereUniqueInput
    create: XOR<ProgramParticipationCreateWithoutMedicalProgramInput, ProgramParticipationUncheckedCreateWithoutMedicalProgramInput>
  }

  export type ProgramParticipationCreateManyMedicalProgramInputEnvelope = {
    data: ProgramParticipationCreateManyMedicalProgramInput | ProgramParticipationCreateManyMedicalProgramInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutMedicalProgramsInput = {
    update: XOR<AccountUpdateWithoutMedicalProgramsInput, AccountUncheckedUpdateWithoutMedicalProgramsInput>
    create: XOR<AccountCreateWithoutMedicalProgramsInput, AccountUncheckedCreateWithoutMedicalProgramsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutMedicalProgramsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutMedicalProgramsInput, AccountUncheckedUpdateWithoutMedicalProgramsInput>
  }

  export type AccountUpdateWithoutMedicalProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
  }

  export type AccountUncheckedUpdateWithoutMedicalProgramsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProgramParticipationUpsertWithWhereUniqueWithoutMedicalProgramInput = {
    where: ProgramParticipationWhereUniqueInput
    update: XOR<ProgramParticipationUpdateWithoutMedicalProgramInput, ProgramParticipationUncheckedUpdateWithoutMedicalProgramInput>
    create: XOR<ProgramParticipationCreateWithoutMedicalProgramInput, ProgramParticipationUncheckedCreateWithoutMedicalProgramInput>
  }

  export type ProgramParticipationUpdateWithWhereUniqueWithoutMedicalProgramInput = {
    where: ProgramParticipationWhereUniqueInput
    data: XOR<ProgramParticipationUpdateWithoutMedicalProgramInput, ProgramParticipationUncheckedUpdateWithoutMedicalProgramInput>
  }

  export type ProgramParticipationUpdateManyWithWhereWithoutMedicalProgramInput = {
    where: ProgramParticipationScalarWhereInput
    data: XOR<ProgramParticipationUpdateManyMutationInput, ProgramParticipationUncheckedUpdateManyWithoutMedicalProgramInput>
  }

  export type MedicalProgramCreateWithoutProgramParticipationsInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutMedicalProgramsInput
  }

  export type MedicalProgramUncheckedCreateWithoutProgramParticipationsInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdBy: string
    createdAt?: Date | string
  }

  export type MedicalProgramCreateOrConnectWithoutProgramParticipationsInput = {
    where: MedicalProgramWhereUniqueInput
    create: XOR<MedicalProgramCreateWithoutProgramParticipationsInput, MedicalProgramUncheckedCreateWithoutProgramParticipationsInput>
  }

  export type UserProfileCreateWithoutProgramParticipationsInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutProgramParticipationsInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutProgramParticipationsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutProgramParticipationsInput, UserProfileUncheckedCreateWithoutProgramParticipationsInput>
  }

  export type MedicalProgramUpsertWithoutProgramParticipationsInput = {
    update: XOR<MedicalProgramUpdateWithoutProgramParticipationsInput, MedicalProgramUncheckedUpdateWithoutProgramParticipationsInput>
    create: XOR<MedicalProgramCreateWithoutProgramParticipationsInput, MedicalProgramUncheckedCreateWithoutProgramParticipationsInput>
    where?: MedicalProgramWhereInput
  }

  export type MedicalProgramUpdateToOneWithWhereWithoutProgramParticipationsInput = {
    where?: MedicalProgramWhereInput
    data: XOR<MedicalProgramUpdateWithoutProgramParticipationsInput, MedicalProgramUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type MedicalProgramUpdateWithoutProgramParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutMedicalProgramsNestedInput
  }

  export type MedicalProgramUncheckedUpdateWithoutProgramParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpsertWithoutProgramParticipationsInput = {
    update: XOR<UserProfileUpdateWithoutProgramParticipationsInput, UserProfileUncheckedUpdateWithoutProgramParticipationsInput>
    create: XOR<UserProfileCreateWithoutProgramParticipationsInput, UserProfileUncheckedCreateWithoutProgramParticipationsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutProgramParticipationsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutProgramParticipationsInput, UserProfileUncheckedUpdateWithoutProgramParticipationsInput>
  }

  export type UserProfileUpdateWithoutProgramParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutProgramParticipationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileCreateWithoutInquiriesInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutInquiriesInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutInquiriesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutInquiriesInput, UserProfileUncheckedCreateWithoutInquiriesInput>
  }

  export type InquiryResponseCreateWithoutInquiryInput = {
    id?: string
    message: string
    responder: AccountCreateNestedOneWithoutInquiryResponsesInput
  }

  export type InquiryResponseUncheckedCreateWithoutInquiryInput = {
    id?: string
    message: string
    respondedBy: string
  }

  export type InquiryResponseCreateOrConnectWithoutInquiryInput = {
    where: InquiryResponseWhereUniqueInput
    create: XOR<InquiryResponseCreateWithoutInquiryInput, InquiryResponseUncheckedCreateWithoutInquiryInput>
  }

  export type InquiryResponseCreateManyInquiryInputEnvelope = {
    data: InquiryResponseCreateManyInquiryInput | InquiryResponseCreateManyInquiryInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutInquiriesInput = {
    update: XOR<UserProfileUpdateWithoutInquiriesInput, UserProfileUncheckedUpdateWithoutInquiriesInput>
    create: XOR<UserProfileCreateWithoutInquiriesInput, UserProfileUncheckedCreateWithoutInquiriesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutInquiriesInput, UserProfileUncheckedUpdateWithoutInquiriesInput>
  }

  export type UserProfileUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type InquiryResponseUpsertWithWhereUniqueWithoutInquiryInput = {
    where: InquiryResponseWhereUniqueInput
    update: XOR<InquiryResponseUpdateWithoutInquiryInput, InquiryResponseUncheckedUpdateWithoutInquiryInput>
    create: XOR<InquiryResponseCreateWithoutInquiryInput, InquiryResponseUncheckedCreateWithoutInquiryInput>
  }

  export type InquiryResponseUpdateWithWhereUniqueWithoutInquiryInput = {
    where: InquiryResponseWhereUniqueInput
    data: XOR<InquiryResponseUpdateWithoutInquiryInput, InquiryResponseUncheckedUpdateWithoutInquiryInput>
  }

  export type InquiryResponseUpdateManyWithWhereWithoutInquiryInput = {
    where: InquiryResponseScalarWhereInput
    data: XOR<InquiryResponseUpdateManyMutationInput, InquiryResponseUncheckedUpdateManyWithoutInquiryInput>
  }

  export type InquiryCreateWithoutInquiryResponsesInput = {
    id?: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateWithoutInquiryResponsesInput = {
    id?: string
    userProfileId: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
  }

  export type InquiryCreateOrConnectWithoutInquiryResponsesInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutInquiryResponsesInput, InquiryUncheckedCreateWithoutInquiryResponsesInput>
  }

  export type AccountCreateWithoutInquiryResponsesInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutInquiryResponsesInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutInquiryResponsesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutInquiryResponsesInput, AccountUncheckedCreateWithoutInquiryResponsesInput>
  }

  export type InquiryUpsertWithoutInquiryResponsesInput = {
    update: XOR<InquiryUpdateWithoutInquiryResponsesInput, InquiryUncheckedUpdateWithoutInquiryResponsesInput>
    create: XOR<InquiryCreateWithoutInquiryResponsesInput, InquiryUncheckedCreateWithoutInquiryResponsesInput>
    where?: InquiryWhereInput
  }

  export type InquiryUpdateToOneWithWhereWithoutInquiryResponsesInput = {
    where?: InquiryWhereInput
    data: XOR<InquiryUpdateWithoutInquiryResponsesInput, InquiryUncheckedUpdateWithoutInquiryResponsesInput>
  }

  export type InquiryUpdateWithoutInquiryResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateWithoutInquiryResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithoutInquiryResponsesInput = {
    update: XOR<AccountUpdateWithoutInquiryResponsesInput, AccountUncheckedUpdateWithoutInquiryResponsesInput>
    create: XOR<AccountCreateWithoutInquiryResponsesInput, AccountUncheckedCreateWithoutInquiryResponsesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutInquiryResponsesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutInquiryResponsesInput, AccountUncheckedUpdateWithoutInquiryResponsesInput>
  }

  export type AccountUpdateWithoutInquiryResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutInquiryResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateWithoutSurveysInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutSurveysInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutSurveysInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSurveysInput, AccountUncheckedCreateWithoutSurveysInput>
  }

  export type SurveyQuestionCreateWithoutSurveyInput = {
    id?: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
    surveyAnswers?: SurveyAnswerCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionUncheckedCreateWithoutSurveyInput = {
    id?: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
    surveyAnswers?: SurveyAnswerUncheckedCreateNestedManyWithoutSurveyQuestionInput
  }

  export type SurveyQuestionCreateOrConnectWithoutSurveyInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutSurveyInput, SurveyQuestionUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyQuestionCreateManySurveyInputEnvelope = {
    data: SurveyQuestionCreateManySurveyInput | SurveyQuestionCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type SurveyResponseCreateWithoutSurveyInput = {
    id?: string
    ipAddress?: string | null
    submittedAt?: Date | string
    userProfile: UserProfileCreateNestedOneWithoutSurveyResponsesInput
    surveyAnswers?: SurveyAnswerCreateNestedManyWithoutSurveyResponseInput
  }

  export type SurveyResponseUncheckedCreateWithoutSurveyInput = {
    id?: string
    userProfileId: string
    ipAddress?: string | null
    submittedAt?: Date | string
    surveyAnswers?: SurveyAnswerUncheckedCreateNestedManyWithoutSurveyResponseInput
  }

  export type SurveyResponseCreateOrConnectWithoutSurveyInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyResponseCreateManySurveyInputEnvelope = {
    data: SurveyResponseCreateManySurveyInput | SurveyResponseCreateManySurveyInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutSurveysInput = {
    update: XOR<AccountUpdateWithoutSurveysInput, AccountUncheckedUpdateWithoutSurveysInput>
    create: XOR<AccountCreateWithoutSurveysInput, AccountUncheckedCreateWithoutSurveysInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSurveysInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSurveysInput, AccountUncheckedUpdateWithoutSurveysInput>
  }

  export type AccountUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutSurveysInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SurveyQuestionUpsertWithWhereUniqueWithoutSurveyInput = {
    where: SurveyQuestionWhereUniqueInput
    update: XOR<SurveyQuestionUpdateWithoutSurveyInput, SurveyQuestionUncheckedUpdateWithoutSurveyInput>
    create: XOR<SurveyQuestionCreateWithoutSurveyInput, SurveyQuestionUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyQuestionUpdateWithWhereUniqueWithoutSurveyInput = {
    where: SurveyQuestionWhereUniqueInput
    data: XOR<SurveyQuestionUpdateWithoutSurveyInput, SurveyQuestionUncheckedUpdateWithoutSurveyInput>
  }

  export type SurveyQuestionUpdateManyWithWhereWithoutSurveyInput = {
    where: SurveyQuestionScalarWhereInput
    data: XOR<SurveyQuestionUpdateManyMutationInput, SurveyQuestionUncheckedUpdateManyWithoutSurveyInput>
  }

  export type SurveyQuestionScalarWhereInput = {
    AND?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
    OR?: SurveyQuestionScalarWhereInput[]
    NOT?: SurveyQuestionScalarWhereInput | SurveyQuestionScalarWhereInput[]
    id?: StringFilter<"SurveyQuestion"> | string
    surveyId?: StringFilter<"SurveyQuestion"> | string
    questionText?: StringFilter<"SurveyQuestion"> | string
    questionType?: StringFilter<"SurveyQuestion"> | string
    options?: JsonFilter<"SurveyQuestion">
    isRequired?: BoolFilter<"SurveyQuestion"> | boolean
    orderIndex?: IntFilter<"SurveyQuestion"> | number
  }

  export type SurveyResponseUpsertWithWhereUniqueWithoutSurveyInput = {
    where: SurveyResponseWhereUniqueInput
    update: XOR<SurveyResponseUpdateWithoutSurveyInput, SurveyResponseUncheckedUpdateWithoutSurveyInput>
    create: XOR<SurveyResponseCreateWithoutSurveyInput, SurveyResponseUncheckedCreateWithoutSurveyInput>
  }

  export type SurveyResponseUpdateWithWhereUniqueWithoutSurveyInput = {
    where: SurveyResponseWhereUniqueInput
    data: XOR<SurveyResponseUpdateWithoutSurveyInput, SurveyResponseUncheckedUpdateWithoutSurveyInput>
  }

  export type SurveyResponseUpdateManyWithWhereWithoutSurveyInput = {
    where: SurveyResponseScalarWhereInput
    data: XOR<SurveyResponseUpdateManyMutationInput, SurveyResponseUncheckedUpdateManyWithoutSurveyInput>
  }

  export type SurveyCreateWithoutSurveyQuestionsInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutSurveysInput
    surveyResponses?: SurveyResponseCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutSurveyQuestionsInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdBy: string
    createdAt?: Date | string
    surveyResponses?: SurveyResponseUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutSurveyQuestionsInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutSurveyQuestionsInput, SurveyUncheckedCreateWithoutSurveyQuestionsInput>
  }

  export type SurveyAnswerCreateWithoutSurveyQuestionInput = {
    id?: string
    answer: string
    surveyResponse: SurveyResponseCreateNestedOneWithoutSurveyAnswersInput
  }

  export type SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput = {
    id?: string
    surveyResponseId: string
    answer: string
  }

  export type SurveyAnswerCreateOrConnectWithoutSurveyQuestionInput = {
    where: SurveyAnswerWhereUniqueInput
    create: XOR<SurveyAnswerCreateWithoutSurveyQuestionInput, SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type SurveyAnswerCreateManySurveyQuestionInputEnvelope = {
    data: SurveyAnswerCreateManySurveyQuestionInput | SurveyAnswerCreateManySurveyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type SurveyUpsertWithoutSurveyQuestionsInput = {
    update: XOR<SurveyUpdateWithoutSurveyQuestionsInput, SurveyUncheckedUpdateWithoutSurveyQuestionsInput>
    create: XOR<SurveyCreateWithoutSurveyQuestionsInput, SurveyUncheckedCreateWithoutSurveyQuestionsInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutSurveyQuestionsInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutSurveyQuestionsInput, SurveyUncheckedUpdateWithoutSurveyQuestionsInput>
  }

  export type SurveyUpdateWithoutSurveyQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutSurveysNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutSurveyQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyAnswerUpsertWithWhereUniqueWithoutSurveyQuestionInput = {
    where: SurveyAnswerWhereUniqueInput
    update: XOR<SurveyAnswerUpdateWithoutSurveyQuestionInput, SurveyAnswerUncheckedUpdateWithoutSurveyQuestionInput>
    create: XOR<SurveyAnswerCreateWithoutSurveyQuestionInput, SurveyAnswerUncheckedCreateWithoutSurveyQuestionInput>
  }

  export type SurveyAnswerUpdateWithWhereUniqueWithoutSurveyQuestionInput = {
    where: SurveyAnswerWhereUniqueInput
    data: XOR<SurveyAnswerUpdateWithoutSurveyQuestionInput, SurveyAnswerUncheckedUpdateWithoutSurveyQuestionInput>
  }

  export type SurveyAnswerUpdateManyWithWhereWithoutSurveyQuestionInput = {
    where: SurveyAnswerScalarWhereInput
    data: XOR<SurveyAnswerUpdateManyMutationInput, SurveyAnswerUncheckedUpdateManyWithoutSurveyQuestionInput>
  }

  export type SurveyAnswerScalarWhereInput = {
    AND?: SurveyAnswerScalarWhereInput | SurveyAnswerScalarWhereInput[]
    OR?: SurveyAnswerScalarWhereInput[]
    NOT?: SurveyAnswerScalarWhereInput | SurveyAnswerScalarWhereInput[]
    id?: StringFilter<"SurveyAnswer"> | string
    surveyResponseId?: StringFilter<"SurveyAnswer"> | string
    surveyQuestionId?: StringFilter<"SurveyAnswer"> | string
    answer?: StringFilter<"SurveyAnswer"> | string
  }

  export type SurveyCreateWithoutSurveyResponsesInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdAt?: Date | string
    creator: AccountCreateNestedOneWithoutSurveysInput
    surveyQuestions?: SurveyQuestionCreateNestedManyWithoutSurveyInput
  }

  export type SurveyUncheckedCreateWithoutSurveyResponsesInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdBy: string
    createdAt?: Date | string
    surveyQuestions?: SurveyQuestionUncheckedCreateNestedManyWithoutSurveyInput
  }

  export type SurveyCreateOrConnectWithoutSurveyResponsesInput = {
    where: SurveyWhereUniqueInput
    create: XOR<SurveyCreateWithoutSurveyResponsesInput, SurveyUncheckedCreateWithoutSurveyResponsesInput>
  }

  export type UserProfileCreateWithoutSurveyResponsesInput = {
    id?: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutUserProfileInput
    familyRecordsHeaded?: FamilyRecordCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileUncheckedCreateWithoutSurveyResponsesInput = {
    id?: string
    accountId: string
    fullName: string
    dateOfBirth: Date | string
    age: number
    gender: string
    address: string
    contactNumber: string
    religion?: string | null
    civilStatus: string
    occupation?: string | null
    educationLevel?: string | null
    philhealthNumber?: string | null
    nhtsStatus?: string | null
    personWithDisability?: boolean
    indigenousPeople?: boolean
    createdAt?: Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedCreateNestedManyWithoutHeadOfFamilyInput
    familyMembers?: FamilyMemberUncheckedCreateNestedManyWithoutUserProfileInput
    maternalHealthRecords?: MaternalHealthUncheckedCreateNestedManyWithoutUserProfileInput
    birthInformation?: BirthInformationUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationEvents?: ImmunizationEventUncheckedCreateNestedManyWithoutUserProfileInput
    vitalSigns?: VitalSignsUncheckedCreateNestedManyWithoutUserProfileInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedCreateNestedManyWithoutUserProfileInput
    growthTracking?: GrowthTrackingUncheckedCreateNestedManyWithoutUserProfileInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedCreateNestedManyWithoutUserProfileInput
    visitRecords?: VisitRecordUncheckedCreateNestedManyWithoutUserProfileInput
    healthEducation?: HealthEducationUncheckedCreateNestedManyWithoutUserProfileInput
    nutritionalCounseling?: NutritionalCounselingUncheckedCreateNestedManyWithoutUserProfileInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutUserProfileInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserProfileInput
    immunizationReminders?: ImmunizationReminderUncheckedCreateNestedManyWithoutUserProfileInput
    testReminders?: TestReminderUncheckedCreateNestedManyWithoutUserProfileInput
    virtualCheckups?: VirtualCheckupUncheckedCreateNestedManyWithoutUserProfileInput
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserProfileInput
    programParticipations?: ProgramParticipationUncheckedCreateNestedManyWithoutUserProfileInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutUserProfileInput
  }

  export type UserProfileCreateOrConnectWithoutSurveyResponsesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutSurveyResponsesInput, UserProfileUncheckedCreateWithoutSurveyResponsesInput>
  }

  export type SurveyAnswerCreateWithoutSurveyResponseInput = {
    id?: string
    answer: string
    surveyQuestion: SurveyQuestionCreateNestedOneWithoutSurveyAnswersInput
  }

  export type SurveyAnswerUncheckedCreateWithoutSurveyResponseInput = {
    id?: string
    surveyQuestionId: string
    answer: string
  }

  export type SurveyAnswerCreateOrConnectWithoutSurveyResponseInput = {
    where: SurveyAnswerWhereUniqueInput
    create: XOR<SurveyAnswerCreateWithoutSurveyResponseInput, SurveyAnswerUncheckedCreateWithoutSurveyResponseInput>
  }

  export type SurveyAnswerCreateManySurveyResponseInputEnvelope = {
    data: SurveyAnswerCreateManySurveyResponseInput | SurveyAnswerCreateManySurveyResponseInput[]
    skipDuplicates?: boolean
  }

  export type SurveyUpsertWithoutSurveyResponsesInput = {
    update: XOR<SurveyUpdateWithoutSurveyResponsesInput, SurveyUncheckedUpdateWithoutSurveyResponsesInput>
    create: XOR<SurveyCreateWithoutSurveyResponsesInput, SurveyUncheckedCreateWithoutSurveyResponsesInput>
    where?: SurveyWhereInput
  }

  export type SurveyUpdateToOneWithWhereWithoutSurveyResponsesInput = {
    where?: SurveyWhereInput
    data: XOR<SurveyUpdateWithoutSurveyResponsesInput, SurveyUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type SurveyUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AccountUpdateOneRequiredWithoutSurveysNestedInput
    surveyQuestions?: SurveyQuestionUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type UserProfileUpsertWithoutSurveyResponsesInput = {
    update: XOR<UserProfileUpdateWithoutSurveyResponsesInput, UserProfileUncheckedUpdateWithoutSurveyResponsesInput>
    create: XOR<UserProfileCreateWithoutSurveyResponsesInput, UserProfileUncheckedCreateWithoutSurveyResponsesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutSurveyResponsesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutSurveyResponsesInput, UserProfileUncheckedUpdateWithoutSurveyResponsesInput>
  }

  export type UserProfileUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutUserProfileNestedInput
    familyRecordsHeaded?: FamilyRecordUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUpdateManyWithoutUserProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutSurveyResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    religion?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    educationLevel?: NullableStringFieldUpdateOperationsInput | string | null
    philhealthNumber?: NullableStringFieldUpdateOperationsInput | string | null
    nhtsStatus?: NullableStringFieldUpdateOperationsInput | string | null
    personWithDisability?: BoolFieldUpdateOperationsInput | boolean
    indigenousPeople?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familyRecordsHeaded?: FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyNestedInput
    familyMembers?: FamilyMemberUncheckedUpdateManyWithoutUserProfileNestedInput
    maternalHealthRecords?: MaternalHealthUncheckedUpdateManyWithoutUserProfileNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationEvents?: ImmunizationEventUncheckedUpdateManyWithoutUserProfileNestedInput
    vitalSigns?: VitalSignsUncheckedUpdateManyWithoutUserProfileNestedInput
    anthropometricMeasurements?: AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileNestedInput
    growthTracking?: GrowthTrackingUncheckedUpdateManyWithoutUserProfileNestedInput
    ncdRiskAssessments?: NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileNestedInput
    visitRecords?: VisitRecordUncheckedUpdateManyWithoutUserProfileNestedInput
    healthEducation?: HealthEducationUncheckedUpdateManyWithoutUserProfileNestedInput
    nutritionalCounseling?: NutritionalCounselingUncheckedUpdateManyWithoutUserProfileNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutUserProfileNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserProfileNestedInput
    immunizationReminders?: ImmunizationReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    testReminders?: TestReminderUncheckedUpdateManyWithoutUserProfileNestedInput
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutUserProfileNestedInput
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserProfileNestedInput
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutUserProfileNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutUserProfileNestedInput
  }

  export type SurveyAnswerUpsertWithWhereUniqueWithoutSurveyResponseInput = {
    where: SurveyAnswerWhereUniqueInput
    update: XOR<SurveyAnswerUpdateWithoutSurveyResponseInput, SurveyAnswerUncheckedUpdateWithoutSurveyResponseInput>
    create: XOR<SurveyAnswerCreateWithoutSurveyResponseInput, SurveyAnswerUncheckedCreateWithoutSurveyResponseInput>
  }

  export type SurveyAnswerUpdateWithWhereUniqueWithoutSurveyResponseInput = {
    where: SurveyAnswerWhereUniqueInput
    data: XOR<SurveyAnswerUpdateWithoutSurveyResponseInput, SurveyAnswerUncheckedUpdateWithoutSurveyResponseInput>
  }

  export type SurveyAnswerUpdateManyWithWhereWithoutSurveyResponseInput = {
    where: SurveyAnswerScalarWhereInput
    data: XOR<SurveyAnswerUpdateManyMutationInput, SurveyAnswerUncheckedUpdateManyWithoutSurveyResponseInput>
  }

  export type SurveyResponseCreateWithoutSurveyAnswersInput = {
    id?: string
    ipAddress?: string | null
    submittedAt?: Date | string
    survey: SurveyCreateNestedOneWithoutSurveyResponsesInput
    userProfile: UserProfileCreateNestedOneWithoutSurveyResponsesInput
  }

  export type SurveyResponseUncheckedCreateWithoutSurveyAnswersInput = {
    id?: string
    surveyId: string
    userProfileId: string
    ipAddress?: string | null
    submittedAt?: Date | string
  }

  export type SurveyResponseCreateOrConnectWithoutSurveyAnswersInput = {
    where: SurveyResponseWhereUniqueInput
    create: XOR<SurveyResponseCreateWithoutSurveyAnswersInput, SurveyResponseUncheckedCreateWithoutSurveyAnswersInput>
  }

  export type SurveyQuestionCreateWithoutSurveyAnswersInput = {
    id?: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
    survey: SurveyCreateNestedOneWithoutSurveyQuestionsInput
  }

  export type SurveyQuestionUncheckedCreateWithoutSurveyAnswersInput = {
    id?: string
    surveyId: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
  }

  export type SurveyQuestionCreateOrConnectWithoutSurveyAnswersInput = {
    where: SurveyQuestionWhereUniqueInput
    create: XOR<SurveyQuestionCreateWithoutSurveyAnswersInput, SurveyQuestionUncheckedCreateWithoutSurveyAnswersInput>
  }

  export type SurveyResponseUpsertWithoutSurveyAnswersInput = {
    update: XOR<SurveyResponseUpdateWithoutSurveyAnswersInput, SurveyResponseUncheckedUpdateWithoutSurveyAnswersInput>
    create: XOR<SurveyResponseCreateWithoutSurveyAnswersInput, SurveyResponseUncheckedCreateWithoutSurveyAnswersInput>
    where?: SurveyResponseWhereInput
  }

  export type SurveyResponseUpdateToOneWithWhereWithoutSurveyAnswersInput = {
    where?: SurveyResponseWhereInput
    data: XOR<SurveyResponseUpdateWithoutSurveyAnswersInput, SurveyResponseUncheckedUpdateWithoutSurveyAnswersInput>
  }

  export type SurveyResponseUpdateWithoutSurveyAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutSurveyResponsesNestedInput
    userProfile?: UserProfileUpdateOneRequiredWithoutSurveyResponsesNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutSurveyAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyQuestionUpsertWithoutSurveyAnswersInput = {
    update: XOR<SurveyQuestionUpdateWithoutSurveyAnswersInput, SurveyQuestionUncheckedUpdateWithoutSurveyAnswersInput>
    create: XOR<SurveyQuestionCreateWithoutSurveyAnswersInput, SurveyQuestionUncheckedCreateWithoutSurveyAnswersInput>
    where?: SurveyQuestionWhereInput
  }

  export type SurveyQuestionUpdateToOneWithWhereWithoutSurveyAnswersInput = {
    where?: SurveyQuestionWhereInput
    data: XOR<SurveyQuestionUpdateWithoutSurveyAnswersInput, SurveyQuestionUncheckedUpdateWithoutSurveyAnswersInput>
  }

  export type SurveyQuestionUpdateWithoutSurveyAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    survey?: SurveyUpdateOneRequiredWithoutSurveyQuestionsNestedInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutSurveyAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type AccountCreateWithoutAnalyticsReportsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutAnalyticsReportsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutAnalyticsReportsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAnalyticsReportsInput, AccountUncheckedCreateWithoutAnalyticsReportsInput>
  }

  export type AccountUpsertWithoutAnalyticsReportsInput = {
    update: XOR<AccountUpdateWithoutAnalyticsReportsInput, AccountUncheckedUpdateWithoutAnalyticsReportsInput>
    create: XOR<AccountCreateWithoutAnalyticsReportsInput, AccountUncheckedCreateWithoutAnalyticsReportsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAnalyticsReportsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAnalyticsReportsInput, AccountUncheckedUpdateWithoutAnalyticsReportsInput>
  }

  export type AccountUpdateWithoutAnalyticsReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutAnalyticsReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateWithoutPredictionModelsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    systemLogs?: SystemLogCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutPredictionModelsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    systemLogs?: SystemLogUncheckedCreateNestedManyWithoutUserInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutPredictionModelsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPredictionModelsInput, AccountUncheckedCreateWithoutPredictionModelsInput>
  }

  export type AccountUpsertWithoutPredictionModelsInput = {
    update: XOR<AccountUpdateWithoutPredictionModelsInput, AccountUncheckedUpdateWithoutPredictionModelsInput>
    create: XOR<AccountCreateWithoutPredictionModelsInput, AccountUncheckedCreateWithoutPredictionModelsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPredictionModelsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPredictionModelsInput, AccountUncheckedUpdateWithoutPredictionModelsInput>
  }

  export type AccountUpdateWithoutPredictionModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    systemLogs?: SystemLogUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutPredictionModelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    systemLogs?: SystemLogUncheckedUpdateManyWithoutUserNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AccountCreateWithoutSystemLogsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerCreateNestedManyWithoutAccountInput
    events?: EventCreateNestedManyWithoutCreatorInput
    surveys?: SurveyCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelCreateNestedManyWithoutCreatorInput
    medicalPrograms?: MedicalProgramCreateNestedManyWithoutCreatorInput
  }

  export type AccountUncheckedCreateWithoutSystemLogsInput = {
    id?: string
    email: string
    password: string
    role: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profilePictureUrl?: string | null
    emailVerified?: boolean
    userProfile?: UserProfileUncheckedCreateNestedOneWithoutAccountInput
    healthWorkers?: HealthWorkerUncheckedCreateNestedManyWithoutAccountInput
    events?: EventUncheckedCreateNestedManyWithoutCreatorInput
    surveys?: SurveyUncheckedCreateNestedManyWithoutCreatorInput
    inquiryResponses?: InquiryResponseUncheckedCreateNestedManyWithoutResponderInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutGeneratorInput
    predictionModels?: PredictionModelUncheckedCreateNestedManyWithoutCreatorInput
    medicalPrograms?: MedicalProgramUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type AccountCreateOrConnectWithoutSystemLogsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSystemLogsInput, AccountUncheckedCreateWithoutSystemLogsInput>
  }

  export type AccountUpsertWithoutSystemLogsInput = {
    update: XOR<AccountUpdateWithoutSystemLogsInput, AccountUncheckedUpdateWithoutSystemLogsInput>
    create: XOR<AccountCreateWithoutSystemLogsInput, AccountUncheckedCreateWithoutSystemLogsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSystemLogsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSystemLogsInput, AccountUncheckedUpdateWithoutSystemLogsInput>
  }

  export type AccountUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUpdateManyWithoutAccountNestedInput
    events?: EventUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUpdateManyWithoutCreatorNestedInput
    medicalPrograms?: MedicalProgramUpdateManyWithoutCreatorNestedInput
  }

  export type AccountUncheckedUpdateWithoutSystemLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    userProfile?: UserProfileUncheckedUpdateOneWithoutAccountNestedInput
    healthWorkers?: HealthWorkerUncheckedUpdateManyWithoutAccountNestedInput
    events?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    surveys?: SurveyUncheckedUpdateManyWithoutCreatorNestedInput
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutResponderNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutGeneratorNestedInput
    predictionModels?: PredictionModelUncheckedUpdateManyWithoutCreatorNestedInput
    medicalPrograms?: MedicalProgramUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type HealthWorkerCreateManyAccountInput = {
    id?: string
    name: string
    role: string
    contactNumber: string
    signature?: string | null
    isActive?: boolean
  }

  export type EventCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    eventType: string
    eventDate: Date | string
    startTime: string
    endTime: string
    venue: string
    targetAudience?: string | null
    maxParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
  }

  export type SurveyCreateManyCreatorInput = {
    id?: string
    title: string
    description: string
    surveyType: string
    isActive?: boolean
    startDate: Date | string
    endDate: Date | string
    qrCode?: string | null
    createdAt?: Date | string
  }

  export type InquiryResponseCreateManyResponderInput = {
    id?: string
    inquiryId: string
    message: string
  }

  export type AnalyticsReportCreateManyGeneratorInput = {
    id?: string
    reportName: string
    reportType: string
    dataFilters: JsonNullValueInput | InputJsonValue
    reportData: JsonNullValueInput | InputJsonValue
    reportPeriodStart: Date | string
    reportPeriodEnd: Date | string
  }

  export type PredictionModelCreateManyCreatorInput = {
    id?: string
    modelName: string
    modelType: string
    modelParameters: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: number | null
    lastTrained?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type SystemLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type MedicalProgramCreateManyCreatorInput = {
    id?: string
    programName: string
    description: string
    programType: string
    startDate: Date | string
    endDate: Date | string
    venue: string
    targetDemographic?: string | null
    targetParticipants?: number | null
    status: string
    bannerImageUrl?: string | null
    createdAt?: Date | string
  }

  export type HealthWorkerUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    virtualCheckups?: VirtualCheckupUpdateManyWithoutHealthWorkerNestedInput
  }

  export type HealthWorkerUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    virtualCheckups?: VirtualCheckupUncheckedUpdateManyWithoutHealthWorkerNestedInput
  }

  export type HealthWorkerUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventRegistrations?: EventRegistrationUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    targetAudience?: NullableStringFieldUpdateOperationsInput | string | null
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUpdateManyWithoutSurveyNestedInput
    surveyResponses?: SurveyResponseUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyQuestions?: SurveyQuestionUncheckedUpdateManyWithoutSurveyNestedInput
    surveyResponses?: SurveyResponseUncheckedUpdateManyWithoutSurveyNestedInput
  }

  export type SurveyUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    surveyType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryResponseUpdateWithoutResponderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    inquiry?: InquiryUpdateOneRequiredWithoutInquiryResponsesNestedInput
  }

  export type InquiryResponseUncheckedUpdateWithoutResponderInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryResponseUncheckedUpdateManyWithoutResponderInput = {
    id?: StringFieldUpdateOperationsInput | string
    inquiryId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
  }

  export type AnalyticsReportUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    dataFilters?: JsonNullValueInput | InputJsonValue
    reportData?: JsonNullValueInput | InputJsonValue
    reportPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reportPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    dataFilters?: JsonNullValueInput | InputJsonValue
    reportData?: JsonNullValueInput | InputJsonValue
    reportPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reportPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateManyWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportName?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    dataFilters?: JsonNullValueInput | InputJsonValue
    reportData?: JsonNullValueInput | InputJsonValue
    reportPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    reportPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionModelUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    modelParameters?: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTrained?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionModelUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    modelParameters?: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTrained?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionModelUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelName?: StringFieldUpdateOperationsInput | string
    modelType?: StringFieldUpdateOperationsInput | string
    modelParameters?: JsonNullValueInput | InputJsonValue
    predictionResults?: NullableJsonNullValueInput | InputJsonValue
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    lastTrained?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldData?: NullableJsonNullValueInput | InputJsonValue
    newData?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalProgramUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programParticipations?: ProgramParticipationUpdateManyWithoutMedicalProgramNestedInput
  }

  export type MedicalProgramUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programParticipations?: ProgramParticipationUncheckedUpdateManyWithoutMedicalProgramNestedInput
  }

  export type MedicalProgramUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    programName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    programType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: StringFieldUpdateOperationsInput | string
    targetDemographic?: NullableStringFieldUpdateOperationsInput | string | null
    targetParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    bannerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyRecordCreateManyHeadOfFamilyInput = {
    id?: string
    familyId: string
    address: string
    contactNumber: string
    smsConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamilyMemberCreateManyUserProfileInput = {
    id?: string
    familyRecordId: string
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
  }

  export type MaternalHealthCreateManyUserProfileInput = {
    id?: string
    mothersName: string
    mothersAge: number
    mothersBirthday: Date | string
    mothersMaidenName: string
    mothersReligion?: string | null
    mothersEducation?: string | null
    mothersOccupation?: string | null
    numberOfChildren: number
    gravidaPara: string
    menarcheAge: number
    lastMenstrualPeriod: Date | string
    expectedDeliveryDate: Date | string
    tetanusToxoidStatus?: string | null
    createdAt?: Date | string
  }

  export type BirthInformationCreateManyUserProfileInput = {
    id?: string
    maternalHealthId: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
  }

  export type ImmunizationEventCreateManyUserProfileInput = {
    id?: string
    visitDate: Date | string
    temperatureCelsius?: number | null
    weightKg?: number | null
    heightCm?: number | null
    adverseReactions?: string | null
    healthWorkerName: string
    healthWorkerSignature?: string | null
    nextFollowupDate?: Date | string | null
    recordedBy: string
  }

  export type VitalSignsCreateManyUserProfileInput = {
    id?: string
    recordDate: Date | string
    bloodPressure?: string | null
    heartRate?: number | null
    respiratoryRate?: number | null
    temperatureCelsius?: number | null
    pulseRate?: number | null
    recordedBy: string
  }

  export type AnthropometricMeasurementCreateManyUserProfileInput = {
    id?: string
    measurementDate: Date | string
    weightKg?: number | null
    heightCm?: number | null
    headCircumferenceCm?: number | null
    waistCircumferenceCm?: number | null
    bmi?: number | null
    recordedBy: string
  }

  export type GrowthTrackingCreateManyUserProfileInput = {
    id?: string
    trackingDate: Date | string
    weightForAge?: string | null
    heightForAge?: string | null
    weightForHeight?: string | null
    recordedBy: string
  }

  export type NCDRiskAssessmentCreateManyUserProfileInput = {
    id?: string
    assessmentDate: Date | string
    smokingStatus?: string | null
    alcoholIntake?: string | null
    physicalActivity?: string | null
    fruitVegetableIntake?: string | null
    familyHistoryDiabetes?: boolean
    familyHistoryHypertension?: boolean
    familyHistoryHeartDisease?: boolean
    familyHistoryStroke?: boolean
    screeningCompleted?: boolean
    followUpNeeded?: boolean
    lifestyleModifications: JsonNullValueInput | InputJsonValue
    healthEducationReceived: JsonNullValueInput | InputJsonValue
    recordedBy: string
  }

  export type VisitRecordCreateManyUserProfileInput = {
    id?: string
    visitDate: Date | string
    visitType: string
    visitFrequency?: string | null
    referred?: boolean
    facilityName?: string | null
    referralReason?: string | null
    recordedBy: string
  }

  export type HealthEducationCreateManyUserProfileInput = {
    id?: string
    topicsCovered: JsonNullValueInput | InputJsonValue
    dateProvided: Date | string
    providedBy: string
  }

  export type NutritionalCounselingCreateManyUserProfileInput = {
    id?: string
    recommendations: string
    dateProvided: Date | string
    providedBy: string
  }

  export type ReferralCreateManyUserProfileInput = {
    id?: string
    facilityName: string
    reason: string
    dateReferred: Date | string
    status: string
    referredBy: string
  }

  export type AppointmentCreateManyUserProfileInput = {
    id?: string
    nextVisitDate: Date | string
    visitType: string
    appointmentStatus: string
    scheduledBy: string
    createdAt?: Date | string
  }

  export type ImmunizationReminderCreateManyUserProfileInput = {
    id?: string
    vaccineName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type TestReminderCreateManyUserProfileInput = {
    id?: string
    testName: string
    dueDate: Date | string
    reminderSent?: boolean
    sentAt?: Date | string | null
  }

  export type VirtualCheckupCreateManyUserProfileInput = {
    id?: string
    healthWorkerId: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
  }

  export type EventRegistrationCreateManyUserProfileInput = {
    id?: string
    eventId: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
  }

  export type ProgramParticipationCreateManyUserProfileInput = {
    id?: string
    medicalProgramId: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
  }

  export type InquiryCreateManyUserProfileInput = {
    id?: string
    subject: string
    message: string
    priority: string
    status: string
    category?: string | null
    createdAt?: Date | string
  }

  export type SurveyResponseCreateManyUserProfileInput = {
    id?: string
    surveyId: string
    ipAddress?: string | null
    submittedAt?: Date | string
  }

  export type FamilyRecordUpdateWithoutHeadOfFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyMemberUpdateManyWithoutFamilyRecordNestedInput
    familyHealthHistory?: FamilyHealthHistoryUpdateOneWithoutFamilyRecordNestedInput
  }

  export type FamilyRecordUncheckedUpdateWithoutHeadOfFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: FamilyMemberUncheckedUpdateManyWithoutFamilyRecordNestedInput
    familyHealthHistory?: FamilyHealthHistoryUncheckedUpdateOneWithoutFamilyRecordNestedInput
  }

  export type FamilyRecordUncheckedUpdateManyWithoutHeadOfFamilyInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyId?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    smsConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    familyRecord?: FamilyRecordUpdateOneRequiredWithoutMembersNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyRecordId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyMemberUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    familyRecordId?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
  }

  export type MaternalHealthUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenatalVisits?: PrenatalVisitUpdateManyWithoutMaternalHealthNestedInput
    birthInformation?: BirthInformationUpdateManyWithoutMaternalHealthNestedInput
  }

  export type MaternalHealthUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prenatalVisits?: PrenatalVisitUncheckedUpdateManyWithoutMaternalHealthNestedInput
    birthInformation?: BirthInformationUncheckedUpdateManyWithoutMaternalHealthNestedInput
  }

  export type MaternalHealthUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    mothersName?: StringFieldUpdateOperationsInput | string
    mothersAge?: IntFieldUpdateOperationsInput | number
    mothersBirthday?: DateTimeFieldUpdateOperationsInput | Date | string
    mothersMaidenName?: StringFieldUpdateOperationsInput | string
    mothersReligion?: NullableStringFieldUpdateOperationsInput | string | null
    mothersEducation?: NullableStringFieldUpdateOperationsInput | string | null
    mothersOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfChildren?: IntFieldUpdateOperationsInput | number
    gravidaPara?: StringFieldUpdateOperationsInput | string
    menarcheAge?: IntFieldUpdateOperationsInput | number
    lastMenstrualPeriod?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDeliveryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tetanusToxoidStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BirthInformationUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    maternalHealth?: MaternalHealthUpdateOneRequiredWithoutBirthInformationNestedInput
  }

  export type BirthInformationUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type BirthInformationUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    maternalHealthId?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ImmunizationEventUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    vaccinesGiven?: VaccineGivenUpdateManyWithoutImmunizationEventNestedInput
  }

  export type ImmunizationEventUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    vaccinesGiven?: VaccineGivenUncheckedUpdateManyWithoutImmunizationEventNestedInput
  }

  export type ImmunizationEventUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    adverseReactions?: NullableStringFieldUpdateOperationsInput | string | null
    healthWorkerName?: StringFieldUpdateOperationsInput | string
    healthWorkerSignature?: NullableStringFieldUpdateOperationsInput | string | null
    nextFollowupDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VitalSignsUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    pulseRate?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VitalSignsUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    pulseRate?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VitalSignsUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordDate?: DateTimeFieldUpdateOperationsInput | Date | string
    bloodPressure?: NullableStringFieldUpdateOperationsInput | string | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    respiratoryRate?: NullableIntFieldUpdateOperationsInput | number | null
    temperatureCelsius?: NullableFloatFieldUpdateOperationsInput | number | null
    pulseRate?: NullableIntFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnthropometricMeasurementUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    headCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    waistCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnthropometricMeasurementUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    headCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    waistCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type AnthropometricMeasurementUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    measurementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    headCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    waistCircumferenceCm?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type GrowthTrackingUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    heightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    weightForHeight?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type GrowthTrackingUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    heightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    weightForHeight?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type GrowthTrackingUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    trackingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    weightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    heightForAge?: NullableStringFieldUpdateOperationsInput | string | null
    weightForHeight?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NCDRiskAssessmentUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    smokingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    alcoholIntake?: NullableStringFieldUpdateOperationsInput | string | null
    physicalActivity?: NullableStringFieldUpdateOperationsInput | string | null
    fruitVegetableIntake?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistoryDiabetes?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHypertension?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHeartDisease?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryStroke?: BoolFieldUpdateOperationsInput | boolean
    screeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    followUpNeeded?: BoolFieldUpdateOperationsInput | boolean
    lifestyleModifications?: JsonNullValueInput | InputJsonValue
    healthEducationReceived?: JsonNullValueInput | InputJsonValue
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NCDRiskAssessmentUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    smokingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    alcoholIntake?: NullableStringFieldUpdateOperationsInput | string | null
    physicalActivity?: NullableStringFieldUpdateOperationsInput | string | null
    fruitVegetableIntake?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistoryDiabetes?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHypertension?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHeartDisease?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryStroke?: BoolFieldUpdateOperationsInput | boolean
    screeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    followUpNeeded?: BoolFieldUpdateOperationsInput | boolean
    lifestyleModifications?: JsonNullValueInput | InputJsonValue
    healthEducationReceived?: JsonNullValueInput | InputJsonValue
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NCDRiskAssessmentUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    assessmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    smokingStatus?: NullableStringFieldUpdateOperationsInput | string | null
    alcoholIntake?: NullableStringFieldUpdateOperationsInput | string | null
    physicalActivity?: NullableStringFieldUpdateOperationsInput | string | null
    fruitVegetableIntake?: NullableStringFieldUpdateOperationsInput | string | null
    familyHistoryDiabetes?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHypertension?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryHeartDisease?: BoolFieldUpdateOperationsInput | boolean
    familyHistoryStroke?: BoolFieldUpdateOperationsInput | boolean
    screeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    followUpNeeded?: BoolFieldUpdateOperationsInput | boolean
    lifestyleModifications?: JsonNullValueInput | InputJsonValue
    healthEducationReceived?: JsonNullValueInput | InputJsonValue
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VisitRecordUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    visitFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    facilityName?: NullableStringFieldUpdateOperationsInput | string | null
    referralReason?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VisitRecordUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    visitFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    facilityName?: NullableStringFieldUpdateOperationsInput | string | null
    referralReason?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type VisitRecordUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    visitFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    facilityName?: NullableStringFieldUpdateOperationsInput | string | null
    referralReason?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type HealthEducationUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicsCovered?: JsonNullValueInput | InputJsonValue
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type HealthEducationUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicsCovered?: JsonNullValueInput | InputJsonValue
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type HealthEducationUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicsCovered?: JsonNullValueInput | InputJsonValue
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalCounselingUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalCounselingUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type NutritionalCounselingUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    recommendations?: StringFieldUpdateOperationsInput | string
    dateProvided?: DateTimeFieldUpdateOperationsInput | Date | string
    providedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    dateReferred?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    referredBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    dateReferred?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    referredBy?: StringFieldUpdateOperationsInput | string
  }

  export type ReferralUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    facilityName?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    dateReferred?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    referredBy?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    appointmentStatus?: StringFieldUpdateOperationsInput | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    appointmentStatus?: StringFieldUpdateOperationsInput | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: StringFieldUpdateOperationsInput | string
    appointmentStatus?: StringFieldUpdateOperationsInput | string
    scheduledBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImmunizationReminderUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImmunizationReminderUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ImmunizationReminderUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestReminderUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestReminderUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TestReminderUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reminderSent?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VirtualCheckupUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthWorker?: HealthWorkerUpdateOneRequiredWithoutVirtualCheckupsNestedInput
    virtualCheckupNotes?: VirtualCheckupNoteUpdateManyWithoutVirtualCheckupNestedInput
  }

  export type VirtualCheckupUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthWorkerId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualCheckupNotes?: VirtualCheckupNoteUncheckedUpdateManyWithoutVirtualCheckupNestedInput
  }

  export type VirtualCheckupUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    healthWorkerId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    event?: EventUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventRegistrationUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramParticipationUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    medicalProgram?: MedicalProgramUpdateOneRequiredWithoutProgramParticipationsNestedInput
  }

  export type ProgramParticipationUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalProgramId?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicalProgramId?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inquiryResponses?: InquiryResponseUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inquiryResponses?: InquiryResponseUncheckedUpdateManyWithoutInquiryNestedInput
  }

  export type InquiryUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyResponseUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    survey?: SurveyUpdateOneRequiredWithoutSurveyResponsesNestedInput
    surveyAnswers?: SurveyAnswerUpdateManyWithoutSurveyResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyAnswers?: SurveyAnswerUncheckedUpdateManyWithoutSurveyResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateManyWithoutUserProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualCheckupCreateManyHealthWorkerInput = {
    id?: string
    userProfileId: string
    scheduledDate: Date | string
    scheduledTime: string
    meetingUrl?: string | null
    status: string
    consultationType?: string | null
    chiefComplaint?: string | null
    notes?: string | null
    durationMinutes?: number | null
    createdAt?: Date | string
  }

  export type VirtualCheckupUpdateWithoutHealthWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutVirtualCheckupsNestedInput
    virtualCheckupNotes?: VirtualCheckupNoteUpdateManyWithoutVirtualCheckupNestedInput
  }

  export type VirtualCheckupUncheckedUpdateWithoutHealthWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    virtualCheckupNotes?: VirtualCheckupNoteUncheckedUpdateManyWithoutVirtualCheckupNestedInput
  }

  export type VirtualCheckupUncheckedUpdateManyWithoutHealthWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    consultationType?: NullableStringFieldUpdateOperationsInput | string | null
    chiefComplaint?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    durationMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamilyMemberCreateManyFamilyRecordInput = {
    id?: string
    userProfileId?: string | null
    memberName: string
    relationship: string
    gender: string
    age: number
    occupation?: string | null
    civilStatus: string
  }

  export type FamilyMemberUpdateWithoutFamilyRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneWithoutFamilyMembersNestedInput
  }

  export type FamilyMemberUncheckedUpdateWithoutFamilyRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
  }

  export type FamilyMemberUncheckedUpdateManyWithoutFamilyRecordInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    memberName?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    civilStatus?: StringFieldUpdateOperationsInput | string
  }

  export type PrenatalVisitCreateManyMaternalHealthInput = {
    id?: string
    visitDate: Date | string
    gestationalAgeWeeks: number
    weightKg: number
    heightCm: number
    bloodPressure: string
    fundalHeightCm: number
    fetalHeartTone: string
    nextVisitDate?: Date | string | null
    recordedBy: string
  }

  export type BirthInformationCreateManyMaternalHealthInput = {
    id?: string
    userProfileId: string
    placeOfDelivery: string
    timeOfDelivery: string
    deliveryType: string
    birthWeightKg: number
    birthHeightCm: number
    newbornScreeningDate?: Date | string | null
    newbornScreeningCompleted?: boolean
    feedingType: string
    createdAt?: Date | string
    recordedBy: string
  }

  export type PrenatalVisitUpdateWithoutMaternalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    laboratoryTests?: LaboratoryTestUpdateManyWithoutPrenatalVisitNestedInput
    interventions?: InterventionUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type PrenatalVisitUncheckedUpdateWithoutMaternalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    laboratoryTests?: LaboratoryTestUncheckedUpdateManyWithoutPrenatalVisitNestedInput
    interventions?: InterventionUncheckedUpdateManyWithoutPrenatalVisitNestedInput
  }

  export type PrenatalVisitUncheckedUpdateManyWithoutMaternalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gestationalAgeWeeks?: IntFieldUpdateOperationsInput | number
    weightKg?: FloatFieldUpdateOperationsInput | number
    heightCm?: FloatFieldUpdateOperationsInput | number
    bloodPressure?: StringFieldUpdateOperationsInput | string
    fundalHeightCm?: FloatFieldUpdateOperationsInput | number
    fetalHeartTone?: StringFieldUpdateOperationsInput | string
    nextVisitDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type BirthInformationUpdateWithoutMaternalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutBirthInformationNestedInput
  }

  export type BirthInformationUncheckedUpdateWithoutMaternalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type BirthInformationUncheckedUpdateManyWithoutMaternalHealthInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    placeOfDelivery?: StringFieldUpdateOperationsInput | string
    timeOfDelivery?: StringFieldUpdateOperationsInput | string
    deliveryType?: StringFieldUpdateOperationsInput | string
    birthWeightKg?: FloatFieldUpdateOperationsInput | number
    birthHeightCm?: FloatFieldUpdateOperationsInput | number
    newbornScreeningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newbornScreeningCompleted?: BoolFieldUpdateOperationsInput | boolean
    feedingType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryTestCreateManyPrenatalVisitInput = {
    id?: string
    userProfileId: string
    testDate: Date | string
    testType: string
    testCompleted?: boolean
    recordedBy: string
  }

  export type InterventionCreateManyPrenatalVisitInput = {
    id?: string
    tetanusToxoidDose?: string | null
    tetanusToxoidLocation?: string | null
    tetanusToxoidDate?: Date | string | null
    ironSupplementation?: boolean
    ironMedication?: string | null
    vitaminSupplementation?: boolean
    vitaminMedication?: string | null
    calciumSupplementation?: boolean
    calciumMedication?: string | null
    healthEducationTopics: JsonNullValueInput | InputJsonValue
  }

  export type LaboratoryTestUpdateWithoutPrenatalVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    testType?: StringFieldUpdateOperationsInput | string
    testCompleted?: BoolFieldUpdateOperationsInput | boolean
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryTestUncheckedUpdateWithoutPrenatalVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    testType?: StringFieldUpdateOperationsInput | string
    testCompleted?: BoolFieldUpdateOperationsInput | boolean
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type LaboratoryTestUncheckedUpdateManyWithoutPrenatalVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    testDate?: DateTimeFieldUpdateOperationsInput | Date | string
    testType?: StringFieldUpdateOperationsInput | string
    testCompleted?: BoolFieldUpdateOperationsInput | boolean
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type InterventionUpdateWithoutPrenatalVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetanusToxoidDose?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidLocation?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ironSupplementation?: BoolFieldUpdateOperationsInput | boolean
    ironMedication?: NullableStringFieldUpdateOperationsInput | string | null
    vitaminSupplementation?: BoolFieldUpdateOperationsInput | boolean
    vitaminMedication?: NullableStringFieldUpdateOperationsInput | string | null
    calciumSupplementation?: BoolFieldUpdateOperationsInput | boolean
    calciumMedication?: NullableStringFieldUpdateOperationsInput | string | null
    healthEducationTopics?: JsonNullValueInput | InputJsonValue
  }

  export type InterventionUncheckedUpdateWithoutPrenatalVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetanusToxoidDose?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidLocation?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ironSupplementation?: BoolFieldUpdateOperationsInput | boolean
    ironMedication?: NullableStringFieldUpdateOperationsInput | string | null
    vitaminSupplementation?: BoolFieldUpdateOperationsInput | boolean
    vitaminMedication?: NullableStringFieldUpdateOperationsInput | string | null
    calciumSupplementation?: BoolFieldUpdateOperationsInput | boolean
    calciumMedication?: NullableStringFieldUpdateOperationsInput | string | null
    healthEducationTopics?: JsonNullValueInput | InputJsonValue
  }

  export type InterventionUncheckedUpdateManyWithoutPrenatalVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    tetanusToxoidDose?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidLocation?: NullableStringFieldUpdateOperationsInput | string | null
    tetanusToxoidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ironSupplementation?: BoolFieldUpdateOperationsInput | boolean
    ironMedication?: NullableStringFieldUpdateOperationsInput | string | null
    vitaminSupplementation?: BoolFieldUpdateOperationsInput | boolean
    vitaminMedication?: NullableStringFieldUpdateOperationsInput | string | null
    calciumSupplementation?: BoolFieldUpdateOperationsInput | boolean
    calciumMedication?: NullableStringFieldUpdateOperationsInput | string | null
    healthEducationTopics?: JsonNullValueInput | InputJsonValue
  }

  export type VaccineGivenCreateManyImmunizationEventInput = {
    id?: string
    vaccineName: string
    doseNumber: string
    dateGiven: Date | string
    lotNumber?: string | null
  }

  export type VaccineGivenUpdateWithoutImmunizationEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    doseNumber?: StringFieldUpdateOperationsInput | string
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VaccineGivenUncheckedUpdateWithoutImmunizationEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    doseNumber?: StringFieldUpdateOperationsInput | string
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VaccineGivenUncheckedUpdateManyWithoutImmunizationEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    vaccineName?: StringFieldUpdateOperationsInput | string
    doseNumber?: StringFieldUpdateOperationsInput | string
    dateGiven?: DateTimeFieldUpdateOperationsInput | Date | string
    lotNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VirtualCheckupNoteCreateManyVirtualCheckupInput = {
    id?: string
    note: string
    createdBy: string
  }

  export type VirtualCheckupNoteUpdateWithoutVirtualCheckupInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualCheckupNoteUncheckedUpdateWithoutVirtualCheckupInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualCheckupNoteUncheckedUpdateManyWithoutVirtualCheckupInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
  }

  export type EventRegistrationCreateManyEventInput = {
    id?: string
    userProfileId: string
    registrationDate?: Date | string
    status: string
    notes?: string | null
  }

  export type EventRegistrationUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    userProfile?: UserProfileUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProgramParticipationCreateManyMedicalProgramInput = {
    id?: string
    userProfileId: string
    participationDate: Date | string
    status: string
    servicesReceived?: string | null
    notes?: string | null
    recordedBy: string
  }

  export type ProgramParticipationUpdateWithoutMedicalProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    userProfile?: UserProfileUpdateOneRequiredWithoutProgramParticipationsNestedInput
  }

  export type ProgramParticipationUncheckedUpdateWithoutMedicalProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramParticipationUncheckedUpdateManyWithoutMedicalProgramInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    participationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    servicesReceived?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryResponseCreateManyInquiryInput = {
    id?: string
    message: string
    respondedBy: string
  }

  export type InquiryResponseUpdateWithoutInquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    responder?: AccountUpdateOneRequiredWithoutInquiryResponsesNestedInput
  }

  export type InquiryResponseUncheckedUpdateWithoutInquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    respondedBy?: StringFieldUpdateOperationsInput | string
  }

  export type InquiryResponseUncheckedUpdateManyWithoutInquiryInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    respondedBy?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyQuestionCreateManySurveyInput = {
    id?: string
    questionText: string
    questionType: string
    options: JsonNullValueInput | InputJsonValue
    isRequired?: boolean
    orderIndex: number
  }

  export type SurveyResponseCreateManySurveyInput = {
    id?: string
    userProfileId: string
    ipAddress?: string | null
    submittedAt?: Date | string
  }

  export type SurveyQuestionUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    surveyAnswers?: SurveyAnswerUpdateManyWithoutSurveyQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
    surveyAnswers?: SurveyAnswerUncheckedUpdateManyWithoutSurveyQuestionNestedInput
  }

  export type SurveyQuestionUncheckedUpdateManyWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: StringFieldUpdateOperationsInput | string
    options?: JsonNullValueInput | InputJsonValue
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    orderIndex?: IntFieldUpdateOperationsInput | number
  }

  export type SurveyResponseUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProfile?: UserProfileUpdateOneRequiredWithoutSurveyResponsesNestedInput
    surveyAnswers?: SurveyAnswerUpdateManyWithoutSurveyResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    surveyAnswers?: SurveyAnswerUncheckedUpdateManyWithoutSurveyResponseNestedInput
  }

  export type SurveyResponseUncheckedUpdateManyWithoutSurveyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurveyAnswerCreateManySurveyQuestionInput = {
    id?: string
    surveyResponseId: string
    answer: string
  }

  export type SurveyAnswerUpdateWithoutSurveyQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    surveyResponse?: SurveyResponseUpdateOneRequiredWithoutSurveyAnswersNestedInput
  }

  export type SurveyAnswerUncheckedUpdateWithoutSurveyQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyResponseId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyAnswerUncheckedUpdateManyWithoutSurveyQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyResponseId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyAnswerCreateManySurveyResponseInput = {
    id?: string
    surveyQuestionId: string
    answer: string
  }

  export type SurveyAnswerUpdateWithoutSurveyResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    surveyQuestion?: SurveyQuestionUpdateOneRequiredWithoutSurveyAnswersNestedInput
  }

  export type SurveyAnswerUncheckedUpdateWithoutSurveyResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type SurveyAnswerUncheckedUpdateManyWithoutSurveyResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    surveyQuestionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}